var REMOTE_API = {
	JAccount: {
		statik: {
			one: ["O,F", "O,O,F"],
			some: ["O,O,F"],
			cursor: ["O,O,F"],
			each: ["O,O,F", "O,O,O,F"],
			someWithRelationship: ["O,O,F"],
			someData: ["O,O,O,F"],
			getAutoCompleteData: ["S,S,F"],
			count: ["F", "O,F"],
			byRelevance: ["S,F", "S,O,F"],
			fetchVersion: ["F"],
			reserveNames: ["F", "O,F"],
			impersonate: ["S,F"],
			verifyEmailByUsername: ["S,F"],
			fetchBlockedUsers: ["O,F"],
			fetchCachedUserCount: ["F"]
		},
		instance: {
			modify: ["O,F"],
			follow: ["F", "O,F"],
			unfollow: ["F"],
			fetchFollowersWithRelationship: ["O,O,F"],
			countFollowersWithRelationship: ["O,F"],
			countFollowingWithRelationship: ["O,F"],
			fetchFollowingWithRelationship: ["O,O,F"],
			fetchTopics: ["O,O,F"],
			fetchActivityTeasers: ["O,F", "O,O,F"],
			fetchMail: ["F", "O,F"],
			fetchNotificationsTimeline: ["O,F", "O,O,F"],
			fetchActivities: ["O,F", "O,O,F"],
			fetchAppStorage: ["O,F"],
			addTags: ["O,F", "O,O,F"],
			fetchLikedContents: ["O,F", "O,O,F"],
			setEmailPreferences: ["O,F"],
			glanceActivities: ["F", "S,F"],
			fetchRole: ["F"],
			flagAccount: ["S,F"],
			unflagAccount: ["S,F"],
			isFollowing: ["S,S,F"],
			updateFlags: ["[S],F"],
			fetchGroups: ["F", "O,F"],
			fetchGroupRoles: ["S,F"],
			fetchGroupsWithPendingInvitations: ["F", "O,F"],
			fetchGroupsWithPendingRequests: ["F", "O,F"],
			cancelRequest: ["S,F"],
			acceptInvitation: ["S,F"],
			ignoreInvitation: ["S,F"],
			fetchMyGroupInvitationStatus: ["S,F"],
			fetchMyPermissions: ["F"],
			fetchMyPermissionsAndRoles: ["F"],
			fetchMyFollowingsFromGraph: ["O,F"],
			fetchMyOnlineFollowingsFromGraph: ["O,F"],
			fetchMyFollowersFromGraph: ["O,F"],
			blockUser: ["S,N,F", "O,N,F"],
			unblockUser: ["S,F", "O,F"],
			fetchRelatedTagsFromGraph: ["O,F"],
			fetchRelatedUsersFromGraph: ["O,F"],
			unlinkOauth: ["S,F"],
			changeUsername: ["O", "O,F"],
			markUserAsExempt: ["B,F"],
			userIsExempt: ["F"],
			checkGroupMembership: ["S,F"],
			fetchStorage: ["S,F"],
			fetchStorages: ["[S],F"],
			store: ["O,F"],
			unstore: ["S,F"],
			isEmailVerified: ["F"],
			fetchEmail: ["F"],
			fetchPaymentMethods: ["F"],
			fetchSubscriptions: ["F", "O,F"],
			fetchPlansAndSubscriptions: ["F", "O,F"],
			fetchEmailAndStatus: ["F"],
			fetchEmailFrequency: ["F"],
			fetchOAuthInfo: ["F"],
			fetchMyBadges: ["F"],
			fetchFromUser: ["S,F"],
			updateCountAndCheckBadge: ["O,F"],
			likeMember: ["S,F"],
			fetchKites: ["O,F"]
		}
	},
	ActiveItems: {
		statik: {
			fetchTopics: ["F", "O,F"],
			fetchUsers: ["F", "O,F"]
		},
		instance: {}
	},
	CActivity: {
		statik: {
			fetchFolloweeContents: ["O,F"],
			one: ["O,F"],
			some: ["O,O,F"],
			someData: ["O,O,F", "O,O,O,F"],
			each: ["O,O,F", "O,O,O,F"],
			cursor: ["O,O,F"],
			teasers: ["F", "O,F"],
			checkIfLikedBefore: ["[S],F"],
			count: ["F", "O,F"],
			fetchCount: ["F"],
			fetchLastActivityTimestamp: ["F"]
		},
		instance: {
			fetchTeaser: ["F", "F,B"]
		}
	},
	CRepliesActivity: {
		statik: {
			fetchFolloweeContents: ["O,F"],
			one: ["O,F"],
			some: ["O,O,F"],
			someData: ["O,O,F", "O,O,O,F"],
			each: ["O,O,F", "O,O,O,F"],
			cursor: ["O,O,F"],
			teasers: ["F", "O,F"],
			checkIfLikedBefore: ["[S],F"],
			count: ["F", "O,F"],
			fetchCount: ["F"],
			fetchLastActivityTimestamp: ["F"]
		},
		instance: {
			fetchTeaser: ["F", "F,B"]
		}
	},
	ActivityTicker: {
		statik: {
			fetch: ["F", "O,F"]
		},
		instance: {}
	},
	JNewApp: {
		statik: {
			publish: ["O,F"],
			one: ["O,F"],
			some: ["O,O,F"],
			some_: ["O,O,F"],
			each: ["O,F", "O,O,F"],
			byRelevance: ["S,F", "S,O,F"]
		},
		instance: {
			"delete": ["F"],
			approve: ["F", "B,F"]
		}
	},
	JAppStorage: {
		statik: {},
		instance: {
			save: ["F"],
			update: ["O,F"]
		}
	},
	JBadge: {
		statik: {
			listBadges: ["O,O,F"],
			create: ["O,F"],
			fetchBadgeUsers: ["S,O,F"],
			checkEligibleBadges: ["O,F"]
		},
		instance: {
			modify: ["O,F"],
			deleteBadge: ["F"],
			removeBadgeFromUser: ["O,F"],
			assignBadgeBatch: ["O,F"]
		}
	},
	CFolloweeBucketActivity: {
		statik: {},
		instance: {}
	},
	CFolloweeBucket: {
		statik: {},
		instance: {}
	},
	CFollowerBucketActivity: {
		statik: {},
		instance: {}
	},
	CFollowerBucket: {
		statik: {},
		instance: {}
	},
	CGroupJoineeActivity: {
		statik: {},
		instance: {}
	},
	CGroupJoineeBucketActivity: {
		statik: {},
		instance: {}
	},
	CGroupJoineeBucket: {
		statik: {},
		instance: {}
	},
	CGroupJoinerActivity: {
		statik: {},
		instance: {}
	},
	CGroupJoinerBucketActivity: {
		statik: {},
		instance: {}
	},
	CGroupJoinerBucket: {
		statik: {},
		instance: {}
	},
	CGroupLeaveeActivity: {
		statik: {},
		instance: {}
	},
	CGroupLeaveeBucketActivity: {
		statik: {},
		instance: {}
	},
	CGroupLeaveeBucket: {
		statik: {},
		instance: {}
	},
	CGroupLeaverActivity: {
		statik: {},
		instance: {}
	},
	CGroupLeaverBucketActivity: {
		statik: {},
		instance: {}
	},
	CGroupLeaverBucket: {
		statik: {},
		instance: {}
	},
	CInstalleeBucket: {
		statik: {},
		instance: {}
	},
	CInstalleeBucketActivity: {
		statik: {},
		instance: {}
	},
	CInstallerBucket: {
		statik: {},
		instance: {}
	},
	CInstallerBucketActivity: {
		statik: {},
		instance: {}
	},
	CLikeeBucket: {
		statik: {},
		instance: {}
	},
	CLikeeBucketActivity: {
		statik: {},
		instance: {}
	},
	CLikerBucket: {
		statik: {},
		instance: {}
	},
	CLikerBucketActivity: {
		statik: {},
		instance: {}
	},
	CNewMemberBucket: {
		statik: {},
		instance: {}
	},
	CNewMemberBucketActivity: {
		statik: {},
		instance: {}
	},
	CReplieeBucket: {
		statik: {},
		instance: {}
	},
	CReplieeBucketActivity: {
		statik: {},
		instance: {}
	},
	CReplierBucket: {
		statik: {},
		instance: {}
	},
	CReplierBucketActivity: {
		statik: {},
		instance: {}
	},
	JGroupBundle: {
		statik: {},
		instance: {}
	},
	JChatConversation: {
		statik: {
			create: ["[S],F"],
			fetch: ["S,F"],
			fetchSome: ["F", "O,F"]
		},
		instance: {
			invite: ["S,F"],
			leave: ["F"]
		}
	},
	JCustomPartials: {
		statik: {
			create: ["O,F", "O,O,F"],
			some: ["O,O,F"]
		},
		instance: {
			update: ["O,F", "O,O,F"],
			remove: ["F", "O,F"]
		}
	},
	JDomain: {
		statik: {
			one: ["O,F"],
			fetchDomains: ["F"],
			createDomain: ["O,F"]
		},
		instance: {
			bindVM: ["O,F"],
			unbindVM: ["O,F"],
			remove: ["F"]
		}
	},
	JMail: {
		statik: {
			unsubscribeWithId: ["S,S,S,F"]
		},
		instance: {}
	},
	JMailNotification: {
		statik: {
			unsubscribeWithId: ["S,S,S,F"]
		},
		instance: {}
	},
	OAuth: {
		statik: {
			getUrl: ["S,F"]
		},
		instance: {}
	},
	JGroup: {
		statik: {
			one: ["O,F"],
			create: ["O,F"],
			each: ["O,O,F", "O,O,O,F"],
			count: ["F", "O,F"],
			byRelevance: ["S,F", "S,O,F"],
			someWithRelationship: ["O,O,F"],
			__resetAllGroups: ["F"],
			fetchMyMemberships: ["[O],F", "[O],S,F"],
			__importKodingMembers: ["F"],
			suggestUniqueSlug: ["S,F", "S,N,F"]
		},
		instance: {
			join: ["F", "O,F"],
			leave: ["F", "O,F"],
			modify: ["O,F"],
			fetchPermissions: ["F", "O,F"],
			createRole: ["O,F"],
			updatePermissions: ["O,F"],
			fetchMembers: ["F", "O,F", "O,O,F"],
			searchMembers: ["S,O,F"],
			fetchRoles: ["F", "O,F", "O,O,F"],
			fetchMyRoles: ["F"],
			fetchUserRoles: ["F", "[S],F"],
			changeMemberRoles: ["S,[S],F"],
			canOpenGroup: ["F"],
			canEditGroup: ["F"],
			fetchMembershipPolicy: ["F"],
			modifyMembershipPolicy: ["O,F"],
			requestAccess: ["F"],
			addCustomRole: ["O,F"],
			resolvePendingRequests: ["F"],
			fetchMembershipStatuses: ["F"],
			fetchAdmin: ["F"],
			inviteByEmail: ["S,O,F"],
			inviteByEmails: ["S,O,F"],
			isMember: ["O,F"],
			kickMember: ["S,F"],
			transferOwnership: ["S,F"],
			fetchRolesByClientId: ["F", "S,F"],
			fetchInvitationsFromGraph: ["S,O,F"],
			countInvitationsFromGraph: ["S,O,F"],
			fetchMembersFromGraph: ["O,F"],
			remove: ["F"],
			bulkApprove: ["N,O,F"],
			fetchNewestMembers: ["F", "O,F", "O,O,F"],
			countMembers: ["F"],
			makePayment: ["O,F"],
			fetchProducts: ["F", "S,F", "S,O,F"],
			saveInviteMessage: ["S,S", "S,S,F"],
			redeemInvitation: ["S,F"],
			fetchPaymentMethod: ["F"],
			linkPaymentMethod: ["S,F"],
			unlinkPaymentMethod: ["S,F"],
			addSubscription: ["S,F"],
			fetchSubscription: ["F"],
			fetchPermissionSetOrDefault: ["F"],
			fetchUserStatus: ["O,F"],
			fetchInvitationsByStatus: ["O,F"]
		}
	},
	JMembershipPolicy: {
		statik: {
			byGroupSlug: ["S,F"]
		},
		instance: {}
	},
	JPermissionSet: {
		statik: {},
		instance: {}
	},
	JInvitation: {
		statik: {
			inviteFriend: ["O,F"],
			create: ["S,S,O,F"],
			byCode: ["S,F"],
			suggestCode: ["F", "O,F", "O,F,N"],
			createMultiuse: ["O,F"]
		},
		instance: {
			modifyMultiuse: ["O,F"],
			remove: ["F"]
		}
	},
	JInvitationRequest: {
		statik: {},
		instance: {
			remove: ["F"],
			approve: ["F"],
			decline: ["F"]
		}
	},
	JKite: {
		statik: {
			create: ["O,F"],
			list: ["O,O,F"]
		},
		instance: {
			modify: ["O,F"],
			deleteKite: ["F"],
			fetchPlans: ["F"],
			createPlan: ["O,F"],
			deletePlan: ["O,F"]
		}
	},
	JKiteStack: {
		statik: {
			fetchInfo: ["F"],
			setInfo: ["O,F"]
		},
		instance: {}
	},
	JKodingKey: {
		statik: {
			create: ["O,F"],
			fetchAll: ["O,F"],
			fetchByKey: ["O,F"],
			registerHostnameAndKey: ["O,F"]
		},
		instance: {
			revoke: ["F"]
		}
	},
	JLocation: {
		statik: {
			importAll: ["F"],
			importStates: ["F"],
			one: ["O,F"],
			fetchStatesByCountryCode: ["S,F"]
		},
		instance: {}
	},
	CCommentActivity: {
		statik: {
			fetchFolloweeContents: ["O,F"],
			one: ["O,F"],
			some: ["O,O,F"],
			someData: ["O,O,F", "O,O,O,F"],
			each: ["O,O,F", "O,O,O,F"],
			cursor: ["O,O,F"],
			teasers: ["F", "O,F"],
			checkIfLikedBefore: ["[S],F"],
			count: ["F", "O,F"],
			fetchCount: ["F"],
			fetchLastActivityTimestamp: ["F"]
		},
		instance: {
			fetchTeaser: ["F", "F,B"]
		}
	},
	JComment: {
		statik: {
			fetchRelated: ["S,F"],
			one: ["O,F"]
		},
		instance: {
			"delete": ["F"],
			like: ["F"],
			fetchLikedByes: ["F", "O,F", "O,O,F"],
			modify: ["S,F"],
			checkIfLikedBefore: ["F"]
		}
	},
	JNewStatusUpdate: {
		statik: {
			create: ["O,F"],
			one: ["O,F"],
			fetchDataFromEmbedly: ["S,O,F", "[S],O,F"],
			updateAllSlugs: ["F", "O,F"],
			fetchFollowingFeed: ["F", "O,F"],
			fetchTopicFeed: ["F", "O,F"],
			fetchProfileFeed: ["F", "O,F"],
			fetchGroupActivity: ["F", "O,F"],
			search: ["F", "O,F"]
		},
		instance: {
			reply: ["S,F"],
			restComments: ["F", "N,F"],
			commentsByRange: ["F", "O,F"],
			like: ["F"],
			fetchLikedByes: ["F", "O,F", "O,O,F"],
			mark: ["S", "S,F"],
			unmark: ["S", "S,F"],
			fetchTags: ["F", "O,F"],
			"delete": ["F"],
			modify: ["O,F"],
			fetchRelativeComments: ["O,F"],
			checkIfLikedBefore: ["F"]
		}
	},
	CStatusActivity: {
		statik: {},
		instance: {}
	},
	JName: {
		statik: {
			one: ["O,F"],
			claimNames: ["F"]
		},
		instance: {}
	},
	JPasswordRecovery: {
		statik: {
			validate: ["S,F"],
			recoverPassword: ["S,F"],
			resendVerification: ["S,F"],
			resetPassword: ["S,S,F"],
			fetchRegistrationDetails: ["S,F"]
		},
		instance: {}
	},
	JPaymentCharge: {
		statik: {
			one: ["O,F"],
			some: ["O,O,F"],
			charge: ["O,F"]
		},
		instance: {
			cancel: ["F"]
		}
	},
	JGroupPlan: {
		statik: {
			subscribe: ["O,F"],
			hasGroupCredit: ["F"]
		},
		instance: {}
	},
	JPayment: {
		statik: {
			setPaymentInfo: ["S,O,F"],
			fetchTransactions: ["F"],
			fetchCountryDataByIp: ["S,F"],
			removePaymentMethod: ["S,F"]
		},
		instance: {}
	},
	JPaymentMethod: {
		statik: {
			create: ["O,F"]
		},
		instance: {
			associatePaymentData: ["O,F"]
		}
	},
	JPaymentPack: {
		statik: {
			create: ["O,F"],
			one: ["O,F"],
			removeByCode: ["S,F"]
		},
		instance: {
			modify: ["O,F"],
			remove: ["F"],
			fetchProducts: ["F", "O,F", "O,O,F"],
			updateProducts: ["O,F"]
		}
	},
	JPaymentPayment: {
		statik: {
			makePayment: ["O,F"]
		},
		instance: {}
	},
	JPaymentPlan: {
		statik: {
			create: ["O,F"],
			removeByCode: ["S,F"],
			fetchPlanByCode: ["S,F"],
			one: ["O,F"]
		},
		instance: {
			fetchToken: ["O,F"],
			subscribe: ["S,O,F"],
			modify: ["O,F"],
			fetchProducts: ["F", "O,F", "O,O,F"],
			updateProducts: ["O,F"],
			checkQuota: ["O,F"],
			fetchCoupon: ["S,F"]
		}
	},
	JPaymentProduct: {
		statik: {
			create: ["O,F"],
			removeByCode: ["S,F"],
			some: ["O,O,F"]
		},
		instance: {
			remove: ["F"],
			modify: ["O,F"]
		}
	},
	JResourcePlan: {
		statik: {
			subscribe: ["O,F"]
		},
		instance: {}
	},
	JPaymentSubscription: {
		statik: {
			fetchUserSubscriptions: ["F"],
			fetchUserSubscriptionsWithPlan: ["F"]
		},
		instance: {
			cancel: ["F"],
			resume: ["F"],
			checkUsage: ["O,F", "O,N,F"],
			checkQuota: ["O,F"],
			debit: ["O,F", "O,N,F"],
			credit: ["O,F"],
			transitionTo: ["O,F"]
		}
	},
	JPaymentToken: {
		statik: {
			checkToken: ["O,F"],
			createToken: ["O,F"]
		},
		instance: {}
	},
	JProxyFilter: {
		statik: {
			create: ["O,F"],
			some: ["O,O,F"]
		},
		instance: {
			remove: ["F"],
			update: ["O,F"]
		}
	},
	JProxyRestriction: {
		statik: {
			create: ["O,F"],
			remove: ["O,F"],
			some: ["O,O,F"],
			clear: ["S,F"]
		},
		instance: {}
	},
	JReferrableEmail: {
		statik: {
			invite: ["S,F"],
			getUninvitedEmails: ["F"],
			deleteEmailsForAccount: ["F"]
		},
		instance: {
			invite: ["F"]
		}
	},
	JReferralCampaign: {
		statik: {
			create: ["O,F", "O,O,F"],
			some: ["O,O,F"],
			isCampaignValid: ["S,F"]
		},
		instance: {
			update: ["O,F", "O,O,F"],
			remove: ["F", "O,F"]
		}
	},
	JReferral: {
		statik: {
			addExtraReferral: ["O,F"],
			redeem: ["O,F"],
			changeBaseVMForUsers: ["F", "O,F"],
			resetVMDefaults: ["F"],
			fetchRedeemableReferrals: ["O,F"],
			fetchReferredAccounts: ["O,O,F"]
		},
		instance: {}
	},
	SocialChannel: {
		statik: {
			fetchActivities: ["O,F"],
			fetchChannels: ["O,F"],
			fetchParticipants: ["O,F"],
			fetchPopularTopics: ["O,F"],
			fetchPinnedMessages: ["O,F"],
			pinMessage: ["O,F"],
			unpinMessage: ["O,F"],
			follow: ["O,F"],
			unfollow: ["O,F"],
			fetchFollowedChannels: ["O,F"]
		},
		instance: {}
	},
	SocialMessage: {
		statik: {
			post: ["O,F"],
			reply: ["O,F"],
			edit: ["O,F"],
			"delete": ["O,F"],
			like: ["O,F"],
			unlike: ["O,F"],
			sendPrivateMessage: ["O,F"],
			fetchPrivateMessages: ["O,F"]
		},
		instance: {}
	},
	JStack: {
		statik: {
			one: ["O,F"],
			getStack: ["F"],
			createStack: ["O,F"],
			getStacks: ["F"]
		},
		instance: {
			remove: ["F"],
			push: ["O,F"],
			updateConfig: ["S,F"]
		}
	},
	JStorage: {
		statik: {},
		instance: {}
	},
	JSystemStatus: {
		statik: {
			getCurrentSystemStatuses: ["F"],
			create: ["O,F"],
			stopCurrentSystemStatus: ["F"],
			healthCheck: ["F"],
			checkRealtimeUpdates: ["F"],
			sendFeedback: ["O,F"]
		},
		instance: {
			cancel: ["F"]
		}
	},
	JTag: {
		statik: {
			one: ["O,F", "O,O,F"],
			on: ["S,F"],
			some: ["O,O,F"],
			create: ["O,F"],
			count: ["O,F"],
			fetchCount: ["F"],
			someWithRelationship: ["O,O,F"],
			byRelevance: ["S,F", "S,O,F"],
			cursor: ["O,O,F"],
			cursorWithRelationship: ["O,O,F"],
			fetchMyFollowees: ["[O],F"],
			each: ["O,O,F", "O,O,O,F"],
			fetchSkillTags: ["O,O,F"],
			byRelevanceForSkills: ["S,F", "S,O,F"],
			fetchSystemTags: ["O,O,F"],
			createSystemTag: ["O,O,F"]
		},
		instance: {
			modify: ["O,F"],
			follow: ["F", "O,F"],
			unfollow: ["F"],
			fetchFollowersWithRelationship: ["O,O,F"],
			fetchFollowingWithRelationship: ["O,O,F"],
			fetchContents: ["F"],
			fetchContentTeasers: ["O,O,F", "O,O,O,F"],
			addSystemTagToStatusUpdate: ["O,F"],
			removeTagFromStatus: ["O,F"],
			fetchSynonym: ["F"],
			"delete": ["F"],
			fetchLastInteractors: ["O,F"],
			createSynonym: ["O,F"]
		}
	},
	JUnsubscribedMail: {
		statik: {},
		instance: {}
	},
	JUrlAlias: {
		statik: {
			create: ["S,S,F"],
			resolve: ["S,F"]
		},
		instance: {}
	},
	JUser: {
		statik: {
			login: ["O,F"],
			logout: ["F"],
			usernameAvailable: ["S,F"],
			emailAvailable: ["S,F"],
			changePassword: ["S,F"],
			changeEmail: ["O,F"],
			fetchUser: ["F"],
			whoami: ["F"],
			isRegistrationEnabled: ["F"],
			convert: ["O,F"],
			setSSHKeys: ["[O],F"],
			getSSHKeys: ["F"],
			authenticateWithOauth: ["O,F"],
			unregister: ["S,F"],
			finishRegistration: ["O,F"],
			verifyPassword: ["O,F"]
		},
		instance: {}
	},
	JVerificationToken: {
		statik: {},
		instance: {}
	},
	JVM: {
		statik: {
			fetchVms: ["F", "O,F"],
			fetchVmsByContext: ["F", "O,F"],
			fetchVmsByName: ["O,F"],
			fetchVmInfo: ["S,F"],
			fetchDomains: ["S,F"],
			removeByHostname: ["S,F"],
			someData: ["O,O,O,F"],
			count: ["O,F"],
			fetchDefaultVm: ["F"],
			resetDefaultVMLimits: ["F"],
			fetchVmRegion: ["S,F"],
			createVmByNonce: ["S,S,F"],
			createSharedVm: ["F"],
			setAlwaysOn: ["O,F"],
			updateInitScript: ["S,S,F"]
		},
		instance: {}
	}
};
var REMOTE_LOGGING_API = {
	JErrorLog: {
		statik: {
			create: ["O,F"]
		},
		instance: {}
	},
	JMetric: {
		statik: {
			create: ["O,F"]
		},
		instance: {}
	},
	JPageHit: {
		statik: {
			create: ["O,F"]
		},
		instance: {}
	}
};
var JSON;
JSON || (JSON = {}),
	function () {
		function str(a, b) {
			var c, d, e, f, h, g = gap,
				i = b[a];
			i && "object" == typeof i && "function" == typeof i.toJSON && (i = i.toJSON(a)), "function" == typeof rep && (i = rep.call(b, a, i));
			switch (typeof i) {
			case "string":
				return quote(i);
			case "number":
				return isFinite(i) ? String(i) : "null";
			case "boolean":
			case "null":
				return String(i);
			case "object":
				if (!i) return "null";
				gap += indent, h = [];
				if ("[object Array]" === Object.prototype.toString.apply(i)) {
					f = i.length;
					for (c = 0; f > c; c += 1) h[c] = str(c, i) || "null";
					e = 0 === h.length ? "[]" : gap ? "[\n" + gap + h.join(",\n" + gap) + "\n" + g + "]" : "[" + h.join(",") + "]", gap = g;
					return e
				}
				if (rep && "object" == typeof rep) {
					f = rep.length;
					for (c = 0; f > c; c += 1) "string" == typeof rep[c] && (d = rep[c], e = str(d, i), e && h.push(quote(d) + (gap ? ": " : ":") + e))
				} else
					for (d in i) Object.prototype.hasOwnProperty.call(i, d) && (e = str(d, i), e && h.push(quote(d) + (gap ? ": " : ":") + e));
				e = 0 === h.length ? "{}" : gap ? "{\n" + gap + h.join(",\n" + gap) + "\n" + g + "}" : "{" + h.join(",") + "}", gap = g;
				return e
			}
		}

		function quote(a) {
			escapable.lastIndex = 0;
			return escapable.test(a) ? '"' + a.replace(escapable, function (a) {
				var b = meta[a];
				return "string" == typeof b ? b : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
			}) + '"' : '"' + a + '"'
		}

		function f(a) {
			return 10 > a ? "0" + a : a
		}
		"function" != typeof Date.prototype.toJSON && (Date.prototype.toJSON = function () {
			return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null
		}, String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function () {
			return this.valueOf()
		});
		var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
			escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
			gap, indent, meta = {
				"\b": "\\b",
				"	": "\\t",
				"\n": "\\n",
				"\f": "\\f",
				"\r": "\\r",
				'"': '\\"',
				"\\": "\\\\"
			},
			rep;
		"function" != typeof JSON.stringify && (JSON.stringify = function (a, b, c) {
			var d;
			gap = "", indent = "";
			if ("number" == typeof c)
				for (d = 0; c > d; d += 1) indent += " ";
			else "string" == typeof c && (indent = c);
			rep = b;
			if (!b || "function" == typeof b || "object" == typeof b && "number" == typeof b.length) return str("", {
				"": a
			});
			throw new Error("JSON.stringify")
		}), "function" != typeof JSON.parse && (JSON.parse = function (text, reviver) {
			function walk(a, b) {
				var c, d, e = a[b];
				if (e && "object" == typeof e)
					for (c in e) Object.prototype.hasOwnProperty.call(e, c) && (d = walk(e, c), void 0 !== d ? e[c] = d : delete e[c]);
				return reviver.call(a, b, e)
			}
			var j;
			text = String(text), cx.lastIndex = 0, cx.test(text) && (text = text.replace(cx, function (a) {
				return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
			}));
			if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) {
				j = eval("(" + text + ")");
				return "function" == typeof reviver ? walk({
					"": j
				}, "") : j
			}
			throw new SyntaxError("JSON.parse")
		})
	}();
SockJS = function () {
	var _document = document,
		_window = window,
		utils = {},
		REventTarget = function () {};
	REventTarget.prototype.addEventListener = function (eventType, listener) {
		this._listeners || (this._listeners = {});
		eventType in this._listeners || (this._listeners[eventType] = []);
		var arr = this._listeners[eventType]; - 1 === utils.arrIndexOf(arr, listener) && arr.push(listener)
	};
	REventTarget.prototype.removeEventListener = function (eventType, listener) {
		if (this._listeners && eventType in this._listeners) {
			var arr = this._listeners[eventType],
				idx = utils.arrIndexOf(arr, listener); - 1 === idx || (arr.length > 1 ? this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1)) : delete this._listeners[eventType])
		}
	};
	REventTarget.prototype.dispatchEvent = function (event) {
		var t = event.type,
			args = Array.prototype.slice.call(arguments, 0);
		this["on" + t] && this["on" + t].apply(this, args);
		if (this._listeners && t in this._listeners)
			for (var i = 0; i < this._listeners[t].length; i++) this._listeners[t][i].apply(this, args)
	};
	var SimpleEvent = function (type, obj) {
		this.type = type;
		if ("undefined" != typeof obj)
			for (var k in obj) obj.hasOwnProperty(k) && (this[k] = obj[k])
	};
	SimpleEvent.prototype.toString = function () {
		var r = [];
		for (var k in this)
			if (this.hasOwnProperty(k)) {
				var v = this[k];
				"function" == typeof v && (v = "[function]");
				r.push(k + "=" + v)
			}
		return "SimpleEvent(" + r.join(", ") + ")"
	};
	var EventEmitter = function (events) {
		this.events = events || []
	};
	EventEmitter.prototype.emit = function (type) {
		var that = this,
			args = Array.prototype.slice.call(arguments, 1);
		!that.nuked && that["on" + type] && that["on" + type].apply(that, args); - 1 === utils.arrIndexOf(that.events, type) && utils.log("Event " + JSON.stringify(type) + " not listed " + JSON.stringify(that.events) + " in " + that)
	};
	EventEmitter.prototype.nuke = function () {
		var that = this;
		that.nuked = !0;
		for (var i = 0; i < that.events.length; i++) delete that[that.events[i]]
	};
	var random_string_chars = "abcdefghijklmnopqrstuvwxyz0123456789_";
	utils.random_string = function (length, max) {
		max = max || random_string_chars.length;
		var i, ret = [];
		for (i = 0; length > i; i++) ret.push(random_string_chars.substr(Math.floor(Math.random() * max), 1));
		return ret.join("")
	};
	utils.random_number = function (max) {
		return Math.floor(Math.random() * max)
	};
	utils.random_number_string = function (max) {
		var t = ("" + (max - 1)).length,
			p = Array(t + 1).join("0");
		return (p + utils.random_number(max)).slice(-t)
	};
	utils.getOrigin = function (url) {
		url += "/";
		var parts = url.split("/").slice(0, 3);
		return parts.join("/")
	};
	utils.isSameOriginUrl = function (url_a, url_b) {
		url_b || (url_b = _window.location.href);
		return url_a.split("/").slice(0, 3).join("/") === url_b.split("/").slice(0, 3).join("/")
	};
	utils.getParentDomain = function (url) {
		if (/^[0-9.]*$/.test(url)) return url;
		if (/^\[/.test(url)) return url;
		if (!/[.]/.test(url)) return url;
		var parts = url.split(".").slice(1);
		return parts.join(".")
	};
	utils.objectExtend = function (dst, src) {
		for (var k in src) src.hasOwnProperty(k) && (dst[k] = src[k]);
		return dst
	};
	var WPrefix = "_jp";
	utils.polluteGlobalNamespace = function () {
		WPrefix in _window || (_window[WPrefix] = {})
	};
	utils.closeFrame = function (code, reason) {
		return "c" + JSON.stringify([code, reason])
	};
	utils.userSetCode = function (code) {
		return 1e3 === code || code >= 3e3 && 4999 >= code
	};
	utils.countRTO = function (rtt) {
		var rto;
		rto = rtt > 100 ? 3 * rtt : rtt + 200;
		return rto
	};
	utils.log = function () {
		_window.console && console.log && console.log.apply && console.log.apply(console, arguments)
	};
	utils.bind = function (fun, that) {
		return fun.bind ? fun.bind(that) : function () {
			return fun.apply(that, arguments)
		}
	};
	utils.flatUrl = function (url) {
		return -1 === url.indexOf("?") && -1 === url.indexOf("#")
	};
	utils.amendUrl = function (url) {
		var dl = _document.location;
		if (!url) throw new Error("Wrong url for SockJS");
		if (!utils.flatUrl(url)) throw new Error("Only basic urls are supported in SockJS");
		0 === url.indexOf("//") && (url = dl.protocol + url);
		0 === url.indexOf("/") && (url = dl.protocol + "//" + dl.host + url);
		url = url.replace(/[/]+$/, "");
		return url
	};
	utils.arrIndexOf = function (arr, obj) {
		for (var i = 0; i < arr.length; i++)
			if (arr[i] === obj) return i;
		return -1
	};
	utils.arrSkip = function (arr, obj) {
		var idx = utils.arrIndexOf(arr, obj);
		if (-1 === idx) return arr.slice();
		var dst = arr.slice(0, idx);
		return dst.concat(arr.slice(idx + 1))
	};
	utils.isArray = Array.isArray || function (value) {
		return {}.toString.call(value).indexOf("Array") >= 0
	};
	utils.delay = function (t, fun) {
		if ("function" == typeof t) {
			fun = t;
			t = 0
		}
		return setTimeout(fun, t)
	};
	var extra_lookup, json_escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
		json_lookup = {
			"\x00": "\\u0000",
			"": "\\u0001",
			"": "\\u0002",
			"": "\\u0003",
			"": "\\u0004",
			"": "\\u0005",
			"": "\\u0006",
			"": "\\u0007",
			"\b": "\\b",
			"	": "\\t",
			"\n": "\\n",
			"": "\\u000b",
			"\f": "\\f",
			"\r": "\\r",
			"": "\\u000e",
			"": "\\u000f",
			"": "\\u0010",
			"": "\\u0011",
			"": "\\u0012",
			"": "\\u0013",
			"": "\\u0014",
			"": "\\u0015",
			"": "\\u0016",
			"": "\\u0017",
			"": "\\u0018",
			"": "\\u0019",
			"": "\\u001a",
			"": "\\u001b",
			"": "\\u001c",
			"": "\\u001d",
			"": "\\u001e",
			"": "\\u001f",
			'"': '\\"',
			"\\": "\\\\",
			"": "\\u007f",
			"": "\\u0080",
			"": "\\u0081",
			"": "\\u0082",
			"": "\\u0083",
			"": "\\u0084",
			"": "\\u0085",
			"": "\\u0086",
			"": "\\u0087",
			"": "\\u0088",
			"": "\\u0089",
			"": "\\u008a",
			"": "\\u008b",
			"": "\\u008c",
			"": "\\u008d",
			"": "\\u008e",
			"": "\\u008f",
			"": "\\u0090",
			"": "\\u0091",
			"": "\\u0092",
			"": "\\u0093",
			"": "\\u0094",
			"": "\\u0095",
			"": "\\u0096",
			"": "\\u0097",
			"": "\\u0098",
			"": "\\u0099",
			"": "\\u009a",
			"": "\\u009b",
			"": "\\u009c",
			"": "\\u009d",
			"": "\\u009e",
			"": "\\u009f",
			"Â­": "\\u00ad",
			"\u0600": "\\u0600",
			"\u0601": "\\u0601",
			"\u0602": "\\u0602",
			"\u0603": "\\u0603",
			"\u0604": "\\u0604",
			"\u070f": "\\u070f",
			"\u17b4": "\\u17b4",
			"\u17b5": "\\u17b5",
			"\u200c": "\\u200c",
			"\u200d": "\\u200d",
			"\u200e": "\\u200e",
			"\u200f": "\\u200f",
			"\u2028": "\\u2028",
			"\u2029": "\\u2029",
			"\u202a": "\\u202a",
			"\u202b": "\\u202b",
			"\u202c": "\\u202c",
			"\u202d": "\\u202d",
			"\u202e": "\\u202e",
			"\u202f": "\\u202f",
			"\u2060": "\\u2060",
			"\u2061": "\\u2061",
			"\u2062": "\\u2062",
			"\u2063": "\\u2063",
			"\u2064": "\\u2064",
			"\u2065": "\\u2065",
			"\u2066": "\\u2066",
			"\u2067": "\\u2067",
			"\u2068": "\\u2068",
			"\u2069": "\\u2069",
			"\u206a": "\\u206a",
			"\u206b": "\\u206b",
			"\u206c": "\\u206c",
			"\u206d": "\\u206d",
			"\u206e": "\\u206e",
			"\u206f": "\\u206f",
			"\ufeff": "\\ufeff",
			"\ufff0": "\\ufff0",
			"\ufff1": "\\ufff1",
			"\ufff2": "\\ufff2",
			"\ufff3": "\\ufff3",
			"\ufff4": "\\ufff4",
			"\ufff5": "\\ufff5",
			"\ufff6": "\\ufff6",
			"\ufff7": "\\ufff7",
			"\ufff8": "\\ufff8",
			"\ufff9": "\\ufff9",
			"\ufffa": "\\ufffa",
			"\ufffb": "\\ufffb",
			"\ufffc": "\\ufffc",
			"\ufffd": "\\ufffd",
			"\ufffe": "\\ufffe",
			"\uffff": "\\uffff"
		},
		extra_escapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,
		JSONQuote = JSON && JSON.stringify || function (string) {
			json_escapable.lastIndex = 0;
			json_escapable.test(string) && (string = string.replace(json_escapable, function (a) {
				return json_lookup[a]
			}));
			return '"' + string + '"'
		},
		unroll_lookup = function (escapable) {
			var i, unrolled = {},
				c = [];
			for (i = 0; 65536 > i; i++) c.push(String.fromCharCode(i));
			escapable.lastIndex = 0;
			c.join("").replace(escapable, function (a) {
				unrolled[a] = "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
				return ""
			});
			escapable.lastIndex = 0;
			return unrolled
		};
	utils.quote = function (string) {
		var quoted = JSONQuote(string);
		extra_escapable.lastIndex = 0;
		if (!extra_escapable.test(quoted)) return quoted;
		extra_lookup || (extra_lookup = unroll_lookup(extra_escapable));
		return quoted.replace(extra_escapable, function (a) {
			return extra_lookup[a]
		})
	};
	var _all_protocols = ["websocket", "xdr-streaming", "xhr-streaming", "iframe-eventsource", "iframe-htmlfile", "xdr-polling", "xhr-polling", "iframe-xhr-polling", "jsonp-polling"];
	utils.probeProtocols = function () {
		for (var probed = {}, i = 0; i < _all_protocols.length; i++) {
			var protocol = _all_protocols[i];
			probed[protocol] = SockJS[protocol] && SockJS[protocol].enabled()
		}
		return probed
	};
	utils.detectProtocols = function (probed, protocols_whitelist, info) {
		var pe = {},
			protocols = [];
		protocols_whitelist || (protocols_whitelist = _all_protocols);
		for (var i = 0; i < protocols_whitelist.length; i++) {
			var protocol = protocols_whitelist[i];
			pe[protocol] = probed[protocol]
		}
		var maybe_push = function (protos) {
			var proto = protos.shift();
			pe[proto] ? protocols.push(proto) : protos.length > 0 && maybe_push(protos)
		};
		info.websocket !== !1 && maybe_push(["websocket"]);
		pe["xhr-streaming"] && !info.null_origin ? protocols.push("xhr-streaming") : !pe["xdr-streaming"] || info.cookie_needed || info.null_origin ? maybe_push(["iframe-eventsource", "iframe-htmlfile"]) : protocols.push("xdr-streaming");
		pe["xhr-polling"] && !info.null_origin ? protocols.push("xhr-polling") : !pe["xdr-polling"] || info.cookie_needed || info.null_origin ? maybe_push(["iframe-xhr-polling", "jsonp-polling"]) : protocols.push("xdr-polling");
		return protocols
	};
	var MPrefix = "_sockjs_global";
	utils.createHook = function () {
		var window_id = "a" + utils.random_string(8);
		if (!(MPrefix in _window)) {
			var map = {};
			_window[MPrefix] = function (window_id) {
				window_id in map || (map[window_id] = {
					id: window_id,
					del: function () {
						delete map[window_id]
					}
				});
				return map[window_id]
			}
		}
		return _window[MPrefix](window_id)
	};
	utils.attachMessage = function (listener) {
		utils.attachEvent("message", listener)
	};
	utils.attachEvent = function (event, listener) {
		if ("undefined" != typeof _window.addEventListener) _window.addEventListener(event, listener, !1);
		else {
			_document.attachEvent("on" + event, listener);
			_window.attachEvent("on" + event, listener)
		}
	};
	utils.detachMessage = function (listener) {
		utils.detachEvent("message", listener)
	};
	utils.detachEvent = function (event, listener) {
		if ("undefined" != typeof _window.addEventListener) _window.removeEventListener(event, listener, !1);
		else {
			_document.detachEvent("on" + event, listener);
			_window.detachEvent("on" + event, listener)
		}
	};
	var on_unload = {},
		after_unload = !1,
		trigger_unload_callbacks = function () {
			for (var ref in on_unload) {
				on_unload[ref]();
				delete on_unload[ref]
			}
		},
		unload_triggered = function () {
			if (!after_unload) {
				after_unload = !0;
				trigger_unload_callbacks()
			}
		};
	utils.attachEvent("unload", unload_triggered);
	utils.unload_add = function (listener) {
		var ref = utils.random_string(8);
		on_unload[ref] = listener;
		after_unload && utils.delay(trigger_unload_callbacks);
		return ref
	};
	utils.unload_del = function (ref) {
		ref in on_unload && delete on_unload[ref]
	};
	utils.createIframe = function (iframe_url, error_callback) {
		var tref, unload_ref, iframe = _document.createElement("iframe"),
			unattach = function () {
				clearTimeout(tref);
				try {
					iframe.onload = null
				} catch (x) {}
				iframe.onerror = null
			},
			cleanup = function () {
				if (iframe) {
					unattach();
					setTimeout(function () {
						iframe && iframe.parentNode.removeChild(iframe);
						iframe = null
					}, 0);
					utils.unload_del(unload_ref)
				}
			},
			onerror = function (r) {
				if (iframe) {
					cleanup();
					error_callback(r)
				}
			},
			post = function (msg, origin) {
				try {
					iframe && iframe.contentWindow && iframe.contentWindow.postMessage(msg, origin)
				} catch (x) {}
			};
		iframe.src = iframe_url;
		iframe.style.display = "none";
		iframe.style.position = "absolute";
		iframe.onerror = function () {
			onerror("onerror")
		};
		iframe.onload = function () {
			clearTimeout(tref);
			tref = setTimeout(function () {
				onerror("onload timeout")
			}, 2e3)
		};
		_document.body.appendChild(iframe);
		tref = setTimeout(function () {
			onerror("timeout")
		}, 15e3);
		unload_ref = utils.unload_add(cleanup);
		return {
			post: post,
			cleanup: cleanup,
			loaded: unattach
		}
	};
	utils.createHtmlfile = function (iframe_url, error_callback) {
		var tref, unload_ref, iframe, doc = new ActiveXObject("htmlfile"),
			unattach = function () {
				clearTimeout(tref)
			},
			cleanup = function () {
				if (doc) {
					unattach();
					utils.unload_del(unload_ref);
					iframe.parentNode.removeChild(iframe);
					iframe = doc = null;
					CollectGarbage()
				}
			},
			onerror = function (r) {
				if (doc) {
					cleanup();
					error_callback(r)
				}
			},
			post = function (msg, origin) {
				try {
					iframe && iframe.contentWindow && iframe.contentWindow.postMessage(msg, origin)
				} catch (x) {}
			};
		doc.open();
		doc.write('<html><script>document.domain="' + document.domain + '";</script></html>');
		doc.close();
		doc.parentWindow[WPrefix] = _window[WPrefix];
		var c = doc.createElement("div");
		doc.body.appendChild(c);
		iframe = doc.createElement("iframe");
		c.appendChild(iframe);
		iframe.src = iframe_url;
		tref = setTimeout(function () {
			onerror("timeout")
		}, 15e3);
		unload_ref = utils.unload_add(cleanup);
		return {
			post: post,
			cleanup: cleanup,
			loaded: unattach
		}
	};
	var AbstractXHRObject = function () {};
	AbstractXHRObject.prototype = new EventEmitter(["chunk", "finish"]);
	AbstractXHRObject.prototype._start = function (method, url, payload, opts) {
		var that = this;
		try {
			that.xhr = new XMLHttpRequest
		} catch (x) {}
		if (!that.xhr) try {
			that.xhr = new _window.ActiveXObject("Microsoft.XMLHTTP")
		} catch (x) {}(_window.ActiveXObject || _window.XDomainRequest) && (url += (-1 === url.indexOf("?") ? "?" : "&") + "t=" + +new Date);
		that.unload_ref = utils.unload_add(function () {
			that._cleanup(!0)
		});
		try {
			that.xhr.open(method, url, !0)
		} catch (e) {
			that.emit("finish", 0, "");
			that._cleanup();
			return
		}
		opts && opts.no_credentials || (that.xhr.withCredentials = "true");
		if (opts && opts.headers)
			for (var key in opts.headers) that.xhr.setRequestHeader(key, opts.headers[key]);
		that.xhr.onreadystatechange = function () {
			if (that.xhr) {
				var x = that.xhr;
				switch (x.readyState) {
				case 3:
					try {
						var status = x.status,
							text = x.responseText
					} catch (x) {}
					text && text.length > 0 && that.emit("chunk", status, text);
					break;
				case 4:
					that.emit("finish", x.status, x.responseText);
					that._cleanup(!1)
				}
			}
		};
		that.xhr.send(payload)
	};
	AbstractXHRObject.prototype._cleanup = function (abort) {
		var that = this;
		if (that.xhr) {
			utils.unload_del(that.unload_ref);
			that.xhr.onreadystatechange = function () {};
			if (abort) try {
				that.xhr.abort()
			} catch (x) {}
			that.unload_ref = that.xhr = null
		}
	};
	AbstractXHRObject.prototype.close = function () {
		var that = this;
		that.nuke();
		that._cleanup(!0)
	};
	var XHRCorsObject = utils.XHRCorsObject = function () {
		var that = this,
			args = arguments;
		utils.delay(function () {
			that._start.apply(that, args)
		})
	};
	XHRCorsObject.prototype = new AbstractXHRObject;
	var XHRLocalObject = utils.XHRLocalObject = function (method, url, payload) {
		var that = this;
		utils.delay(function () {
			that._start(method, url, payload, {
				no_credentials: !0
			})
		})
	};
	XHRLocalObject.prototype = new AbstractXHRObject;
	var XDRObject = utils.XDRObject = function (method, url, payload) {
		var that = this;
		utils.delay(function () {
			that._start(method, url, payload)
		})
	};
	XDRObject.prototype = new EventEmitter(["chunk", "finish"]);
	XDRObject.prototype._start = function (method, url, payload) {
		var that = this,
			xdr = new XDomainRequest;
		url += (-1 === url.indexOf("?") ? "?" : "&") + "t=" + +new Date;
		var onerror = xdr.ontimeout = xdr.onerror = function () {
			that.emit("finish", 0, "");
			that._cleanup(!1)
		};
		xdr.onprogress = function () {
			that.emit("chunk", 200, xdr.responseText)
		};
		xdr.onload = function () {
			that.emit("finish", 200, xdr.responseText);
			that._cleanup(!1)
		};
		that.xdr = xdr;
		that.unload_ref = utils.unload_add(function () {
			that._cleanup(!0)
		});
		try {
			that.xdr.open(method, url);
			that.xdr.send(payload)
		} catch (x) {
			onerror()
		}
	};
	XDRObject.prototype._cleanup = function (abort) {
		var that = this;
		if (that.xdr) {
			utils.unload_del(that.unload_ref);
			that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress = that.xdr.onload = null;
			if (abort) try {
				that.xdr.abort()
			} catch (x) {}
			that.unload_ref = that.xdr = null
		}
	};
	XDRObject.prototype.close = function () {
		var that = this;
		that.nuke();
		that._cleanup(!0)
	};
	utils.isXHRCorsCapable = function () {
		return _window.XMLHttpRequest && "withCredentials" in new XMLHttpRequest ? 1 : _window.XDomainRequest && _document.domain ? 2 : IframeTransport.enabled() ? 3 : 4
	};
	var SockJS = function (url, dep_protocols_whitelist, options) {
		var protocols_whitelist, that = this;
		that._options = {
			devel: !1,
			debug: !1,
			protocols_whitelist: [],
			info: void 0,
			rtt: void 0,
			heartbeatTimeout: 0
		};
		options && utils.objectExtend(that._options, options);
		that._base_url = utils.amendUrl(url);
		that._server = that._options.server || utils.random_number_string(1e3);
		if (that._options.protocols_whitelist && that._options.protocols_whitelist.length) protocols_whitelist = that._options.protocols_whitelist;
		else {
			protocols_whitelist = "string" == typeof dep_protocols_whitelist && dep_protocols_whitelist.length > 0 ? [dep_protocols_whitelist] : utils.isArray(dep_protocols_whitelist) ? dep_protocols_whitelist : null;
			protocols_whitelist && that._debug('Deprecated API: Use "protocols_whitelist" option instead of supplying protocol list as a second parameter to SockJS constructor.')
		}
		that.heartbeatTimeoutTimer = null;
		that._protocols = [];
		that.protocol = null;
		that.readyState = SockJS.CONNECTING;
		that._ir = createInfoReceiver(that._base_url);
		that._ir.onfinish = function (info, rtt) {
			that._ir = null;
			if (info) {
				that._options.info && (info = utils.objectExtend(info, that._options.info));
				that._options.rtt && (rtt = that._options.rtt);
				that._applyInfo(info, rtt, protocols_whitelist);
				that._didClose()
			} else that._didClose(1002, "Can't connect to server", !0)
		}
	};
	SockJS.prototype = new REventTarget;
	SockJS.version = "0.3.2";
	SockJS.CONNECTING = 0;
	SockJS.OPEN = 1;
	SockJS.CLOSING = 2;
	SockJS.CLOSED = 3;
	SockJS.prototype._debug = function () {
		this._options.debug && utils.log.apply(utils, arguments)
	};
	SockJS.prototype._dispatchOpen = function () {
		var that = this;
		if (that.readyState === SockJS.CONNECTING) {
			that._options.heartbeatTimeout > 0 && that._setHeartbeatTimeout();
			if (that._transport_tref) {
				clearTimeout(that._transport_tref);
				that._transport_tref = null
			}
			that.readyState = SockJS.OPEN;
			that.dispatchEvent(new SimpleEvent("open"))
		} else that._didClose(1006, "Server lost session")
	};
	SockJS.prototype._dispatchMessage = function (data) {
		var that = this;
		that.readyState === SockJS.OPEN && that.dispatchEvent(new SimpleEvent("message", {
			data: data
		}))
	};
	SockJS.prototype._dispatchHeartbeat = function () {
		var that = this;
		that.readyState === SockJS.OPEN && that.dispatchEvent(new SimpleEvent("heartbeat", {}))
	};
	SockJS.prototype._setHeartbeatTimeout = function () {
		var that = this;
		clearTimeout(that.heartbeatTimeoutTimer);
		that.heartbeatTimeoutTimer = setTimeout(function () {
			that._didClose(1007, "Heartbeat timed out.")
		}, that._options.heartbeatTimeout)
	};
	SockJS.prototype._didClose = function (code, reason, force) {
		var that = this;
		if (that.readyState !== SockJS.CONNECTING && that.readyState !== SockJS.OPEN && that.readyState !== SockJS.CLOSING) throw new Error("INVALID_STATE_ERR");
		if (that._ir) {
			that._ir.nuke();
			that._ir = null
		}
		if (that._transport) {
			that._transport.doCleanup();
			that._transport = null
		}
		var close_event = new SimpleEvent("close", {
			code: code,
			reason: reason,
			wasClean: utils.userSetCode(code)
		});
		if (!utils.userSetCode(code) && that.readyState === SockJS.CONNECTING && !force) {
			if (that._try_next_protocol(close_event)) return;
			close_event = new SimpleEvent("close", {
				code: 2e3,
				reason: "All transports failed",
				wasClean: !1,
				last_event: close_event
			})
		}
		that.readyState = SockJS.CLOSED;
		utils.delay(function () {
			that.dispatchEvent(close_event)
		})
	};
	SockJS.prototype._didMessage = function (data) {
		var that = this,
			type = data.slice(0, 1);
		that._options.heartbeatTimeout > 0 && that._setHeartbeatTimeout();
		switch (type) {
		case "o":
			that._dispatchOpen();
			break;
		case "a":
			for (var payload = JSON.parse(data.slice(1) || "[]"), i = 0; i < payload.length; i++) that._dispatchMessage(payload[i]);
			break;
		case "m":
			var payload = JSON.parse(data.slice(1) || "null");
			that._dispatchMessage(payload);
			break;
		case "c":
			var payload = JSON.parse(data.slice(1) || "[]");
			that._didClose(payload[0], payload[1]);
			break;
		case "h":
			that._dispatchHeartbeat()
		}
	};
	SockJS.prototype._try_next_protocol = function (close_event) {
		var that = this;
		if (that.protocol) {
			that._debug("Closed transport:", that.protocol, "" + close_event);
			that.protocol = null
		}
		that._options.heartbeatTimeout > 0 && that._setHeartbeatTimeout();
		if (that._transport_tref) {
			clearTimeout(that._transport_tref);
			that._transport_tref = null
		}
		for (;;) {
			var protocol = that.protocol = that._protocols.shift();
			if (!protocol) return !1;
			if (SockJS[protocol] && SockJS[protocol].need_body === !0 && (!_document.body || "undefined" != typeof _document.readyState && "complete" !== _document.readyState)) {
				that._protocols.unshift(protocol);
				that.protocol = "waiting-for-load";
				utils.attachEvent("load", function () {
					that._try_next_protocol()
				});
				return !0
			}
			if (SockJS[protocol] && SockJS[protocol].enabled(that._options)) {
				var roundTrips = SockJS[protocol].roundTrips || 1,
					to = (that._options.rto || 0) * roundTrips || 5e3;
				that._transport_tref = utils.delay(to, function () {
					that.readyState === SockJS.CONNECTING && that._didClose(2007, "Transport timeouted")
				});
				var connid = utils.random_string(8),
					trans_url = that._base_url + "/" + that._server + "/" + connid;
				that._debug("Opening transport:", protocol, " url:" + trans_url, " RTO:" + that._options.rto);
				that._transport = new SockJS[protocol](that, trans_url, that._base_url);
				return !0
			}
			that._debug("Skipping transport:", protocol)
		}
	};
	SockJS.prototype.close = function (code, reason) {
		var that = this;
		if (code && !utils.userSetCode(code)) throw new Error("INVALID_ACCESS_ERR");
		if (that.readyState !== SockJS.CONNECTING && that.readyState !== SockJS.OPEN) return !1;
		that.readyState = SockJS.CLOSING;
		that._didClose(code || 1e3, reason || "Normal closure");
		return !0
	};
	SockJS.prototype.send = function (data) {
		var that = this;
		if (that.readyState === SockJS.CONNECTING) throw new Error("INVALID_STATE_ERR");
		that.readyState === SockJS.OPEN && that._transport.doSend(utils.quote("" + data));
		return !0
	};
	SockJS.prototype._applyInfo = function (info, rtt, protocols_whitelist) {
		var that = this;
		that._options.info = info;
		that._options.rtt = rtt;
		that._options.rto = utils.countRTO(rtt);
		that._options.info.null_origin = !_document.domain;
		var probed = utils.probeProtocols();
		that._protocols = utils.detectProtocols(probed, protocols_whitelist, info)
	};
	var WebSocketTransport = SockJS.websocket = function (ri, trans_url) {
		var that = this,
			url = trans_url + "/websocket";
		url = "https" === url.slice(0, 5) ? "wss" + url.slice(5) : "ws" + url.slice(4);
		that.ri = ri;
		that.url = url;
		var Constructor = _window.WebSocket || _window.MozWebSocket;
		that.ws = new Constructor(that.url);
		that.ws.onmessage = function (e) {
			that.ri._didMessage(e.data)
		};
		that.unload_ref = utils.unload_add(function () {
			that.ws.close()
		});
		that.ws.onclose = function () {
			that.ri._didMessage(utils.closeFrame(1006, "WebSocket connection broken"))
		}
	};
	WebSocketTransport.prototype.doSend = function (data) {
		this.ws.send("[" + data + "]")
	};
	WebSocketTransport.prototype.doCleanup = function () {
		var that = this,
			ws = that.ws;
		if (ws) {
			ws.onmessage = ws.onclose = null;
			ws.close();
			utils.unload_del(that.unload_ref);
			that.unload_ref = that.ri = that.ws = null
		}
	};
	WebSocketTransport.enabled = function () {
		return !(!_window.WebSocket && !_window.MozWebSocket)
	};
	WebSocketTransport.roundTrips = 2;
	var BufferedSender = function () {};
	BufferedSender.prototype.send_constructor = function (sender) {
		var that = this;
		that.send_buffer = [];
		that.sender = sender
	};
	BufferedSender.prototype.doSend = function (message) {
		var that = this;
		that.send_buffer.push(message);
		that.send_stop || that.send_schedule()
	};
	BufferedSender.prototype.send_schedule_wait = function () {
		var tref, that = this;
		that.send_stop = function () {
			that.send_stop = null;
			clearTimeout(tref)
		};
		tref = utils.delay(25, function () {
			that.send_stop = null;
			that.send_schedule()
		})
	};
	BufferedSender.prototype.send_schedule = function () {
		var that = this;
		if (that.send_buffer.length > 0) {
			var payload = "[" + that.send_buffer.join(",") + "]";
			that.send_stop = that.sender(that.trans_url, payload, function () {
				that.send_stop = null;
				that.send_schedule_wait()
			});
			that.send_buffer = []
		}
	};
	BufferedSender.prototype.send_destructor = function () {
		var that = this;
		that._send_stop && that._send_stop();
		that._send_stop = null
	};
	var jsonPGenericSender = function (url, payload, callback) {
			var that = this;
			if (!("_send_form" in that)) {
				var form = that._send_form = _document.createElement("form"),
					area = that._send_area = _document.createElement("textarea");
				area.name = "d";
				form.style.display = "none";
				form.style.position = "absolute";
				form.method = "POST";
				form.enctype = "application/x-www-form-urlencoded";
				form.acceptCharset = "UTF-8";
				form.appendChild(area);
				_document.body.appendChild(form)
			}
			var form = that._send_form,
				area = that._send_area,
				id = "a" + utils.random_string(8);
			form.target = id;
			form.action = url + "/jsonp_send?i=" + id;
			var iframe;
			try {
				iframe = _document.createElement('<iframe name="' + id + '">')
			} catch (x) {
				iframe = _document.createElement("iframe");
				iframe.name = id
			}
			iframe.id = id;
			form.appendChild(iframe);
			iframe.style.display = "none";
			try {
				area.value = payload
			} catch (e) {
				utils.log("Your browser is seriously broken. Go home! " + e.message)
			}
			form.submit();
			var completed = function () {
				if (iframe.onerror) {
					iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
					utils.delay(500, function () {
						iframe.parentNode.removeChild(iframe);
						iframe = null
					});
					area.value = "";
					callback()
				}
			};
			iframe.onerror = iframe.onload = completed;
			iframe.onreadystatechange = function () {
				"complete" == iframe.readyState && completed()
			};
			return completed
		},
		createAjaxSender = function (AjaxObject) {
			return function (url, payload, callback) {
				var xo = new AjaxObject("POST", url + "/xhr_send", payload);
				xo.onfinish = function (status) {
					callback(status)
				};
				return function (abort_reason) {
					callback(0, abort_reason)
				}
			}
		},
		jsonPGenericReceiver = function (url, callback) {
			var tref, script2, script = _document.createElement("script"),
				close_script = function (frame) {
					if (script2) {
						script2.parentNode.removeChild(script2);
						script2 = null
					}
					if (script) {
						clearTimeout(tref);
						script.parentNode.removeChild(script);
						script.onreadystatechange = script.onerror = script.onload = script.onclick = null;
						script = null;
						callback(frame);
						callback = null
					}
				},
				loaded_okay = !1,
				error_timer = null;
			script.id = "a" + utils.random_string(8);
			script.src = url;
			script.type = "text/javascript";
			script.charset = "UTF-8";
			script.onerror = function () {
				error_timer || (error_timer = setTimeout(function () {
					loaded_okay || close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onerror)"))
				}, 1e3))
			};
			script.onload = function () {
				close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onload)"))
			};
			script.onreadystatechange = function () {
				if (/loaded|closed/.test(script.readyState)) {
					if (script && script.htmlFor && script.onclick) {
						loaded_okay = !0;
						try {
							script.onclick()
						} catch (x) {}
					}
					script && close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onreadystatechange)"))
				}
			};
			if ("undefined" == typeof script.async && _document.attachEvent)
				if (/opera/i.test(navigator.userAgent)) {
					script2 = _document.createElement("script");
					script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
					script.async = script2.async = !1
				} else {
					try {
						script.htmlFor = script.id;
						script.event = "onclick"
					} catch (x) {}
					script.async = !0
				}
				"undefined" != typeof script.async && (script.async = !0);
			tref = setTimeout(function () {
				close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (timeout)"))
			}, 35e3);
			var head = _document.getElementsByTagName("head")[0];
			head.insertBefore(script, head.firstChild);
			script2 && head.insertBefore(script2, head.firstChild);
			return close_script
		},
		JsonPTransport = SockJS["jsonp-polling"] = function (ri, trans_url) {
			utils.polluteGlobalNamespace();
			var that = this;
			that.ri = ri;
			that.trans_url = trans_url;
			that.send_constructor(jsonPGenericSender);
			that._schedule_recv()
		};
	JsonPTransport.prototype = new BufferedSender;
	JsonPTransport.prototype._schedule_recv = function () {
		var that = this,
			callback = function (data) {
				that._recv_stop = null;
				data && (that._is_closing || that.ri._didMessage(data));
				that._is_closing || that._schedule_recv()
			};
		that._recv_stop = jsonPReceiverWrapper(that.trans_url + "/jsonp", jsonPGenericReceiver, callback)
	};
	JsonPTransport.enabled = function () {
		return !0
	};
	JsonPTransport.need_body = !0;
	JsonPTransport.prototype.doCleanup = function () {
		var that = this;
		that._is_closing = !0;
		that._recv_stop && that._recv_stop();
		that.ri = that._recv_stop = null;
		that.send_destructor()
	};
	var jsonPReceiverWrapper = function (url, constructReceiver, user_callback) {
			var id = "a" + utils.random_string(6),
				url_id = url + "?c=" + escape(WPrefix + "." + id),
				callback = function (frame) {
					delete _window[WPrefix][id];
					user_callback(frame)
				},
				close_script = constructReceiver(url_id, callback);
			_window[WPrefix][id] = close_script;
			var stop = function () {
				_window[WPrefix][id] && _window[WPrefix][id](utils.closeFrame(1e3, "JSONP user aborted read"))
			};
			return stop
		},
		AjaxBasedTransport = function () {};
	AjaxBasedTransport.prototype = new BufferedSender;
	AjaxBasedTransport.prototype.run = function (ri, trans_url, url_suffix, Receiver, AjaxObject) {
		var that = this;
		that.ri = ri;
		that.trans_url = trans_url;
		that.send_constructor(createAjaxSender(AjaxObject));
		that.poll = new Polling(ri, Receiver, trans_url + url_suffix, AjaxObject)
	};
	AjaxBasedTransport.prototype.doCleanup = function () {
		var that = this;
		if (that.poll) {
			that.poll.abort();
			that.poll = null
		}
	};
	var XhrStreamingTransport = SockJS["xhr-streaming"] = function (ri, trans_url) {
		this.run(ri, trans_url, "/xhr_streaming", XhrReceiver, utils.XHRCorsObject)
	};
	XhrStreamingTransport.prototype = new AjaxBasedTransport;
	XhrStreamingTransport.enabled = function () {
		return _window.XMLHttpRequest && "withCredentials" in new XMLHttpRequest && !/opera/i.test(navigator.userAgent)
	};
	XhrStreamingTransport.roundTrips = 2;
	XhrStreamingTransport.need_body = !0;
	var XdrStreamingTransport = SockJS["xdr-streaming"] = function (ri, trans_url) {
		this.run(ri, trans_url, "/xhr_streaming", XhrReceiver, utils.XDRObject)
	};
	XdrStreamingTransport.prototype = new AjaxBasedTransport;
	XdrStreamingTransport.enabled = function () {
		return !!_window.XDomainRequest
	};
	XdrStreamingTransport.roundTrips = 2;
	var XhrPollingTransport = SockJS["xhr-polling"] = function (ri, trans_url) {
		this.run(ri, trans_url, "/xhr", XhrReceiver, utils.XHRCorsObject)
	};
	XhrPollingTransport.prototype = new AjaxBasedTransport;
	XhrPollingTransport.enabled = XhrStreamingTransport.enabled;
	XhrPollingTransport.roundTrips = 2;
	var XdrPollingTransport = SockJS["xdr-polling"] = function (ri, trans_url) {
		this.run(ri, trans_url, "/xhr", XhrReceiver, utils.XDRObject)
	};
	XdrPollingTransport.prototype = new AjaxBasedTransport;
	XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
	XdrPollingTransport.roundTrips = 2;
	var IframeTransport = function () {};
	IframeTransport.prototype.i_constructor = function (ri, trans_url, base_url) {
		var that = this;
		that.ri = ri;
		that.origin = utils.getOrigin(base_url);
		that.base_url = base_url;
		that.trans_url = trans_url;
		var iframe_url = base_url + "/iframe.html";
		that.ri._options.devel && (iframe_url += "?t=" + +new Date);
		that.window_id = utils.random_string(8);
		iframe_url += "#" + that.window_id;
		that.iframeObj = utils.createIframe(iframe_url, function (r) {
			that.ri._didClose(1006, "Unable to load an iframe (" + r + ")")
		});
		that.onmessage_cb = utils.bind(that.onmessage, that);
		utils.attachMessage(that.onmessage_cb)
	};
	IframeTransport.prototype.doCleanup = function () {
		var that = this;
		if (that.iframeObj) {
			utils.detachMessage(that.onmessage_cb);
			try {
				that.iframeObj.iframe.contentWindow && that.postMessage("c")
			} catch (x) {}
			that.iframeObj.cleanup();
			that.iframeObj = null;
			that.onmessage_cb = that.iframeObj = null
		}
	};
	IframeTransport.prototype.onmessage = function (e) {
		var that = this;
		if (e.origin === that.origin) {
			var window_id = e.data.slice(0, 8),
				type = e.data.slice(8, 9),
				data = e.data.slice(9);
			if (window_id === that.window_id) switch (type) {
			case "s":
				that.iframeObj.loaded();
				that.postMessage("s", JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));
				break;
			case "t":
				that.ri._didMessage(data)
			}
		}
	};
	IframeTransport.prototype.postMessage = function (type, data) {
		var that = this;
		that.iframeObj.post(that.window_id + type + (data || ""), that.origin)
	};
	IframeTransport.prototype.doSend = function (message) {
		this.postMessage("m", message)
	};
	IframeTransport.enabled = function () {
		var konqueror = navigator && navigator.userAgent && -1 !== navigator.userAgent.indexOf("Konqueror");
		return ("function" == typeof _window.postMessage || "object" == typeof _window.postMessage) && !konqueror
	};
	var curr_window_id, postMessage = function (type, data) {
			parent !== _window ? parent.postMessage(curr_window_id + type + (data || ""), "*") : utils.log("Can't postMessage, no parent window.", type, data)
		},
		FacadeJS = function () {};
	FacadeJS.prototype._didClose = function (code, reason) {
		postMessage("t", utils.closeFrame(code, reason))
	};
	FacadeJS.prototype._didMessage = function (frame) {
		postMessage("t", frame)
	};
	FacadeJS.prototype._doSend = function (data) {
		this._transport.doSend(data)
	};
	FacadeJS.prototype._doCleanup = function () {
		this._transport.doCleanup()
	};
	utils.parent_origin = void 0;
	SockJS.bootstrap_iframe = function () {
		var facade;
		curr_window_id = _document.location.hash.slice(1);
		var onMessage = function (e) {
			if (e.source === parent) {
				"undefined" == typeof utils.parent_origin && (utils.parent_origin = e.origin);
				if (e.origin === utils.parent_origin) {
					var window_id = e.data.slice(0, 8),
						type = e.data.slice(8, 9),
						data = e.data.slice(9);
					if (window_id === curr_window_id) switch (type) {
					case "s":
						var p = JSON.parse(data),
							version = p[0],
							protocol = p[1],
							trans_url = p[2],
							base_url = p[3];
						version !== SockJS.version && utils.log('Incompatibile SockJS! Main site uses: "' + version + '", the iframe: "' + SockJS.version + '".');
						if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {
							utils.log("Only basic urls are supported in SockJS");
							return
						}
						if (!utils.isSameOriginUrl(trans_url) || !utils.isSameOriginUrl(base_url)) {
							utils.log("Can't connect to different domain from within an iframe. (" + JSON.stringify([_window.location.href, trans_url, base_url]) + ")");
							return
						}
						facade = new FacadeJS;
						facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);
						break;
					case "m":
						facade._doSend(data);
						break;
					case "c":
						facade && facade._doCleanup();
						facade = null
					}
				}
			}
		};
		utils.attachMessage(onMessage);
		postMessage("s")
	};
	var InfoReceiver = function (base_url, AjaxObject) {
		var that = this;
		utils.delay(function () {
			that.doXhr(base_url, AjaxObject)
		})
	};
	InfoReceiver.prototype = new EventEmitter(["finish"]);
	InfoReceiver.prototype.doXhr = function (base_url, AjaxObject) {
		var that = this,
			t0 = (new Date).getTime(),
			xo = new AjaxObject("GET", base_url + "/info"),
			tref = utils.delay(8e3, function () {
				xo.ontimeout()
			});
		xo.onfinish = function (status, text) {
			clearTimeout(tref);
			tref = null;
			if (200 === status) {
				var rtt = (new Date).getTime() - t0,
					info = JSON.parse(text);
				"object" != typeof info && (info = {});
				that.emit("finish", info, rtt)
			} else that.emit("finish")
		};
		xo.ontimeout = function () {
			xo.close();
			that.emit("finish")
		}
	};
	var InfoReceiverIframe = function (base_url) {
		var that = this,
			go = function () {
				var ifr = new IframeTransport;
				ifr.protocol = "w-iframe-info-receiver";
				var fun = function (r) {
						if ("string" == typeof r && "m" === r.substr(0, 1)) {
							var d = JSON.parse(r.substr(1)),
								info = d[0],
								rtt = d[1];
							that.emit("finish", info, rtt)
						} else that.emit("finish");
						ifr.doCleanup();
						ifr = null
					},
					mock_ri = {
						_options: {},
						_didClose: fun,
						_didMessage: fun
					};
				ifr.i_constructor(mock_ri, base_url, base_url)
			};
		_document.body ? go() : utils.attachEvent("load", go)
	};
	InfoReceiverIframe.prototype = new EventEmitter(["finish"]);
	var InfoReceiverFake = function () {
		var that = this;
		utils.delay(function () {
			that.emit("finish", {}, 2e3)
		})
	};
	InfoReceiverFake.prototype = new EventEmitter(["finish"]);
	var createInfoReceiver = function (base_url) {
			if (utils.isSameOriginUrl(base_url)) return new InfoReceiver(base_url, utils.XHRLocalObject);
			switch (utils.isXHRCorsCapable()) {
			case 1:
				return new InfoReceiver(base_url, utils.XHRLocalObject);
			case 2:
				return new InfoReceiver(base_url, utils.XDRObject);
			case 3:
				return new InfoReceiverIframe(base_url);
			default:
				return new InfoReceiverFake
			}
		},
		WInfoReceiverIframe = FacadeJS["w-iframe-info-receiver"] = function (ri, _trans_url, base_url) {
			var ir = new InfoReceiver(base_url, utils.XHRLocalObject);
			ir.onfinish = function (info, rtt) {
				ri._didMessage("m" + JSON.stringify([info, rtt]));
				ri._didClose()
			}
		};
	WInfoReceiverIframe.prototype.doCleanup = function () {};
	var EventSourceIframeTransport = SockJS["iframe-eventsource"] = function () {
		var that = this;
		that.protocol = "w-iframe-eventsource";
		that.i_constructor.apply(that, arguments)
	};
	EventSourceIframeTransport.prototype = new IframeTransport;
	EventSourceIframeTransport.enabled = function () {
		return "EventSource" in _window && IframeTransport.enabled()
	};
	EventSourceIframeTransport.need_body = !0;
	EventSourceIframeTransport.roundTrips = 3;
	var EventSourceTransport = FacadeJS["w-iframe-eventsource"] = function (ri, trans_url) {
		this.run(ri, trans_url, "/eventsource", EventSourceReceiver, utils.XHRLocalObject)
	};
	EventSourceTransport.prototype = new AjaxBasedTransport;
	var XhrPollingIframeTransport = SockJS["iframe-xhr-polling"] = function () {
		var that = this;
		that.protocol = "w-iframe-xhr-polling";
		that.i_constructor.apply(that, arguments)
	};
	XhrPollingIframeTransport.prototype = new IframeTransport;
	XhrPollingIframeTransport.enabled = function () {
		return _window.XMLHttpRequest && IframeTransport.enabled()
	};
	XhrPollingIframeTransport.need_body = !0;
	XhrPollingIframeTransport.roundTrips = 3;
	var XhrPollingITransport = FacadeJS["w-iframe-xhr-polling"] = function (ri, trans_url) {
		this.run(ri, trans_url, "/xhr", XhrReceiver, utils.XHRLocalObject)
	};
	XhrPollingITransport.prototype = new AjaxBasedTransport;
	var HtmlFileIframeTransport = SockJS["iframe-htmlfile"] = function () {
		var that = this;
		that.protocol = "w-iframe-htmlfile";
		that.i_constructor.apply(that, arguments)
	};
	HtmlFileIframeTransport.prototype = new IframeTransport;
	HtmlFileIframeTransport.enabled = function () {
		return IframeTransport.enabled()
	};
	HtmlFileIframeTransport.need_body = !0;
	HtmlFileIframeTransport.roundTrips = 3;
	var HtmlFileTransport = FacadeJS["w-iframe-htmlfile"] = function (ri, trans_url) {
		this.run(ri, trans_url, "/htmlfile", HtmlfileReceiver, utils.XHRLocalObject)
	};
	HtmlFileTransport.prototype = new AjaxBasedTransport;
	var Polling = function (ri, Receiver, recv_url, AjaxObject) {
		var that = this;
		that.ri = ri;
		that.Receiver = Receiver;
		that.recv_url = recv_url;
		that.AjaxObject = AjaxObject;
		that._scheduleRecv()
	};
	Polling.prototype._scheduleRecv = function () {
		var that = this,
			poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject),
			msg_counter = 0;
		poll.onmessage = function (e) {
			msg_counter += 1;
			that.ri._didMessage(e.data)
		};
		poll.onclose = function (e) {
			that.poll = poll = poll.onmessage = poll.onclose = null;
			that.poll_is_closing || ("permanent" === e.reason ? that.ri._didClose(1006, "Polling error (" + e.reason + ")") : that._scheduleRecv())
		}
	};
	Polling.prototype.abort = function () {
		var that = this;
		that.poll_is_closing = !0;
		that.poll && that.poll.abort()
	};
	var EventSourceReceiver = function (url) {
		var that = this,
			es = new EventSource(url);
		es.onmessage = function (e) {
			that.dispatchEvent(new SimpleEvent("message", {
				data: unescape(e.data)
			}))
		};
		that.es_close = es.onerror = function (e, abort_reason) {
			var reason = abort_reason ? "user" : 2 !== es.readyState ? "network" : "permanent";
			that.es_close = es.onmessage = es.onerror = null;
			es.close();
			es = null;
			utils.delay(200, function () {
				that.dispatchEvent(new SimpleEvent("close", {
					reason: reason
				}))
			})
		}
	};
	EventSourceReceiver.prototype = new REventTarget;
	EventSourceReceiver.prototype.abort = function () {
		var that = this;
		that.es_close && that.es_close({}, !0)
	};
	var _is_ie_htmlfile_capable, isIeHtmlfileCapable = function () {
			if (void 0 === _is_ie_htmlfile_capable)
				if ("ActiveXObject" in _window) try {
					_is_ie_htmlfile_capable = !!new ActiveXObject("htmlfile")
				} catch (x) {} else _is_ie_htmlfile_capable = !1;
			return _is_ie_htmlfile_capable
		},
		HtmlfileReceiver = function (url) {
			var that = this;
			utils.polluteGlobalNamespace();
			that.id = "a" + utils.random_string(6, 26);
			url += (-1 === url.indexOf("?") ? "?" : "&") + "c=" + escape(WPrefix + "." + that.id);
			var iframeObj, constructor = isIeHtmlfileCapable() ? utils.createHtmlfile : utils.createIframe;
			_window[WPrefix][that.id] = {
				start: function () {
					iframeObj.loaded()
				},
				message: function (data) {
					that.dispatchEvent(new SimpleEvent("message", {
						data: data
					}))
				},
				stop: function () {
					that.iframe_close({}, "network")
				}
			};
			that.iframe_close = function (e, abort_reason) {
				iframeObj.cleanup();
				that.iframe_close = iframeObj = null;
				delete _window[WPrefix][that.id];
				that.dispatchEvent(new SimpleEvent("close", {
					reason: abort_reason
				}))
			};
			iframeObj = constructor(url, function () {
				that.iframe_close({}, "permanent")
			})
		};
	HtmlfileReceiver.prototype = new REventTarget;
	HtmlfileReceiver.prototype.abort = function () {
		var that = this;
		that.iframe_close && that.iframe_close({}, "user")
	};
	var XhrReceiver = function (url, AjaxObject) {
		var that = this,
			buf_pos = 0;
		that.xo = new AjaxObject("POST", url, null);
		that.xo.onchunk = function (status, text) {
			if (200 === status)
				for (;;) {
					var buf = text.slice(buf_pos),
						p = buf.indexOf("\n");
					if (-1 === p) break;
					buf_pos += p + 1;
					var msg = buf.slice(0, p);
					that.dispatchEvent(new SimpleEvent("message", {
						data: msg
					}))
				}
		};
		that.xo.onfinish = function (status, text) {
			that.xo.onchunk(status, text);
			that.xo = null;
			var reason = 200 === status ? "network" : "permanent";
			that.dispatchEvent(new SimpleEvent("close", {
				reason: reason
			}))
		}
	};
	XhrReceiver.prototype = new REventTarget;
	XhrReceiver.prototype.abort = function () {
		var that = this;
		if (that.xo) {
			that.xo.close();
			that.dispatchEvent(new SimpleEvent("close", {
				reason: "user"
			}));
			that.xo = null
		}
	};
	SockJS.getUtils = function () {
		return utils
	};
	SockJS.getIframeTransport = function () {
		return IframeTransport
	};
	return SockJS
}();
"_sockjs_onload" in window && setTimeout(_sockjs_onload, 1);
"function" == typeof define && define.amd && define("sockjs", [], function () {
	return SockJS
});
! function () {
	var require = function (file, cwd) {
		var resolved = require.resolve(file, cwd || "/"),
			mod = require.modules[resolved];
		if (!mod) throw new Error("Failed to resolve module " + file + ", tried " + resolved);
		var cached = require.cache[resolved],
			res = cached ? cached.exports : mod();
		return res
	};
	require.paths = [];
	require.modules = {};
	require.cache = {};
	require.extensions = [".js", ".coffee", ".json"];
	require._core = {
		assert: !0,
		events: !0,
		fs: !0,
		path: !0,
		vm: !0
	};
	require.resolve = function () {
		return function (x, cwd) {
			function loadAsFileSync(x) {
				x = path.normalize(x);
				if (require.modules[x]) return x;
				for (var i = 0; i < require.extensions.length; i++) {
					var ext = require.extensions[i];
					if (require.modules[x + ext]) return x + ext
				}
			}

			function loadAsDirectorySync(x) {
				x = x.replace(/\/+$/, "");
				var pkgfile = path.normalize(x + "/package.json");
				if (require.modules[pkgfile]) {
					var pkg = require.modules[pkgfile](),
						b = pkg.browserify;
					if ("object" == typeof b && b.main) {
						var m = loadAsFileSync(path.resolve(x, b.main));
						if (m) return m
					} else if ("string" == typeof b) {
						var m = loadAsFileSync(path.resolve(x, b));
						if (m) return m
					} else if (pkg.main) {
						var m = loadAsFileSync(path.resolve(x, pkg.main));
						if (m) return m
					}
				}
				return loadAsFileSync(x + "/index")
			}

			function loadNodeModulesSync(x, start) {
				for (var dirs = nodeModulesPathsSync(start), i = 0; i < dirs.length; i++) {
					var dir = dirs[i],
						m = loadAsFileSync(dir + "/" + x);
					if (m) return m;
					var n = loadAsDirectorySync(dir + "/" + x);
					if (n) return n
				}
				var m = loadAsFileSync(x);
				return m ? m : void 0
			}

			function nodeModulesPathsSync(start) {
				var parts;
				parts = "/" === start ? [""] : path.normalize(start).split("/");
				for (var dirs = [], i = parts.length - 1; i >= 0; i--)
					if ("node_modules" !== parts[i]) {
						var dir = parts.slice(0, i + 1).join("/") + "/node_modules";
						dirs.push(dir)
					}
				return dirs
			}
			cwd || (cwd = "/");
			if (require._core[x]) return x;
			var path = require.modules.path();
			cwd = path.resolve("/", cwd);
			var y = cwd || "/";
			if (x.match(/^(?:\.\.?\/|\/)/)) {
				var m = loadAsFileSync(path.resolve(y, x)) || loadAsDirectorySync(path.resolve(y, x));
				if (m) return m
			}
			var n = loadNodeModulesSync(x, y);
			if (n) return n;
			throw new Error("Cannot find module '" + x + "'")
		}
	}();
	require.alias = function (from, to) {
		var path = require.modules.path(),
			res = null;
		try {
			res = require.resolve(from + "/package.json", "/")
		} catch (err) {
			res = require.resolve(from, "/")
		}
		for (var basedir = path.dirname(res), keys = (Object.keys || function (obj) {
			var res = [];
			for (var key in obj) res.push(key);
			return res
		})(require.modules), i = 0; i < keys.length; i++) {
			var key = keys[i];
			if (key.slice(0, basedir.length + 1) === basedir + "/") {
				var f = key.slice(basedir.length);
				require.modules[to + f] = require.modules[basedir + f]
			} else key === basedir && (require.modules[to] = require.modules[basedir])
		}
	};
	! function () {
		var process = {},
			global = "undefined" != typeof window ? window : {},
			definedProcess = !1;
		require.define = function (filename, fn) {
			if (!definedProcess && require.modules.__browserify_process) {
				process = require.modules.__browserify_process();
				definedProcess = !0
			}
			var dirname = require._core[filename] ? "" : require.modules.path().dirname(filename),
				require_ = function (file) {
					var requiredModule = require(file, dirname),
						cached = require.cache[require.resolve(file, dirname)];
					cached && null === cached.parent && (cached.parent = module_);
					return requiredModule
				};
			require_.resolve = function (name) {
				return require.resolve(name, dirname)
			};
			require_.modules = require.modules;
			require_.define = require.define;
			require_.cache = require.cache;
			var module_ = {
				id: filename,
				filename: filename,
				exports: {},
				loaded: !1,
				parent: null
			};
			require.modules[filename] = function () {
				require.cache[filename] = module_;
				fn.call(module_.exports, require_, module_, module_.exports, dirname, filename, process, global);
				module_.loaded = !0;
				return module_.exports
			}
		}
	}();
	require.define("path", function (require, module, exports, __dirname, __filename, process) {
		function filter(xs, fn) {
			for (var res = [], i = 0; i < xs.length; i++) fn(xs[i], i, xs) && res.push(xs[i]);
			return res
		}

		function normalizeArray(parts, allowAboveRoot) {
			for (var up = 0, i = parts.length; i >= 0; i--) {
				var last = parts[i];
				if ("." == last) parts.splice(i, 1);
				else if (".." === last) {
					parts.splice(i, 1);
					up++
				} else if (up) {
					parts.splice(i, 1);
					up--
				}
			}
			if (allowAboveRoot)
				for (; up--; up) parts.unshift("..");
			return parts
		}
		var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;
		exports.resolve = function () {
			for (var resolvedPath = "", resolvedAbsolute = !1, i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
				var path = i >= 0 ? arguments[i] : process.cwd();
				if ("string" == typeof path && path) {
					resolvedPath = path + "/" + resolvedPath;
					resolvedAbsolute = "/" === path.charAt(0)
				}
			}
			resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function (p) {
				return !!p
			}), !resolvedAbsolute).join("/");
			return (resolvedAbsolute ? "/" : "") + resolvedPath || "."
		};
		exports.normalize = function (path) {
			var isAbsolute = "/" === path.charAt(0),
				trailingSlash = "/" === path.slice(-1);
			path = normalizeArray(filter(path.split("/"), function (p) {
				return !!p
			}), !isAbsolute).join("/");
			path || isAbsolute || (path = ".");
			path && trailingSlash && (path += "/");
			return (isAbsolute ? "/" : "") + path
		};
		exports.join = function () {
			var paths = Array.prototype.slice.call(arguments, 0);
			return exports.normalize(filter(paths, function (p) {
				return p && "string" == typeof p
			}).join("/"))
		};
		exports.dirname = function (path) {
			var dir = splitPathRe.exec(path)[1] || "",
				isWindows = !1;
			return dir ? 1 === dir.length || isWindows && dir.length <= 3 && ":" === dir.charAt(1) ? dir : dir.substring(0, dir.length - 1) : "."
		};
		exports.basename = function (path, ext) {
			var f = splitPathRe.exec(path)[2] || "";
			ext && f.substr(-1 * ext.length) === ext && (f = f.substr(0, f.length - ext.length));
			return f
		};
		exports.extname = function (path) {
			return splitPathRe.exec(path)[3] || ""
		}
	});
	require.define("__browserify_process", function (require, module, exports, __dirname, __filename, process) {
		var process = module.exports = {};
		process.nextTick = function () {
			var canSetImmediate = "undefined" != typeof window && window.setImmediate,
				canPost = "undefined" != typeof window && window.postMessage && window.addEventListener;
			if (canSetImmediate) return window.setImmediate;
			if (canPost) {
				var queue = [];
				window.addEventListener("message", function (ev) {
					if (ev.source === window && "browserify-tick" === ev.data) {
						ev.stopPropagation();
						if (queue.length > 0) {
							var fn = queue.shift();
							fn()
						}
					}
				}, !0);
				return function (fn) {
					queue.push(fn);
					window.postMessage("browserify-tick", "*")
				}
			}
			return function (fn) {
				setTimeout(fn, 0)
			}
		}();
		process.title = "browser";
		process.browser = !0;
		process.env = {};
		process.argv = [];
		process.binding = function (name) {
			if ("evals" === name) return require("vm");
			throw new Error("No such module. (Possibly not yet loaded)")
		};
		! function () {
			var path, cwd = "/";
			process.cwd = function () {
				return cwd
			};
			process.chdir = function (dir) {
				path || (path = require("path"));
				cwd = path.resolve(dir, cwd)
			}
		}()
	});
	require.define("/node_modules_koding/koding-broker-client/lib/broker-client/index.js", function (require, module, exports) {
		exports.Broker = require("./broker");
		exports.Channel = require("./channel");
		"undefined" != typeof window && null !== window && (window.KDBroker = exports)
	});
	require.define("/node_modules_koding/koding-broker-client/lib/broker-client/broker.js", function (require, module, exports, __dirname, __filename, process) {
		var Broker, __hasProp = {}.hasOwnProperty,
			__extends = function (child, parent) {
				function ctor() {
					this.constructor = child
				}
				for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
				ctor.prototype = parent.prototype;
				child.prototype = new ctor;
				child.__super__ = parent.prototype;
				return child
			},
			__indexOf = [].indexOf || function (item) {
				for (var i = 0, l = this.length; l > i; i++)
					if (i in this && this[i] === item) return i;
				return -1
			},
			__slice = [].slice;
		module.exports = Broker = function (_super) {
			function Broker(ws, options) {
				Broker.__super__.constructor.call(this);
				this.sockURL = ws;
				this.autoReconnect = options.autoReconnect, this.authExchange = options.authExchange, this.overlapDuration = options.overlapDuration, this.servicesEndpoint = options.servicesEndpoint, this.getSessionToken = options.getSessionToken, this.brokerExchange = options.brokerExchange, this.tryResubscribing = options.tryResubscribing;
				null == this.overlapDuration && (this.overlapDuration = 3e3);
				null == this.authExchange && (this.authExchange = "auth");
				null == this.brokerExchange && (this.brokerExchange = "broker");
				this.readyState = NOTREADY;
				this.channels = {};
				this.namespacedEvents = {};
				this.subscriptions = {};
				null == this.tryResubscribing && (this.tryResubscribing = !0);
				this.pendingSubscriptions = [];
				this.pendingUnsubscriptions = [];
				this.subscriptionThrottleMs = 2e3;
				this.unsubscriptionThreshold = 40;
				this.autoReconnect && this.initBackoff(options.backoff);
				this.connect()
			}
			var CLOSED, Channel, NOTREADY, READY, chooseBroker, createId, emitToChannel, getRandomBroker, _ref;
			__extends(Broker, _super);
			_ref = [0, 1, 3], NOTREADY = _ref[0], READY = _ref[1], CLOSED = _ref[2];
			Channel = require("./channel");
			createId = require("hat");
			emitToChannel = require("./util").emitToChannel;
			Broker.prototype.initBackoff = require("koding-backoff");
			Broker.prototype.setP2PKeys = function (channelName, _arg, serviceType) {
				var bindingKey, channel, consumerChannel, producerChannel, routingKey;
				routingKey = _arg.routingKey, bindingKey = _arg.bindingKey;
				channel = this.channels[channelName];
				if (channel) {
					channel.close();
					consumerChannel = this.subscribe(bindingKey, {
						exchange: "chat",
						isReadOnly: !0,
						isSecret: !0
					});
					consumerChannel.setAuthenticationInfo({
						serviceType: serviceType
					});
					consumerChannel.pipe(channel);
					producerChannel = this.subscribe(routingKey, {
						exchange: "chat",
						isReadOnly: !1,
						isSecret: !0
					});
					producerChannel.setAuthenticationInfo({
						serviceType: serviceType
					});
					channel.off("publish");
					channel.on("publish", producerChannel.bound("publish"));
					channel.consumerChannel = consumerChannel;
					channel.producerChannel = producerChannel;
					return channel
				}
			};
			Broker.prototype.bound = require("koding-bound");
			Broker.prototype.onopen = function () {
				var _this = this;
				this.ws.removeEventListener(this.bound("onopen"));
				this.autoReconnect && this.clearBackoffTimeout();
				this.once("broker.connected", function (newSocketId) {
					_this.socketId = newSocketId;
					_this.emit("ready");
					_this.readyState === CLOSED && _this.resubscribe();
					_this.readyState = READY;
					return _this.emit("ready")
				});
				return this.emit("connected")
			};
			Broker.prototype.onclose = function () {
				var channel, _, _ref1, _this = this;
				this.setConnectionData();
				this.readyState = CLOSED;
				this.emit("disconnected", Object.keys(this.channels));
				_ref1 = this.channels;
				for (_ in _ref1)
					if (__hasProp.call(_ref1, _)) {
						channel = _ref1[_];
						channel.interrupt()
					}
				return this.autoReconnect ? process.nextTick(function () {
					return _this.connectAttemptFail()
				}) : void 0
			};
			Broker.prototype.connectAttemptFail = function () {
				return this.autoReconnect ? this.setBackoffTimeout(this.bound("connect"), this.bound("connectFail")) : void 0
			};
			Broker.prototype.selectAndConnect = function (blacklist) {
				var endPoint, xhr, _this = this;
				null == blacklist && (blacklist = []);
				xhr = new XMLHttpRequest;
				endPoint = blacklist.length ? "" + this.servicesEndpoint + "?all" : this.servicesEndpoint;
				xhr.open("GET", endPoint);
				xhr.onreadystatechange = function () {
					var response, _ref1;
					if (0 === xhr.status || xhr.status >= 400) {
						_this.connectAttemptFail();
						return _this
					}
					if (4 === xhr.readyState && (200 === (_ref1 = xhr.status) || 304 === _ref1)) {
						response = JSON.parse(xhr.responseText);
						_this.sockURL = "" + (Array.isArray(response) ? chooseBroker(response, blacklist) : response) + "/subscribe";
						return _this.connectDirectly()
					}
				};
				xhr.send();
				return this
			};
			chooseBroker = function (response, blacklist) {
				var brokers;
				if (!blacklist.length) return response[0];
				brokers = response.filter(function (broker) {
					return __indexOf.call(blacklist, broker) < 0
				});
				if (!brokers.length) {
					console.warn("broker filter is bypassed");
					return getRandomBroker(response)
				}
				return getRandomBroker(brokers)
			};
			getRandomBroker = function (brokers) {
				return brokers[Math.floor(Math.random() * brokers.length)]
			};
			Broker.prototype.connectDirectly = function () {
				var _this = this;
				this.ws = new SockJS(this.sockURL);
				this.ws.addEventListener("open", this.bound("onopen"));
				this.ws.addEventListener("close", this.bound("onclose"));
				this.ws.addEventListener("message", this.bound("handleMessageEvent"));
				this.ws.addEventListener("message", function () {
					_this.lastTo = Date.now();
					return _this.emit("messageArrived")
				});
				return this
			};
			Broker.prototype.disconnect = function (reconnect) {
				null == reconnect && (reconnect = !0);
				null != reconnect && (this.autoReconnect = !!reconnect);
				this.ws.close();
				return this
			};
			Broker.prototype.connect = function () {
				null != this.servicesEndpoint ? this.selectAndConnect() : this.connectDirectly();
				return this
			};
			Broker.prototype.connectFail = function () {
				return this.emit("connectFailed")
			};
			Broker.prototype.createRoutingKeyPrefix = function (name, options) {
				var isReadOnly, suffix;
				null == options && (options = {});
				isReadOnly = options.isReadOnly, suffix = options.suffix;
				name += suffix || "";
				return isReadOnly ? name : "client." + name
			};
			Broker.prototype.wrapPrivateChannel = function (channel) {
				var _this = this;
				channel.on("cycle", function () {
					return _this.authenticate(channel)
				});
				return channel.on("setSecretNames", function (secretName) {
					var consumerChannel, isReadOnly;
					isReadOnly = channel.isReadOnly;
					channel.setSecretName(secretName);
					channel.isForwarder = !0;
					consumerChannel = _this.subscribe(secretName.publishingName, {
						isReadOnly: isReadOnly,
						isSecret: !0,
						exchange: channel.exchange
					});
					consumerChannel.setAuthenticationInfo({
						serviceType: "secret",
						wrapperRoutingKeyPrefix: channel.routingKeyPrefix
					});
					channel.consumerChannel = consumerChannel;
					consumerChannel.on("cycleChannel", function () {
						channel.oldConsumerChannel = channel.consumerChannel;
						return channel.cycle()
					});
					isReadOnly || channel.on("publish", function () {
						var rest;
						rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
						return consumerChannel.publish.apply(consumerChannel, rest)
					});
					_this.swapPrivateSourceChannel(channel);
					return channel.emit("ready")
				})
			};
			Broker.prototype.swapPrivateSourceChannel = function (channel) {
				var consumerChannel, oldConsumerChannel;
				consumerChannel = channel.consumerChannel, oldConsumerChannel = channel.oldConsumerChannel;
				return null != oldConsumerChannel ? setTimeout(function () {
					oldConsumerChannel.close().off();
					delete channel.oldConsumerChannel;
					return consumerChannel.pipe(channel)
				}, this.overlapDuration) : consumerChannel.pipe(channel)
			};
			Broker.prototype.registerNamespacedEvent = function (name) {
				var register;
				register = this.namespacedEvents;
				null == register[name] && (register[name] = 0);
				register[name] += 1;
				return 1 === register[name]
			};
			Broker.prototype.createChannel = function (name, options) {
				var channel, exchange, handler, isExclusive, isP2P, isPrivate, isReadOnly, isSecret, mustAuthenticate, routingKeyPrefix, suffix, _this = this;
				if (null != this.channels[name]) return this.channels[name];
				isReadOnly = options.isReadOnly, isSecret = options.isSecret, isExclusive = options.isExclusive, isPrivate = options.isPrivate, isP2P = options.isP2P, suffix = options.suffix, exchange = options.exchange, mustAuthenticate = options.mustAuthenticate;
				null == suffix && (suffix = isExclusive ? "." + createId(32) : "");
				routingKeyPrefix = this.createRoutingKeyPrefix(name, {
					suffix: suffix,
					isReadOnly: isReadOnly
				});
				channel = new Channel(name, routingKeyPrefix, {
					isReadOnly: isReadOnly,
					isSecret: isSecret,
					isP2P: isP2P,
					isExclusive: null != isExclusive ? isExclusive : isPrivate,
					exchange: exchange,
					mustAuthenticate: mustAuthenticate
				});
				this.on("broker.subscribed", handler = function (routingKeyPrefixes) {
					var prefix, _i, _len, _ref1;
					_ref1 = routingKeyPrefixes.split(" ");
					for (_i = 0, _len = _ref1.length; _len > _i; _i++) {
						prefix = _ref1[_i];
						if (prefix === routingKeyPrefix) {
							_this.authenticate(channel);
							_this.off("broker.subscribed", handler);
							channel.emit("broker.subscribed", channel.routingKeyPrefix);
							return
						}
					}
				});
				this.on(routingKeyPrefix, function () {
					var rest;
					rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
					return channel.isForwarder ? void 0 : channel.emit.apply(channel, ["message"].concat(__slice.call(rest)))
				});
				channel.on("newListener", function (event, listener) {
					var namespacedEvent, needsToBeRegistered;
					(channel.isExclusive || channel.isP2P) && channel.trackListener(event, listener);
					if ("broker.subscribed" !== event) {
						namespacedEvent = "" + routingKeyPrefix + "." + event;
						needsToBeRegistered = _this.registerNamespacedEvent(namespacedEvent);
						if (needsToBeRegistered) return _this.on(namespacedEvent, function () {
							var rest;
							rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
							return emitToChannel.apply(null, [_this, channel, event].concat(__slice.call(rest)))
						})
					}
				});
				isSecret || channel.on("auth.authOk", function () {
					return channel.isAuthenticated = !0
				});
				channel.once("error", channel.bound("close"));
				channel.once("close", function () {
					return _this.unsubscribe(channel.name)
				});
				(isExclusive || isPrivate) && this.wrapPrivateChannel(channel);
				isPrivate || isReadOnly || channel.on("publish", function (options, payload) {
					var _ref1, _ref2, _ref3;
					null == payload && (_ref1 = [options, payload], payload = _ref1[0], options = _ref1[1]);
					exchange = null != (_ref2 = null != (_ref3 = null != options ? options.exchange : void 0) ? _ref3 : channel.exchange) ? _ref2 : channel.name;
					return _this.publish({
						exchange: exchange,
						routingKey: channel.name
					}, payload)
				});
				this.channels[name] = channel;
				return channel
			};
			Broker.prototype.authenticate = function (channel) {
				var authInfo, key, val, _ref1;
				if (channel.mustAuthenticate) {
					authInfo = {};
					_ref1 = channel.getAuthenticationInfo();
					for (key in _ref1)
						if (__hasProp.call(_ref1, key)) {
							val = _ref1[key];
							authInfo[key] = val
						}
					authInfo.routingKey = channel.routingKeyPrefix;
					authInfo.brokerExchange = this.brokerExchange;
					return this.publish(this.authExchange, authInfo)
				}
				return process.nextTick(function () {
					return channel.emit("auth.authOk")
				})
			};
			Broker.prototype.handleMessageEvent = function (event) {
				var message;
				message = event.data;
				this.emit("rawMessage", message);
				message.routingKey && this.emit(message.routingKey, message.payload)
			};
			Broker.prototype.ready = function (listener) {
				return this.readyState === READY ? process.nextTick(listener) : this.once("ready", listener)
			};
			Broker.prototype.send = function (data) {
				var _this = this;
				this.emit("send", data);
				this.ready(function () {
					var e;
					try {
						return _this.ws._transport.doSend(JSON.stringify(data))
					} catch (_error) {
						e = _error;
						return _this.disconnect()
					}
				});
				return this
			};
			Broker.prototype.publish = function (options, payload) {
				var exchange, routingKey;
				this.emit("messagePublished");
				"string" == typeof options ? routingKey = exchange = options : (routingKey = options.routingKey, exchange = options.exchange);
				routingKey = this.createRoutingKeyPrefix(routingKey);
				"string" != typeof payload && (payload = JSON.stringify(payload));
				this.send({
					action: "publish",
					exchange: exchange,
					routingKey: routingKey,
					payload: payload
				});
				return this
			};
			Broker.prototype.resubscribeBySocketId = function (socketId, failCallback) {
				var _this = this;
				if (!socketId) return "function" == typeof failCallback ? failCallback() : void 0;
				this.send({
					action: "resubscribe",
					socketId: socketId
				});
				return this.once("broker.resubscribed", function (found) {
					var channel, _, _ref1;
					if (found) {
						_ref1 = _this.channels;
						for (_ in _ref1)
							if (__hasProp.call(_ref1, _)) {
								channel = _ref1[_];
								channel.resume();
								channel.emit("broker.subscribed")
							}
						return _this.setConnectionData()
					}
					return "function" == typeof failCallback ? failCallback() : void 0
				})
			};
			Broker.prototype.resubscribeByOldSocketId = function (failCallback) {
				var clientId, oldSocket, socketId;
				null == failCallback && (failCallback = function () {});
				if (!this.tryResubscribing) return failCallback();
				oldSocket = this.getConnectionData();
				if (!oldSocket) return failCallback();
				clientId = oldSocket.clientId, socketId = oldSocket.socketId;
				if (this.getSessionToken() === clientId) return this.resubscribeBySocketId(socketId, function () {
					return failCallback()
				});
				this.setConnectionData();
				return failCallback()
			};
			Broker.prototype.resubscribeBySubscriptions = function () {
				var rk, routingKeyPrefix, _, _this = this;
				routingKeyPrefix = function () {
					var _ref1, _results;
					_ref1 = this.subscriptions;
					_results = [];
					for (_ in _ref1)
						if (__hasProp.call(_ref1, _)) {
							rk = _ref1[_].routingKeyPrefix;
							_results.push(rk)
						}
					return _results
				}.call(this).join(" ");
				this.sendSubscriptions(routingKeyPrefix);
				return this.once("broker.subscribed", function (routingKeyPrefixes) {
					var channel, prefix, _i, _len, _ref1, _results;
					_ref1 = routingKeyPrefixes.split(" ");
					_results = [];
					for (_i = 0, _len = _ref1.length; _len > _i; _i++) {
						prefix = _ref1[_i];
						_results.push(function () {
							var _ref2, _results1;
							_ref2 = this.channels;
							_results1 = [];
							for (_ in _ref2)
								if (__hasProp.call(_ref2, _)) {
									channel = _ref2[_];
									if ((null != channel ? channel.routingKeyPrefix : void 0) === prefix) {
										channel.resume();
										_results1.push(channel.emit("broker.subscribed"))
									} else _results1.push(void 0)
								}
							return _results1
						}.call(_this))
					}
					return _results
				})
			};
			Broker.prototype.resubscribe = function () {
				var _this = this;
				return this.resubscribeByOldSocketId(function () {
					return _this.resubscribeBySocketId(_this.socketId, function () {
						_this.resubscribeBySubscriptions();
						return _this.setConnectionData()
					})
				})
			};
			Broker.prototype.subscribe = function (name, options, callback) {
				var channel, exchange, handler, isExclusive, isP2P, isPrivate, isReadOnly, isSecret, mustAuthenticate, routingKeyPrefix, suffix, _ref1, _this = this;
				null == options && (options = {});
				channel = this.channels[name];
				if (null == channel) {
					isSecret = !!options.isSecret;
					isExclusive = !!options.isExclusive;
					isReadOnly = null != options.isReadOnly ? !!options.isReadOnly : isExclusive;
					isPrivate = !!options.isPrivate;
					isP2P = !!options.isP2P;
					mustAuthenticate = null != (_ref1 = options.mustAuthenticate) ? _ref1 : !0;
					suffix = options.suffix, exchange = options.exchange;
					routingKeyPrefix = this.createRoutingKeyPrefix(name, {
						isReadOnly: isReadOnly
					});
					this.subscriptions[name] = {
						name: name,
						routingKeyPrefix: routingKeyPrefix,
						arguments: arguments
					};
					channel = this.channels[name] = this.createChannel(name, {
						isReadOnly: isReadOnly,
						isSecret: isSecret,
						isExclusive: isExclusive,
						isPrivate: isPrivate,
						isP2P: isP2P,
						suffix: suffix,
						exchange: exchange,
						mustAuthenticate: mustAuthenticate
					});
					options.connectDirectly ? this.sendSubscriptions(channel.routingKeyPrefix) : this.enqueueSubscription(channel.routingKeyPrefix)
				}
				null != callback && this.on("broker.subscribed", handler = function (routingKeyPrefixes) {
					var prefix, _i, _len, _ref2;
					_ref2 = routingKeyPrefixes.split(" ");
					for (_i = 0, _len = _ref2.length; _len > _i; _i++) {
						prefix = _ref2[_i];
						if (prefix === routingKeyPrefix) {
							_this.off("broker.subscribed", handler);
							callback(prefix);
							return
						}
					}
				});
				return channel
			};
			Broker.prototype.enqueueSubscription = function (routingKeyPrefix) {
				var i, len;
				i = this.pendingUnsubscriptions.indexOf(routingKeyPrefix);
				if (-1 === i) {
					len = this.pendingSubscriptions.push(routingKeyPrefix);
					1 === len && this.triggerSubscriptions()
				} else this.pendingUnsubscriptions.splice(i, 1);
				return this
			};
			Broker.prototype.triggerSubscriptions = function () {
				var _this = this;
				setTimeout(function () {
					var pendingSubscriptions;
					pendingSubscriptions = _this.pendingSubscriptions;
					_this.pendingSubscriptions = [];
					return pendingSubscriptions.length > 0 ? _this.sendSubscriptions(pendingSubscriptions.join(" ")) : void 0
				}, this.subscriptionThrottleMs);
				return this
			};
			Broker.prototype.sendSubscriptions = function (subscriptions) {
				return this.send({
					action: "subscribe",
					routingKeyPrefix: subscriptions
				})
			};
			Broker.prototype.enqueueUnsubscription = function (routingKeyPrefix) {
				var i, len;
				i = this.pendingSubscriptions.indexOf(routingKeyPrefix);
				if (-1 === i) {
					len = this.pendingUnsubscriptions.push(routingKeyPrefix);
					len >= this.unsubscriptionThreshold && this.sendUnsubscriptions()
				} else this.pendingSubscriptions.splice(i, 1);
				return this
			};
			Broker.prototype.sendUnsubscriptions = function () {
				var key, pendingUnsubscriptions, _i, _len;
				pendingUnsubscriptions = this.pendingUnsubscriptions;
				this.send({
					action: "unsubscribe",
					routingKeyPrefix: pendingUnsubscriptions.join(" ")
				});
				for (_i = 0, _len = pendingSubscriptions.length; _len > _i; _i++) {
					key = pendingSubscriptions[_i];
					this.removeSubscriptionKey(key)
				}
				return this
			};
			Broker.prototype.unsubscribe = function (name) {
				var prefix;
				prefix = this.createRoutingKeyPrefix(name);
				this.send({
					action: "unsubscribe",
					routingKeyPrefix: prefix
				});
				this.removeSubscriptionKey(name);
				return this
			};
			Broker.prototype.removeSubscriptionKey = function (name) {
				delete this.channels[name];
				delete this.subscriptions[name];
				return this
			};
			Broker.prototype.ping = function (callback) {
				this.send({
					action: "ping"
				});
				return null != callback ? this.once("broker.pong", callback) : void 0
			};
			Broker.prototype.getConnectionData = function () {
				var data;
				data = localStorage.getItem("connectiondata");
				return data ? JSON.parse(data) : void 0
			};
			Broker.prototype.setConnectionData = function () {
				var data;
				data = JSON.stringify({
					clientId: this.getSessionToken(),
					socketId: this.socketId
				});
				return localStorage.setItem("connectiondata", data)
			};
			return Broker
		}(KDEventEmitter.Wildcard)
	});
	require.define("/node_modules_koding/koding-broker-client/lib/broker-client/channel.js", function (require, module) {
		var Channel, __hasProp = {}.hasOwnProperty,
			__extends = function (child, parent) {
				function ctor() {
					this.constructor = child
				}
				for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
				ctor.prototype = parent.prototype;
				child.prototype = new ctor;
				child.__super__ = parent.prototype;
				return child
			},
			__slice = [].slice;
		module.exports = Channel = function (_super) {
			function Channel(name, routingKeyPrefix, options) {
				var _this = this;
				this.name = name;
				this.routingKeyPrefix = routingKeyPrefix;
				Channel.__super__.constructor.apply(this, arguments);
				this.isOpen = !0;
				this.isReadOnly = options.isReadOnly, this.isSecret = options.isSecret, this.isExclusive = options.isExclusive, this.isP2P = options.isP2P, this.exchange = options.exchange, this.mustAuthenticate = options.mustAuthenticate;
				if (this.isExclusive || this.isP2P) {
					this.eventRegister = [];
					this.trackListener = function (event, listener) {
						var _ref;
						_this.eventRegister.push({
							event: event,
							listener: listener
						});
						return "publish" !== event && null != (_ref = _this.consumerChannel) ? _ref.on(event, listener) : void 0
					}
				}
			}
			__extends(Channel, _super);
			Channel.prototype.publish = function () {
				var rest;
				rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				return this.isReadOnly ? void 0 : this.emit.apply(this, ["publish"].concat(__slice.call(rest)))
			};
			Channel.prototype.close = function () {
				this.isOpen = !1;
				return this.emit("close")
			};
			Channel.prototype.cycle = function () {
				return this.isOpen ? this.emit("cycle") : void 0
			};
			Channel.prototype.pipe = function (channel) {
				var event, listener, _i, _len, _ref, _ref1;
				_ref = channel.eventRegister;
				for (_i = 0, _len = _ref.length; _len > _i; _i++) {
					_ref1 = _ref[_i], event = _ref1.event, listener = _ref1.listener;
					"publish" !== event && this.on(event, listener)
				}
				return this.on("message", function (message) {
					return channel.emit("message", message)
				})
			};
			Channel.prototype.setAuthenticationInfo = function (authenticationInfo) {
				this.authenticationInfo = authenticationInfo
			};
			Channel.prototype.getAuthenticationInfo = function () {
				return this.authenticationInfo
			};
			Channel.prototype.isListeningTo = function (event) {
				var listeners, _ref;
				listeners = null != (_ref = this._e) ? _ref[event] : void 0;
				return listeners && Object.keys(listeners).length > 0
			};
			Channel.prototype.setSecretName = function (secretName) {
				this.secretName = secretName
			};
			Channel.prototype.interrupt = function () {
				return this.isOpen = !1
			};
			Channel.prototype.resume = function () {
				return this.isOpen = !0
			};
			Channel.prototype.bound = require("koding-bound");
			return Channel
		}(KDEventEmitter)
	});
	require.define("/node_modules/koding-bound/package.json", function (require, module) {
		module.exports = {
			main: "index.js"
		}
	});
	require.define("/node_modules/koding-bound/index.js", function (require, module) {
		module.exports = require("./lib/koding-bound")
	});
	require.define("/node_modules/koding-bound/lib/koding-bound/index.js", function (require, module) {
		module.exports = function (method) {
			var boundMethod;
			if (null == this[method]) throw new Error("@bound: unknown method! " + method);
			boundMethod = "__bound__" + method;
			boundMethod in this || Object.defineProperty(this, boundMethod, {
				value: this[method].bind(this)
			});
			return this[boundMethod]
		}
	});
	require.define("/node_modules/hat/package.json", function (require, module) {
		module.exports = {
			main: "index.js"
		}
	});
	require.define("/node_modules/hat/index.js", function (require, module) {
		var hat = module.exports = function (bits, base) {
			base || (base = 16);
			void 0 === bits && (bits = 128);
			if (0 >= bits) return "0";
			for (var digits = Math.log(Math.pow(2, bits)) / Math.log(base), i = 2; 1 / 0 === digits; i *= 2) digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
			for (var rem = digits - Math.floor(digits), res = "", i = 0; i < Math.floor(digits); i++) {
				var x = Math.floor(Math.random() * base).toString(base);
				res = x + res
			}
			if (rem) {
				var b = Math.pow(base, rem),
					x = Math.floor(Math.random() * b).toString(base);
				res = x + res
			}
			var parsed = parseInt(res, base);
			return 1 / 0 !== parsed && parsed >= Math.pow(2, bits) ? hat(bits, base) : res
		};
		hat.rack = function (bits, base, expandBy) {
			var fn = function (data) {
					var iters = 0;
					do {
						if (iters++ > 10) {
							if (!expandBy) throw new Error("too many ID collisions, use more bits");
							bits += expandBy
						}
						var id = hat(bits, base)
					} while (Object.hasOwnProperty.call(hats, id));
					hats[id] = data;
					return id
				},
				hats = fn.hats = {};
			fn.get = function (id) {
				return fn.hats[id]
			};
			fn.set = function (id, value) {
				fn.hats[id] = value;
				return fn
			};
			fn.bits = bits || 128;
			fn.base = base || 16;
			return fn
		}
	});
	require.define("/node_modules_koding/koding-broker-client/lib/broker-client/util.js", function (require, module, exports) {
		var __slice = [].slice;
		exports.emitToChannel = function () {
			var channel, ctx, event, oldChannelEvent, rest;
			ctx = arguments[0], channel = arguments[1], event = arguments[2], rest = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
			if (!channel.isForwarder || "cycleChannel" === event || "setSecretNames" === event) {
				null != channel.event && (oldChannelEvent = channel.event);
				channel.event = ctx.event;
				channel.emit.apply(channel, [event].concat(__slice.call(rest)));
				null != oldChannelEvent ? channel.event = oldChannelEvent : delete channel.event
			}
		}
	});
	require.define("/node_modules/koding-backoff/package.json", function (require, module) {
		module.exports = {
			main: "index.js"
		}
	});
	require.define("/node_modules/koding-backoff/index.js", function (require, module) {
		module.exports = require("./lib/backoff.js")
	});
	require.define("/node_modules/koding-backoff/lib/backoff.js", function (require, module) {
		module.exports = function (ctx, options) {
			var initalDelayMs, maxDelayMs, maxReconnectAttempts, multiplyFactor, totalReconnectAttempts, _ref, _ref1, _ref2, _ref3, _ref4;
			null == options && (options = {});
			options || (_ref = [ctx, options], options = _ref[0], ctx = _ref[1]);
			ctx || (ctx = this);
			totalReconnectAttempts = 0;
			initalDelayMs = null != (_ref1 = options.initialDelayMs) ? _ref1 : 700;
			multiplyFactor = null != (_ref2 = options.multiplyFactor) ? _ref2 : 1.4;
			maxDelayMs = null != (_ref3 = options.maxDelayMs) ? _ref3 : 15e3;
			maxReconnectAttempts = null != (_ref4 = options.maxReconnectAttempts) ? _ref4 : 50;
			ctx.clearBackoffTimeout = function () {
				return totalReconnectAttempts = 0
			};
			ctx.setBackoffTimeout = function (attemptFn, failFn) {
				var timeout;
				if (maxReconnectAttempts > totalReconnectAttempts) {
					timeout = Math.min(initalDelayMs * Math.pow(multiplyFactor, totalReconnectAttempts), maxDelayMs);
					setTimeout(attemptFn, timeout);
					return totalReconnectAttempts++
				}
				return failFn()
			};
			return ctx
		}
	});
	require.define("/node_modules_koding/koding-broker-client/index.js", function (require, module) {
		module.exports = require("./lib/broker-client")
	});
	require("/node_modules_koding/koding-broker-client/index.js")
}();
! function () {
	! function () {
		var require = function (file, cwd) {
			var resolved = require.resolve(file, cwd || "/"),
				mod = require.modules[resolved];
			if (!mod) throw new Error("Failed to resolve module " + file + ", tried " + resolved);
			var cached = require.cache[resolved],
				res = cached ? cached.exports : mod();
			return res
		};
		require.paths = [];
		require.modules = {};
		require.cache = {};
		require.extensions = [".js", ".coffee"];
		require._core = {
			assert: !0,
			events: !0,
			fs: !0,
			path: !0,
			vm: !0
		};
		require.resolve = function () {
			return function (x, cwd) {
				function loadAsFileSync(x) {
					x = path.normalize(x);
					if (require.modules[x]) return x;
					for (var i = 0; i < require.extensions.length; i++) {
						var ext = require.extensions[i];
						if (require.modules[x + ext]) return x + ext
					}
				}

				function loadAsDirectorySync(x) {
					x = x.replace(/\/+$/, "");
					var pkgfile = path.normalize(x + "/package.json");
					if (require.modules[pkgfile]) {
						var pkg = require.modules[pkgfile](),
							b = pkg.browserify;
						if ("object" == typeof b && b.main) {
							var m = loadAsFileSync(path.resolve(x, b.main));
							if (m) return m
						} else if ("string" == typeof b) {
							var m = loadAsFileSync(path.resolve(x, b));
							if (m) return m
						} else if (pkg.main) {
							var m = loadAsFileSync(path.resolve(x, pkg.main));
							if (m) return m
						}
					}
					return loadAsFileSync(x + "/index")
				}

				function loadNodeModulesSync(x, start) {
					for (var dirs = nodeModulesPathsSync(start), i = 0; i < dirs.length; i++) {
						var dir = dirs[i],
							m = loadAsFileSync(dir + "/" + x);
						if (m) return m;
						var n = loadAsDirectorySync(dir + "/" + x);
						if (n) return n
					}
					var m = loadAsFileSync(x);
					return m ? m : void 0
				}

				function nodeModulesPathsSync(start) {
					var parts;
					parts = "/" === start ? [""] : path.normalize(start).split("/");
					for (var dirs = [], i = parts.length - 1; i >= 0; i--)
						if ("node_modules" !== parts[i]) {
							var dir = parts.slice(0, i + 1).join("/") + "/node_modules";
							dirs.push(dir)
						}
					return dirs
				}
				cwd || (cwd = "/");
				if (require._core[x]) return x;
				var path = require.modules.path();
				cwd = path.resolve("/", cwd);
				var y = cwd || "/";
				if (x.match(/^(?:\.\.?\/|\/)/)) {
					var m = loadAsFileSync(path.resolve(y, x)) || loadAsDirectorySync(path.resolve(y, x));
					if (m) return m
				}
				var n = loadNodeModulesSync(x, y);
				if (n) return n;
				throw new Error("Cannot find module '" + x + "'")
			}
		}();
		require.alias = function (from, to) {
			var path = require.modules.path(),
				res = null;
			try {
				res = require.resolve(from + "/package.json", "/")
			} catch (err) {
				res = require.resolve(from, "/")
			}
			for (var basedir = path.dirname(res), keys = (Object.keys || function (obj) {
				var res = [];
				for (var key in obj) res.push(key);
				return res
			})(require.modules), i = 0; i < keys.length; i++) {
				var key = keys[i];
				if (key.slice(0, basedir.length + 1) === basedir + "/") {
					var f = key.slice(basedir.length);
					require.modules[to + f] = require.modules[basedir + f]
				} else key === basedir && (require.modules[to] = require.modules[basedir])
			}
		};
		! function () {
			var process = {};
			require.define = function (filename, fn) {
				require.modules.__browserify_process && (process = require.modules.__browserify_process());
				var dirname = require._core[filename] ? "" : require.modules.path().dirname(filename),
					require_ = function (file) {
						var requiredModule = require(file, dirname),
							cached = require.cache[require.resolve(file, dirname)];
						cached && null === cached.parent && (cached.parent = module_);
						return requiredModule
					};
				require_.resolve = function (name) {
					return require.resolve(name, dirname)
				};
				require_.modules = require.modules;
				require_.define = require.define;
				require_.cache = require.cache;
				var module_ = {
					id: filename,
					filename: filename,
					exports: {},
					loaded: !1,
					parent: null
				};
				require.modules[filename] = function () {
					require.cache[filename] = module_;
					fn.call(module_.exports, require_, module_, module_.exports, dirname, filename, process);
					module_.loaded = !0;
					return module_.exports
				}
			}
		}();
		require.define("path", function (require, module, exports, __dirname, __filename, process) {
			function filter(xs, fn) {
				for (var res = [], i = 0; i < xs.length; i++) fn(xs[i], i, xs) && res.push(xs[i]);
				return res
			}

			function normalizeArray(parts, allowAboveRoot) {
				for (var up = 0, i = parts.length; i >= 0; i--) {
					var last = parts[i];
					if ("." == last) parts.splice(i, 1);
					else if (".." === last) {
						parts.splice(i, 1);
						up++
					} else if (up) {
						parts.splice(i, 1);
						up--
					}
				}
				if (allowAboveRoot)
					for (; up--; up) parts.unshift("..");
				return parts
			}
			var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;
			exports.resolve = function () {
				for (var resolvedPath = "", resolvedAbsolute = !1, i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
					var path = i >= 0 ? arguments[i] : process.cwd();
					if ("string" == typeof path && path) {
						resolvedPath = path + "/" + resolvedPath;
						resolvedAbsolute = "/" === path.charAt(0)
					}
				}
				resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function (p) {
					return !!p
				}), !resolvedAbsolute).join("/");
				return (resolvedAbsolute ? "/" : "") + resolvedPath || "."
			};
			exports.normalize = function (path) {
				var isAbsolute = "/" === path.charAt(0),
					trailingSlash = "/" === path.slice(-1);
				path = normalizeArray(filter(path.split("/"), function (p) {
					return !!p
				}), !isAbsolute).join("/");
				path || isAbsolute || (path = ".");
				path && trailingSlash && (path += "/");
				return (isAbsolute ? "/" : "") + path
			};
			exports.join = function () {
				var paths = Array.prototype.slice.call(arguments, 0);
				return exports.normalize(filter(paths, function (p) {
					return p && "string" == typeof p
				}).join("/"))
			};
			exports.dirname = function (path) {
				var dir = splitPathRe.exec(path)[1] || "",
					isWindows = !1;
				return dir ? 1 === dir.length || isWindows && dir.length <= 3 && ":" === dir.charAt(1) ? dir : dir.substring(0, dir.length - 1) : "."
			};
			exports.basename = function (path, ext) {
				var f = splitPathRe.exec(path)[2] || "";
				ext && f.substr(-1 * ext.length) === ext && (f = f.substr(0, f.length - ext.length));
				return f
			};
			exports.extname = function (path) {
				return splitPathRe.exec(path)[3] || ""
			}
		});
		require.define("__browserify_process", function (require, module, exports, __dirname, __filename, process) {
			var process = module.exports = {};
			process.nextTick = function () {
				var queue = [],
					canPost = "undefined" != typeof window && window.postMessage && window.addEventListener;
				canPost && window.addEventListener("message", function (ev) {
					if (ev.source === window && "browserify-tick" === ev.data) {
						ev.stopPropagation();
						if (queue.length > 0) {
							var fn = queue.shift();
							fn()
						}
					}
				}, !0);
				return function (fn) {
					if (canPost) {
						queue.push(fn);
						window.postMessage("browserify-tick", "*")
					} else setTimeout(fn, 0)
				}
			}();
			process.title = "browser";
			process.browser = !0;
			process.env = {};
			process.argv = [];
			process.binding = function (name) {
				if ("evals" === name) return require("vm");
				throw new Error("No such module. (Possibly not yet loaded)")
			};
			! function () {
				var path, cwd = "/";
				process.cwd = function () {
					return cwd
				};
				process.chdir = function (dir) {
					path || (path = require("path"));
					cwd = path.resolve(dir, cwd)
				}
			}()
		});
		require.define("vm", function (require, module) {
			module.exports = require("vm-browserify")
		});
		require.define("/node_modules/vm-browserify/package.json", function (require, module) {
			module.exports = {
				main: "index.js"
			}
		});
		require.define("/node_modules/vm-browserify/index.js", function (require, module, exports, __dirname, __filename, process) {
			var Object_keys = function (obj) {
					if (Object.keys) return Object.keys(obj);
					var res = [];
					for (var key in obj) res.push(key);
					return res
				},
				forEach = function (xs, fn) {
					if (xs.forEach) return xs.forEach(fn);
					for (var i = 0; i < xs.length; i++) fn(xs[i], i, xs)
				},
				Script = exports.Script = function (code) {
					if (!(this instanceof Script)) return new Script(code);
					this.code = code;
					return void 0
				};
			Script.prototype.runInNewContext = function (context) {
				context || (context = {});
				var iframe = document.createElement("iframe");
				iframe.style || (iframe.style = {});
				iframe.style.display = "none";
				document.body.appendChild(iframe);
				var win = iframe.contentWindow;
				forEach(Object_keys(context), function (key) {
					win[key] = context[key]
				});
				!win.eval && win.execScript && win.execScript("null");
				var res = win.eval(this.code);
				forEach(Object_keys(win), function (key) {
					context[key] = win[key]
				});
				document.body.removeChild(iframe);
				return res
			};
			Script.prototype.runInThisContext = function () {
				return eval(this.code)
			};
			Script.prototype.runInContext = function (context) {
				return this.runInNewContext(context)
			};
			forEach(Object_keys(Script.prototype), function (name) {
				exports[name] = Script[name] = function (code) {
					var s = Script(code);
					return s[name].apply(s, [].slice.call(arguments, 1))
				}
			});
			exports.createScript = function (code) {
				return exports.Script(code)
			};
			exports.createContext = Script.createContext = function (context) {
				var copy = {};
				"object" == typeof context && forEach(Object_keys(context), function (key) {
					copy[key] = context[key]
				});
				return copy
			}
		});
		require.define("/node_modules/microemitter/package.json", function (require, module) {
			module.exports = {
				main: "index.js"
			}
		});
		require.define("/node_modules/microemitter/index.js", function (require, module) {
			var EventEmitter, __slice = [].slice,
				__hasProp = {}.hasOwnProperty;
			EventEmitter = function () {
				"use strict";

				function EventEmitter(obj) {
					null != obj && mixin(obj)
				}
				var createId, defineProperty, idKey, init, mixin;
				idKey = "\u0ca0_\u0ca0";
				EventEmitter.listeners = {};
				EventEmitter.targets = {};
				EventEmitter.off = function (listenerId) {
					delete this.listeners[listenerId];
					delete this.targets[listenerId];
					return this
				};
				defineProperty = Object.defineProperty || function (obj, prop, _arg) {
					var value;
					value = _arg.value;
					return obj[prop] = value
				};
				createId = function () {
					var counter;
					counter = 0;
					return function () {
						return counter++
					}
				}();
				mixin = function (obj) {
					var prop, prot, _results;
					prot = EventEmitter.prototype;
					_results = [];
					for (prop in prot) _results.push(obj[prop] = prot[prop]);
					return _results
				};
				init = function (obj) {
					idKey in obj || defineProperty(obj, idKey, {
						value: "" + Math.round(1e9 * Math.random())
					});
					return "_events" in obj ? void 0 : defineProperty(obj, "_events", {
						value: {}
					})
				};
				EventEmitter.prototype.on = function (evt, listener) {
					var lid, listeners, _base;
					if (null == listener) throw new Error("Listener is required!");
					init(this);
					this.emit("newListener", evt, listener);
					listeners = (_base = this._events)[evt] || (_base[evt] = {});
					if (this[idKey] in listener) lid = listener[this[idKey]];
					else {
						lid = createId();
						defineProperty(listener, this[idKey], {
							value: lid
						})
					}
					EventEmitter.listeners[lid] = listeners[lid] = listener;
					EventEmitter.targets[lid] = this;
					return this
				};
				EventEmitter.prototype.once = function (evt, listener) {
					var wrappedListener, _this = this;
					wrappedListener = function () {
						var rest;
						rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
						_this.off(evt, wrappedListener);
						return listener.apply(_this, rest)
					};
					return this.on(evt, wrappedListener)
				};
				EventEmitter.prototype.off = function (evt, listener) {
					var key, listenerId, listeners, _ref;
					init(this);
					switch (arguments.length) {
					case 0:
						_ref = this._events;
						for (key in _ref) __hasProp.call(_ref, key) && delete this._events[key];
						break;
					case 1:
						this._events[evt] = {};
						break;
					default:
						listeners = this._events[evt];
						listenerId = listener[this[idKey]];
						null != listeners && delete listeners[listenerId];
						EventEmitter.off(listenerId)
					}
					return this
				};
				EventEmitter.prototype.emit = function () {
					var evt, id, listener, listeners, rest, _ref;
					evt = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
					init(this);
					listeners = null != (_ref = this._events[evt]) ? _ref : [];
					for (id in listeners)
						if (__hasProp.call(listeners, id)) {
							listener = listeners[id];
							listener.call.apply(listener, [this].concat(__slice.call(rest)))
						}
					if ("error" === evt && 0 === listeners.length) throw rest[0];
					return this
				};
				return EventEmitter
			}();
			null != ("undefined" != typeof module && null !== module ? module.exports : void 0) ? module.exports.EventEmitter = EventEmitter : null != ("undefined" != typeof define && null !== define ? define.amd : void 0) ? define(function () {
				return EventEmitter
			}) : this.EventEmitter = EventEmitter
		});
		require.define("/node_modules/traverse/package.json", function (require, module) {
			module.exports = {
				main: "index.js"
			}
		});
		require.define("/node_modules/traverse/index.js", function (require, module) {
			function Traverse(obj) {
				this.value = obj
			}

			function walk(root, cb, immutable) {
				var path = [],
					parents = [],
					alive = !0;
				return function walker(node_) {
					function updateState() {
						if ("object" == typeof state.node && null !== state.node) {
							state.keys && state.node_ === state.node || (state.keys = objectKeys(state.node));
							state.isLeaf = 0 == state.keys.length;
							for (var i = 0; i < parents.length; i++)
								if (parents[i].node_ === node_) {
									state.circular = parents[i];
									break
								}
						} else {
							state.isLeaf = !0;
							state.keys = null
						}
						state.notLeaf = !state.isLeaf;
						state.notRoot = !state.isRoot
					}
					var node = immutable ? copy(node_) : node_,
						modifiers = {},
						keepGoing = !0,
						state = {
							node: node,
							node_: node_,
							path: [].concat(path),
							parent: parents[parents.length - 1],
							parents: parents,
							key: path.slice(-1)[0],
							isRoot: 0 === path.length,
							level: path.length,
							circular: null,
							update: function (x, stopHere) {
								state.isRoot || (state.parent.node[state.key] = x);
								state.node = x;
								stopHere && (keepGoing = !1)
							},
							"delete": function (stopHere) {
								delete state.parent.node[state.key];
								stopHere && (keepGoing = !1)
							},
							remove: function (stopHere) {
								isArray(state.parent.node) ? state.parent.node.splice(state.key, 1) : delete state.parent.node[state.key];
								stopHere && (keepGoing = !1)
							},
							keys: null,
							before: function (f) {
								modifiers.before = f
							},
							after: function (f) {
								modifiers.after = f
							},
							pre: function (f) {
								modifiers.pre = f
							},
							post: function (f) {
								modifiers.post = f
							},
							stop: function () {
								alive = !1
							},
							block: function () {
								keepGoing = !1
							}
						};
					if (!alive) return state;
					updateState();
					var ret = cb.call(state, state.node);
					void 0 !== ret && state.update && state.update(ret);
					modifiers.before && modifiers.before.call(state, state.node);
					if (!keepGoing) return state;
					if ("object" == typeof state.node && null !== state.node && !state.circular) {
						parents.push(state);
						updateState();
						forEach(state.keys, function (key, i) {
							path.push(key);
							modifiers.pre && modifiers.pre.call(state, state.node[key], key);
							var child = walker(state.node[key]);
							immutable && hasOwnProperty.call(state.node, key) && (state.node[key] = child.node);
							child.isLast = i == state.keys.length - 1;
							child.isFirst = 0 == i;
							modifiers.post && modifiers.post.call(state, child);
							path.pop()
						});
						parents.pop()
					}
					modifiers.after && modifiers.after.call(state, state.node);
					return state
				}(root).node
			}

			function copy(src) {
				if ("object" == typeof src && null !== src) {
					var dst;
					if (isArray(src)) dst = [];
					else if (isDate(src)) dst = new Date(src.getTime ? src.getTime() : src);
					else if (isRegExp(src)) dst = new RegExp(src);
					else if (isError(src)) dst = {
						message: src.message,
						internal: "stack" in src
					};
					else if (isBoolean(src)) dst = new Boolean(src);
					else if (isNumber(src)) dst = new Number(src);
					else if (isString(src)) dst = new String(src);
					else if (Object.create && Object.getPrototypeOf) dst = Object.create(Object.getPrototypeOf(src));
					else if (src.constructor === Object) dst = {};
					else {
						var proto = src.constructor && src.constructor.prototype || src.__proto__ || {},
							T = function () {};
						T.prototype = proto;
						dst = new T
					}
					forEach(objectKeys(src), function (key) {
						dst[key] = src[key]
					});
					return dst
				}
				return src
			}

			function toS(obj) {
				return Object.prototype.toString.call(obj)
			}

			function isDate(obj) {
				return "[object Date]" === toS(obj)
			}

			function isRegExp(obj) {
				return "[object RegExp]" === toS(obj)
			}

			function isError(obj) {
				return "[object Error]" === toS(obj)
			}

			function isBoolean(obj) {
				return "[object Boolean]" === toS(obj)
			}

			function isNumber(obj) {
				return "[object Number]" === toS(obj)
			}

			function isString(obj) {
				return "[object String]" === toS(obj)
			}
			var traverse = module.exports = function (obj) {
				return new Traverse(obj)
			};
			Traverse.prototype.get = function (ps) {
				for (var node = this.value, i = 0; i < ps.length; i++) {
					var key = ps[i];
					if (!node || !hasOwnProperty.call(node, key)) {
						node = void 0;
						break
					}
					node = node[key]
				}
				return node
			};
			Traverse.prototype.has = function (ps) {
				for (var node = this.value, i = 0; i < ps.length; i++) {
					var key = ps[i];
					if (!node || !hasOwnProperty.call(node, key)) return !1;
					node = node[key]
				}
				return !0
			};
			Traverse.prototype.set = function (ps, value) {
				for (var node = this.value, i = 0; i < ps.length - 1; i++) {
					var key = ps[i];
					hasOwnProperty.call(node, key) || (node[key] = {});
					node = node[key]
				}
				node[ps[i]] = value;
				return value
			};
			Traverse.prototype.map = function (cb) {
				return walk(this.value, cb, !0)
			};
			Traverse.prototype.forEach = function (cb) {
				this.value = walk(this.value, cb, !1);
				return this.value
			};
			Traverse.prototype.reduce = function (cb, init) {
				var skip = 1 === arguments.length,
					acc = skip ? this.value : init;
				this.forEach(function (x) {
					this.isRoot && skip || (acc = cb.call(this, acc, x))
				});
				return acc
			};
			Traverse.prototype.paths = function () {
				var acc = [];
				this.forEach(function () {
					acc.push(this.path)
				});
				return acc
			};
			Traverse.prototype.nodes = function () {
				var acc = [];
				this.forEach(function () {
					acc.push(this.node)
				});
				return acc
			};
			Traverse.prototype.clone = function () {
				var parents = [],
					nodes = [];
				return function clone(src) {
					for (var i = 0; i < parents.length; i++)
						if (parents[i] === src) return nodes[i];
					if ("object" == typeof src && null !== src) {
						var dst = copy(src);
						parents.push(src);
						nodes.push(dst);
						forEach(objectKeys(src), function (key) {
							dst[key] = clone(src[key])
						});
						parents.pop();
						nodes.pop();
						return dst
					}
					return src
				}(this.value)
			};
			var objectKeys = Object.keys || function (obj) {
					var res = [];
					for (var key in obj) res.push(key);
					return res
				},
				isArray = Array.isArray || function (xs) {
					return "[object Array]" === Object.prototype.toString.call(xs)
				},
				forEach = function (xs, fn) {
					if (xs.forEach) return xs.forEach(fn);
					for (var i = 0; i < xs.length; i++) fn(xs[i], i, xs)
				};
			forEach(objectKeys(Traverse.prototype), function (key) {
				traverse[key] = function (obj) {
					var args = [].slice.call(arguments, 1),
						t = new Traverse(obj);
					return t[key].apply(t, args)
				}
			});
			var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
				return key in obj
			}
		});
		require.define("/node_modules/hat/package.json", function (require, module) {
			module.exports = {
				main: "index.js"
			}
		});
		require.define("/node_modules/hat/index.js", function (require, module) {
			var hat = module.exports = function (bits, base) {
				base || (base = 16);
				void 0 === bits && (bits = 128);
				if (0 >= bits) return "0";
				for (var digits = Math.log(Math.pow(2, bits)) / Math.log(base), i = 2; 1 / 0 === digits; i *= 2) digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
				for (var rem = digits - Math.floor(digits), res = "", i = 0; i < Math.floor(digits); i++) {
					var x = Math.floor(Math.random() * base).toString(base);
					res = x + res
				}
				if (rem) {
					var b = Math.pow(base, rem),
						x = Math.floor(Math.random() * b).toString(base);
					res = x + res
				}
				var parsed = parseInt(res, base);
				return 1 / 0 !== parsed && parsed >= Math.pow(2, bits) ? hat(bits, base) : res
			};
			hat.rack = function (bits, base, expandBy) {
				var fn = function (data) {
						var iters = 0;
						do {
							if (iters++ > 10) {
								if (!expandBy) throw new Error("too many ID collisions, use more bits");
								bits += expandBy
							}
							var id = hat(bits, base)
						} while (Object.hasOwnProperty.call(hats, id));
						hats[id] = data;
						return id
					},
					hats = fn.hats = {};
				fn.get = function (id) {
					return fn.hats[id]
				};
				fn.set = function (id, value) {
					fn.hats[id] = value;
					return fn
				};
				fn.bits = bits || 128;
				fn.base = base || 16;
				return fn
			}
		});
		require.define("/node_modules/jspath/package.json", function (require, module) {
			module.exports = {
				main: "index.js"
			}
		});
		require.define("/node_modules/jspath/index.js", function (require, module) {
			(function () {
				var JsPath, __slice = Array.prototype.slice;
				module.exports = JsPath = function () {
					function JsPath(path, val) {
						return JsPath.setAt({}, path, val || {})
					}
					var primTypes;
					primTypes = /^(string|number|boolean)$/;
					["forEach", "indexOf", "join", "pop", "reverse", "shift", "sort", "splice", "unshift", "push"].forEach(function (method) {
						return JsPath[method + "At"] = function () {
							var obj, path, rest, target;
							obj = arguments[0], path = arguments[1], rest = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
							target = JsPath.getAt(obj, path);
							if ("function" == typeof (null != target ? target[method] : void 0)) return target[method].apply(target, rest);
							throw new Error("Does not implement method " + method + " at " + path)
						}
					});
					JsPath.getAt = function (ref, path) {
						var prop;
						path = "function" == typeof path.split ? path.split(".") : path.slice();
						for (; null != ref && (prop = path.shift());) ref = ref[prop];
						return ref
					};
					JsPath.setAt = function (obj, path, val) {
						var component, last, prev, ref;
						path = "function" == typeof path.split ? path.split(".") : path.slice();
						last = path.pop();
						prev = [];
						ref = obj;
						for (; component = path.shift();) {
							if (primTypes.test(typeof ref[component])) throw new Error("" + prev.concat(component).join(".") + " is\nprimitive, and cannot be extended.");
							ref = ref[component] || (ref[component] = {});
							prev.push(component)
						}
						ref[last] = val;
						return obj
					};
					JsPath.assureAt = function (ref, path, initializer) {
						var obj;
						if (obj = JsPath.getAt(ref, path)) return obj;
						JsPath.setAt(ref, path, initializer);
						return initializer
					};
					JsPath.deleteAt = function (ref, path) {
						var component, last, prev;
						path = "function" == typeof path.split ? path.split(".") : path.slice();
						prev = [];
						last = path.pop();
						for (; component = path.shift();) {
							if (primTypes.test(typeof ref[component])) throw new Error("" + prev.concat(component).join(".") + " is\nprimitive; cannot drill any deeper.");
							if (!(ref = ref[component])) return !1;
							prev.push(component)
						}
						return delete ref[last]
					};
					return JsPath
				}.call(this)
			}).call(this)
		});
		require.define("/node_modules/koding-dnode-protocol/package.json", function (require, module) {
			module.exports = {
				main: "index.js"
			}
		});
		require.define("/node_modules/koding-dnode-protocol/index.js", function (require, module, exports, __dirname, __filename, process) {
			var DnodeScrubber, DnodeSession, DnodeStore, EventEmitter, Scrubber, createId, exports, getAt, json, parseArgs, setAt, stream, _ref, __bind = function (fn, me) {
					return function () {
						return fn.apply(me, arguments)
					}
				},
				__hasProp = {}.hasOwnProperty,
				__extends = function (child, parent) {
					function ctor() {
						this.constructor = child
					}
					for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				};
			EventEmitter = require("events").EventEmitter;
			_ref = require("jspath"), getAt = _ref.getAt, setAt = _ref.setAt;
			Scrubber = require("scrubber");
			createId = require("hat").rack();
			stream = "browser" === process.title ? {} : require("stream");
			json = "undefined" != typeof JSON && null !== JSON ? JSON : require("jsonify");
			exports = module.exports = function (wrapper) {
				return {
					sessions: {},
					create: function () {
						var id;
						id = createId();
						return this.sessions[id] = new DnodeSession(id, wrapper)
					},
					destroy: function (id) {
						return delete this.sessions[id]
					}
				}
			};
			exports.Session = DnodeSession = function (_super) {
				function DnodeSession(id, wrapper) {
					var _this = this;
					this.id = id;
					this.parse = __bind(this.parse, this);
					this.remote = {};
					this.instance = "function" == typeof wrapper ? new wrapper(this.remote, this) : wrapper || {};
					this.localStore = new DnodeStore;
					this.remoteStore = new DnodeStore;
					this.localStore.on("cull", function (id) {
						return _this.emit("request", {
							method: "cull",
							arguments: [id],
							callbacks: {}
						})
					})
				}
				var apply;
				__extends(DnodeSession, _super);
				DnodeSession.prototype.start = function () {
					return this.request("methods", [this.instance])
				};
				DnodeSession.prototype.request = function (method, args) {
					var scrubber, _this = this;
					scrubber = new DnodeScrubber(this.localStore);
					return scrubber.scrub(args, function () {
						var scrubbed;
						scrubbed = scrubber.toDnodeProtocol();
						scrubbed.method = method;
						return _this.emit("request", scrubbed)
					})
				};
				DnodeSession.prototype.parse = function (line) {
					var err, msg;
					try {
						msg = json.parse(line)
					} catch (_error) {
						err = _error;
						this.emit("error", new SyntaxError("JSON parsing error: " + err))
					}
					return this.handle(msg)
				};
				DnodeSession.prototype.handle = function (msg) {
					var args, method, scrubber, _this = this;
					scrubber = new DnodeScrubber(this.localStore);
					args = scrubber.unscrub(msg, function (callbackId) {
						_this.remoteStore.has(callbackId) || _this.remoteStore.add(callbackId, function () {
							return _this.request(callbackId, [].slice.call(arguments))
						});
						return _this.remoteStore.get(callbackId)
					});
					method = msg.method;
					switch (method) {
					case "methods":
						return this.handleMethods(args[0]);
					case "error":
						return this.emit("remoteError", args[0]);
					case "cull":
						return args.forEach(function (id) {
							return _this.remoteStore.cull(id)
						});
					default:
						switch (typeof method) {
						case "string":
							return this.instance.propertyIsEnumerable(method) ? apply(this.instance[method], this.instance, args) : this.emit("error", new Error("Request for non-enumerable method: " + method));
						case "number":
							return apply(this.localStore.get(method), this.instance, args)
						}
					}
				};
				DnodeSession.prototype.handleMethods = function (methods) {
					var _this = this;
					null == methods && (methods = {});
					Object.keys(this.remote).forEach(function (key) {
						return delete _this.remote[key]
					});
					Object.keys(methods).forEach(function (key) {
						return _this.remote[key] = methods[key]
					});
					this.emit("remote", this.remote);
					return this.emit("ready")
				};
				apply = function (fn, ctx, args) {
					return fn.apply(ctx, args)
				};
				return DnodeSession
			}(EventEmitter);
			exports.Scrubber = DnodeScrubber = function (_super) {
				function DnodeScrubber(store, stack, autoCull) {
					var dnodeMutators, userStack, _ref1;
					null == store && (store = new DnodeStore);
					null == autoCull && (autoCull = !0);
					this.paths = {};
					this.links = [];
					dnodeMutators = [
						function (cursor) {
							var i, id, node, path;
							node = cursor.node, path = cursor.path;
							if ("function" == typeof node) {
								i = store.indexOf(node);
								if (!~i || i in this.paths) {
									autoCull && (node.times = 1);
									id = store.add(node);
									this.paths[id] = path
								} else this.paths[i] = path;
								return cursor.update("[Function]", !0)
							}
						}
					];
					userStack = null != (_ref1 = null != stack ? stack : DnodeScrubber.stack) ? _ref1 : [];
					Scrubber.apply(this, dnodeMutators.concat(userStack))
				}
				__extends(DnodeScrubber, _super);
				DnodeScrubber.prototype.unscrub = function (msg, getCallback) {
					var args;
					args = msg.arguments || [];
					Object.keys(msg.callbacks || {}).forEach(function (strId) {
						var callback, id, path;
						id = parseInt(strId, 10);
						path = msg.callbacks[id];
						callback = getCallback(id);
						callback.id = id;
						return setAt(args, path, callback)
					});
					(msg.links || []).forEach(function (link) {
						return setAt(args, link.to, getAt(args, link.from))
					});
					return args
				};
				DnodeScrubber.prototype.toDnodeProtocol = function () {
					var out;
					out = {
						arguments: this.out
					};
					out.callbacks = this.paths;
					this.links.length && (out.links = this.links);
					return out
				};
				return DnodeScrubber
			}(Scrubber);
			exports.Store = DnodeStore = function (_super) {
				function DnodeStore() {
					this.items = []
				}
				__extends(DnodeStore, _super);
				DnodeStore.prototype.has = function (id) {
					return null != this.items[id]
				};
				DnodeStore.prototype.get = function (id) {
					var item;
					item = this.items[id];
					return null == item ? null : this.wrap(item)
				};
				DnodeStore.prototype.add = function (id, fn) {
					var _ref1;
					fn || (_ref1 = [id, fn], fn = _ref1[0], id = _ref1[1]);
					null == id && (id = this.items.length);
					this.items[id] = fn;
					return id
				};
				DnodeStore.prototype.cull = function (arg) {
					"function" == typeof arg && (arg = this.items.indexOf(arg));
					delete this.items[arg];
					return arg
				};
				DnodeStore.prototype.indexOf = function (fn) {
					return this.items.indexOf(fn)
				};
				DnodeStore.prototype.wrap = function (fn) {
					var _this = this;
					return function () {
						fn.apply(_this, arguments);
						return _this.autoCull(fn)
					}
				};
				DnodeStore.prototype.autoCull = function (fn) {
					var id;
					if ("number" == typeof fn.times) {
						fn.times--;
						if (0 === fn.times) {
							id = this.cull(fn);
							return this.emit("cull", id)
						}
					}
				};
				return DnodeStore
			}(EventEmitter);
			parseArgs = exports.parseArgs = function (argv) {
				var params;
				params = {};
				[].slice.call(argv).forEach(function (arg) {
					switch (typeof arg) {
					case "string":
						return arg.match(/^\d+$/) ? params.port = parseInt(arg, 10) : arg.match("^/") ? params.path = arg : params.host = arg;
					case "number":
						return params.port = arg;
					case "function":
						return params.block = arg;
					case "object":
						return arg.__proto__ === Object.prototype ? Object.keys(arg).forEach(function (key) {
							return params[key] = arg[key]
						}) : stream.Stream && arg instanceof stream.Stream ? params.stream = arg : params.server = arg;
					case "undefined":
						break;
					default:
						throw new Error("Not sure what to do about " + typeof arg + " objects")
					}
				});
				return params
			}
		});
		require.define("events", function (require, module, exports, __dirname, __filename, process) {
			process.EventEmitter || (process.EventEmitter = function () {});
			var EventEmitter = exports.EventEmitter = process.EventEmitter,
				isArray = "function" == typeof Array.isArray ? Array.isArray : function (xs) {
					return "[object Array]" === Object.prototype.toString.call(xs)
				},
				defaultMaxListeners = 10;
			EventEmitter.prototype.setMaxListeners = function (n) {
				this._events || (this._events = {});
				this._events.maxListeners = n
			};
			EventEmitter.prototype.emit = function (type) {
				if ("error" === type && (!this._events || !this._events.error || isArray(this._events.error) && !this._events.error.length)) throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
				if (!this._events) return !1;
				var handler = this._events[type];
				if (!handler) return !1;
				if ("function" == typeof handler) {
					switch (arguments.length) {
					case 1:
						handler.call(this);
						break;
					case 2:
						handler.call(this, arguments[1]);
						break;
					case 3:
						handler.call(this, arguments[1], arguments[2]);
						break;
					default:
						var args = Array.prototype.slice.call(arguments, 1);
						handler.apply(this, args)
					}
					return !0
				}
				if (isArray(handler)) {
					for (var args = Array.prototype.slice.call(arguments, 1), listeners = handler.slice(), i = 0, l = listeners.length; l > i; i++) listeners[i].apply(this, args);
					return !0
				}
				return !1
			};
			EventEmitter.prototype.addListener = function (type, listener) {
				if ("function" != typeof listener) throw new Error("addListener only takes instances of Function");
				this._events || (this._events = {});
				this.emit("newListener", type, listener);
				if (this._events[type])
					if (isArray(this._events[type])) {
						if (!this._events[type].warned) {
							var m;
							m = void 0 !== this._events.maxListeners ? this._events.maxListeners : defaultMaxListeners;
							if (m && m > 0 && this._events[type].length > m) {
								this._events[type].warned = !0;
								console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[type].length);
								console.trace()
							}
						}
						this._events[type].push(listener)
					} else this._events[type] = [this._events[type], listener];
				else this._events[type] = listener;
				return this
			};
			EventEmitter.prototype.on = EventEmitter.prototype.addListener;
			EventEmitter.prototype.once = function (type, listener) {
				var self = this;
				self.on(type, function g() {
					self.removeListener(type, g);
					listener.apply(this, arguments)
				});
				return this
			};
			EventEmitter.prototype.removeListener = function (type, listener) {
				if ("function" != typeof listener) throw new Error("removeListener only takes instances of Function");
				if (!this._events || !this._events[type]) return this;
				var list = this._events[type];
				if (isArray(list)) {
					var i = list.indexOf(listener);
					if (0 > i) return this;
					list.splice(i, 1);
					0 == list.length && delete this._events[type]
				} else this._events[type] === listener && delete this._events[type];
				return this
			};
			EventEmitter.prototype.removeAllListeners = function (type) {
				type && this._events && this._events[type] && (this._events[type] = null);
				return this
			};
			EventEmitter.prototype.listeners = function (type) {
				this._events || (this._events = {});
				this._events[type] || (this._events[type] = []);
				isArray(this._events[type]) || (this._events[type] = [this._events[type]]);
				return this._events[type]
			}
		});
		require.define("/node_modules/scrubber/package.json", function (require, module) {
			module.exports = {
				main: "index.js"
			}
		});
		require.define("/node_modules/scrubber/index.js", function (require, module, exports, __dirname, __filename, process) {
			var Scrubber, Traverse, daisy, global, slowDaisy, __slice = [].slice;
			Traverse = require("traverse");
			global = "undefined" != typeof window && null !== window ? window : this;
			daisy = function (args) {
				return process.nextTick(args.next = function () {
					var fn;
					return (fn = args.shift()) ? !!fn(args) : void 0
				})
			};
			slowDaisy = function (args) {
				return console.log("it's a slow daisy", args)
			};
			module.exports = Scrubber = function () {
				function Scrubber() {
					var middleware;
					middleware = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
					this.stack = "function" == typeof middleware[0] ? middleware : middleware[0]
				}
				var seemsTooComplex;
				Scrubber.use = function () {
					var middleware;
					middleware = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
					return this.stack = null == this.stack ? middleware : this.stack.concat(middleware)
				};
				Scrubber.prototype.scrub = function (obj, callback) {
					var nodes, queue, scrubber, steps;
					scrubber = this;
					queue = [];
					steps = this.stack.map(function (fn) {
						switch (fn.length) {
						case 0:
						case 1:
							return function (cursor, next) {
								fn.call(this, cursor);
								return next()
							};
						case 2:
							return fn;
						default:
							throw new TypeError("Scrubber requires a callback with 1- or 2-arity. " + ("User provided a " + fn.length + "-arity callback"))
						}
					});
					nodes = [];
					this.out = new Traverse(obj).map(function () {
						var cursor;
						cursor = this;
						steps.forEach(function (step) {
							return queue.push(function () {
								return step.call(scrubber, cursor, function () {
									return queue.next()
								})
							})
						})
					});
					queue.push(function () {
						return callback.call(scrubber)
					});
					return daisy(queue)
				};
				seemsTooComplex = function () {
					var f, i, maxStackSize;
					maxStackSize = function () {
						try {
							i = 0;
							return (f = function () {
								i++;
								return f()
							})()
						} catch (e) {
							return i
						}
					}();
					return function (length, weight) {
						var guess;
						guess = length * weight;
						return guess > maxStackSize
					}
				}();
				["forEach", "indexOf", "join", "pop", "reverse", "shift", "sort", "splice", "unshift", "push"].forEach(function (method) {
					return Scrubber.prototype[method] = function () {
						var rest;
						rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
						return this.stack[method].apply(this.stack, rest)
					}
				});
				Scrubber.prototype.use = Scrubber.prototype.push;
				return Scrubber
			}.call(this)
		});
		require.define("stream", function (require, module) {
			function Stream() {
				events.EventEmitter.call(this)
			}
			var events = require("events"),
				util = require("util");
			util.inherits(Stream, events.EventEmitter);
			module.exports = Stream;
			Stream.Stream = Stream;
			Stream.prototype.pipe = function (dest, options) {
				function ondata(chunk) {
					dest.writable && !1 === dest.write(chunk) && source.pause && source.pause()
				}

				function ondrain() {
					source.readable && source.resume && source.resume()
				}

				function onend() {
					if (!didOnEnd) {
						didOnEnd = !0;
						dest._pipeCount--;
						cleanup();
						dest._pipeCount > 0 || dest.end()
					}
				}

				function onclose() {
					if (!didOnEnd) {
						didOnEnd = !0;
						dest._pipeCount--;
						cleanup();
						dest._pipeCount > 0 || dest.destroy()
					}
				}

				function onerror(er) {
					cleanup();
					if (0 === this.listeners("error").length) throw er
				}

				function cleanup() {
					source.removeListener("data", ondata);
					dest.removeListener("drain", ondrain);
					source.removeListener("end", onend);
					source.removeListener("close", onclose);
					source.removeListener("error", onerror);
					dest.removeListener("error", onerror);
					source.removeListener("end", cleanup);
					source.removeListener("close", cleanup);
					dest.removeListener("end", cleanup);
					dest.removeListener("close", cleanup)
				}
				var source = this;
				source.on("data", ondata);
				dest.on("drain", ondrain);
				if (!(dest._isStdio || options && options.end === !1)) {
					dest._pipeCount = dest._pipeCount || 0;
					dest._pipeCount++;
					source.on("end", onend);
					source.on("close", onclose)
				}
				var didOnEnd = !1;
				source.on("error", onerror);
				dest.on("error", onerror);
				source.on("end", cleanup);
				source.on("close", cleanup);
				dest.on("end", cleanup);
				dest.on("close", cleanup);
				dest.emit("pipe", source);
				return dest
			}
		});
		require.define("util", function (require, module, exports) {
			function isArray(ar) {
				return ar instanceof Array || Array.isArray(ar) || ar && ar !== Object.prototype && isArray(ar.__proto__)
			}

			function isRegExp(re) {
				return re instanceof RegExp || "object" == typeof re && "[object RegExp]" === Object.prototype.toString.call(re)
			}

			function isDate(d) {
				if (d instanceof Date) return !0;
				if ("object" != typeof d) return !1;
				var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype),
					proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
				return JSON.stringify(proto) === JSON.stringify(properties)
			}
			require("events");
			exports.print = function () {};
			exports.puts = function () {};
			exports.debug = function () {};
			exports.inspect = function (obj, showHidden, depth, colors) {
				function format(value, recurseTimes) {
					if (value && "function" == typeof value.inspect && value !== exports && (!value.constructor || value.constructor.prototype !== value)) return value.inspect(recurseTimes);
					switch (typeof value) {
					case "undefined":
						return stylize("undefined", "undefined");
					case "string":
						var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
						return stylize(simple, "string");
					case "number":
						return stylize("" + value, "number");
					case "boolean":
						return stylize("" + value, "boolean")
					}
					if (null === value) return stylize("null", "null");
					var visible_keys = Object_keys(value),
						keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;
					if ("function" == typeof value && 0 === keys.length) {
						if (isRegExp(value)) return stylize("" + value, "regexp");
						var name = value.name ? ": " + value.name : "";
						return stylize("[Function" + name + "]", "special")
					}
					if (isDate(value) && 0 === keys.length) return stylize(value.toUTCString(), "date");
					var base, type, braces;
					if (isArray(value)) {
						type = "Array";
						braces = ["[", "]"]
					} else {
						type = "Object";
						braces = ["{", "}"]
					} if ("function" == typeof value) {
						var n = value.name ? ": " + value.name : "";
						base = isRegExp(value) ? " " + value : " [Function" + n + "]"
					} else base = "";
					isDate(value) && (base = " " + value.toUTCString());
					if (0 === keys.length) return braces[0] + base + braces[1];
					if (0 > recurseTimes) return isRegExp(value) ? stylize("" + value, "regexp") : stylize("[Object]", "special");
					seen.push(value);
					var output = keys.map(function (key) {
						var name, str;
						value.__lookupGetter__ && (value.__lookupGetter__(key) ? str = value.__lookupSetter__(key) ? stylize("[Getter/Setter]", "special") : stylize("[Getter]", "special") : value.__lookupSetter__(key) && (str = stylize("[Setter]", "special")));
						visible_keys.indexOf(key) < 0 && (name = "[" + key + "]");
						if (!str)
							if (seen.indexOf(value[key]) < 0) {
								str = null === recurseTimes ? format(value[key]) : format(value[key], recurseTimes - 1);
								str.indexOf("\n") > -1 && (str = isArray(value) ? str.split("\n").map(function (line) {
									return "  " + line
								}).join("\n").substr(2) : "\n" + str.split("\n").map(function (line) {
									return "   " + line
								}).join("\n"))
							} else str = stylize("[Circular]", "special");
						if ("undefined" == typeof name) {
							if ("Array" === type && key.match(/^\d+$/)) return str;
							name = JSON.stringify("" + key);
							if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
								name = name.substr(1, name.length - 2);
								name = stylize(name, "name")
							} else {
								name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
								name = stylize(name, "string")
							}
						}
						return name + ": " + str
					});
					seen.pop();
					var numLinesEst = 0,
						length = output.reduce(function (prev, cur) {
							numLinesEst++;
							cur.indexOf("\n") >= 0 && numLinesEst++;
							return prev + cur.length + 1
						}, 0);
					output = length > 50 ? braces[0] + ("" === base ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1] : braces[0] + base + " " + output.join(", ") + " " + braces[1];
					return output
				}
				var seen = [],
					stylize = function (str, styleType) {
						var styles = {
								bold: [1, 22],
								italic: [3, 23],
								underline: [4, 24],
								inverse: [7, 27],
								white: [37, 39],
								grey: [90, 39],
								black: [30, 39],
								blue: [34, 39],
								cyan: [36, 39],
								green: [32, 39],
								magenta: [35, 39],
								red: [31, 39],
								yellow: [33, 39]
							},
							style = {
								special: "cyan",
								number: "blue",
								"boolean": "yellow",
								undefined: "grey",
								"null": "bold",
								string: "green",
								date: "magenta",
								regexp: "red"
							}[styleType];
						return style ? "[" + styles[style][0] + "m" + str + "[" + styles[style][1] + "m" : str
					};
				colors || (stylize = function (str) {
					return str
				});
				return format(obj, "undefined" == typeof depth ? 2 : depth)
			};
			exports.log = function () {};
			exports.pump = null;
			var Object_keys = Object.keys || function (obj) {
					var res = [];
					for (var key in obj) res.push(key);
					return res
				},
				Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
					var res = [];
					for (var key in obj) Object.hasOwnProperty.call(obj, key) && res.push(key);
					return res
				},
				Object_create = Object.create || function (prototype, properties) {
					var object;
					if (null === prototype) object = {
						__proto__: null
					};
					else {
						if ("object" != typeof prototype) throw new TypeError("typeof prototype[" + typeof prototype + "] != 'object'");
						var Type = function () {};
						Type.prototype = prototype;
						object = new Type;
						object.__proto__ = prototype
					}
					"undefined" != typeof properties && Object.defineProperties && Object.defineProperties(object, properties);
					return object
				};
			exports.inherits = function (ctor, superCtor) {
				ctor.super_ = superCtor;
				ctor.prototype = Object_create(superCtor.prototype, {
					constructor: {
						value: ctor,
						enumerable: !1,
						writable: !0,
						configurable: !0
					}
				})
			}
		});
		require.define("/node_modules/jsonify/package.json", function (require, module) {
			module.exports = {
				main: "index.js"
			}
		});
		require.define("/node_modules/jsonify/index.js", function (require, module, exports) {
			exports.parse = require("./lib/parse");
			exports.stringify = require("./lib/stringify")
		});
		require.define("/node_modules/jsonify/lib/parse.js", function (require, module) {
			var at, ch, text, value, escapee = {
					'"': '"',
					"\\": "\\",
					"/": "/",
					b: "\b",
					f: "\f",
					n: "\n",
					r: "\r",
					t: "	"
				},
				error = function (m) {
					throw {
						name: "SyntaxError",
						message: m,
						at: at,
						text: text
					}
				},
				next = function (c) {
					c && c !== ch && error("Expected '" + c + "' instead of '" + ch + "'");
					ch = text.charAt(at);
					at += 1;
					return ch
				},
				number = function () {
					var number, string = "";
					if ("-" === ch) {
						string = "-";
						next("-")
					}
					for (; ch >= "0" && "9" >= ch;) {
						string += ch;
						next()
					}
					if ("." === ch) {
						string += ".";
						for (; next() && ch >= "0" && "9" >= ch;) string += ch
					}
					if ("e" === ch || "E" === ch) {
						string += ch;
						next();
						if ("-" === ch || "+" === ch) {
							string += ch;
							next()
						}
						for (; ch >= "0" && "9" >= ch;) {
							string += ch;
							next()
						}
					}
					number = +string;
					if (isFinite(number)) return number;
					error("Bad number");
					return void 0
				},
				string = function () {
					var hex, i, uffff, string = "";
					if ('"' === ch)
						for (; next();) {
							if ('"' === ch) {
								next();
								return string
							}
							if ("\\" === ch) {
								next();
								if ("u" === ch) {
									uffff = 0;
									for (i = 0; 4 > i; i += 1) {
										hex = parseInt(next(), 16);
										if (!isFinite(hex)) break;
										uffff = 16 * uffff + hex
									}
									string += String.fromCharCode(uffff)
								} else {
									if ("string" != typeof escapee[ch]) break;
									string += escapee[ch]
								}
							} else string += ch
						}
					error("Bad string")
				},
				white = function () {
					for (; ch && " " >= ch;) next()
				},
				word = function () {
					switch (ch) {
					case "t":
						next("t");
						next("r");
						next("u");
						next("e");
						return !0;
					case "f":
						next("f");
						next("a");
						next("l");
						next("s");
						next("e");
						return !1;
					case "n":
						next("n");
						next("u");
						next("l");
						next("l");
						return null
					}
					error("Unexpected '" + ch + "'")
				},
				array = function () {
					var array = [];
					if ("[" === ch) {
						next("[");
						white();
						if ("]" === ch) {
							next("]");
							return array
						}
						for (; ch;) {
							array.push(value());
							white();
							if ("]" === ch) {
								next("]");
								return array
							}
							next(",");
							white()
						}
					}
					error("Bad array")
				},
				object = function () {
					var key, object = {};
					if ("{" === ch) {
						next("{");
						white();
						if ("}" === ch) {
							next("}");
							return object
						}
						for (; ch;) {
							key = string();
							white();
							next(":");
							Object.hasOwnProperty.call(object, key) && error('Duplicate key "' + key + '"');
							object[key] = value();
							white();
							if ("}" === ch) {
								next("}");
								return object
							}
							next(",");
							white()
						}
					}
					error("Bad object")
				};
			value = function () {
				white();
				switch (ch) {
				case "{":
					return object();
				case "[":
					return array();
				case '"':
					return string();
				case "-":
					return number();
				default:
					return ch >= "0" && "9" >= ch ? number() : word()
				}
			};
			module.exports = function (source, reviver) {
				var result;
				text = source;
				at = 0;
				ch = " ";
				result = value();
				white();
				ch && error("Syntax error");
				return "function" == typeof reviver ? function walk(holder, key) {
					var k, v, value = holder[key];
					if (value && "object" == typeof value)
						for (k in value)
							if (Object.prototype.hasOwnProperty.call(value, k)) {
								v = walk(value, k);
								void 0 !== v ? value[k] = v : delete value[k]
							}
					return reviver.call(holder, key, value)
				}({
					"": result
				}, "") : result
			}
		});
		require.define("/node_modules/jsonify/lib/stringify.js", function (require, module) {
			function quote(string) {
				escapable.lastIndex = 0;
				return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
					var c = meta[a];
					return "string" == typeof c ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
				}) + '"' : '"' + string + '"'
			}

			function str(key, holder) {
				var i, k, v, length, partial, mind = gap,
					value = holder[key];
				value && "object" == typeof value && "function" == typeof value.toJSON && (value = value.toJSON(key));
				"function" == typeof rep && (value = rep.call(holder, key, value));
				switch (typeof value) {
				case "string":
					return quote(value);
				case "number":
					return isFinite(value) ? String(value) : "null";
				case "boolean":
				case "null":
					return String(value);
				case "object":
					if (!value) return "null";
					gap += indent;
					partial = [];
					if ("[object Array]" === Object.prototype.toString.apply(value)) {
						length = value.length;
						for (i = 0; length > i; i += 1) partial[i] = str(i, value) || "null";
						v = 0 === partial.length ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
						gap = mind;
						return v
					}
					if (rep && "object" == typeof rep) {
						length = rep.length;
						for (i = 0; length > i; i += 1) {
							k = rep[i];
							if ("string" == typeof k) {
								v = str(k, value);
								v && partial.push(quote(k) + (gap ? ": " : ":") + v)
							}
						}
					} else
						for (k in value)
							if (Object.prototype.hasOwnProperty.call(value, k)) {
								v = str(k, value);
								v && partial.push(quote(k) + (gap ? ": " : ":") + v)
							}
					v = 0 === partial.length ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
					gap = mind;
					return v
				}
			}
			var gap, indent, rep, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
				meta = {
					"\b": "\\b",
					"	": "\\t",
					"\n": "\\n",
					"\f": "\\f",
					"\r": "\\r",
					'"': '\\"',
					"\\": "\\\\"
				};
			module.exports = function (value, replacer, space) {
				var i;
				gap = "";
				indent = "";
				if ("number" == typeof space)
					for (i = 0; space > i; i += 1) indent += " ";
				else "string" == typeof space && (indent = space);
				rep = replacer;
				if (replacer && "function" != typeof replacer && ("object" != typeof replacer || "number" != typeof replacer.length)) throw new Error("JSON.stringify");
				return str("", {
					"": value
				})
			}
		});
		require.define("/node_modules_koding/bongo-client/src/scrubber.coffee", function (require, module) {
			(function () {
				var BongoScrubber, Scrubber, __hasProp = {}.hasOwnProperty,
					__extends = function (child, parent) {
						function ctor() {
							this.constructor = child
						}
						for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
						ctor.prototype = parent.prototype;
						child.prototype = new ctor;
						child.__super__ = parent.prototype;
						return child
					},
					__slice = [].slice;
				Scrubber = require("koding-dnode-protocol").Scrubber;
				module.exports = BongoScrubber = function (_super) {
					function BongoScrubber() {
						BongoScrubber.__super__.constructor.apply(this, arguments);
						this.unshift(compensateForLatency)
					}
					var compensateForLatency, createFailHandler, error, noop;
					__extends(BongoScrubber, _super);
					noop = function () {};
					error = function (message) {
						throw new Error(message)
					};
					createFailHandler = function (fn) {
						return function () {
							var err, rest;
							rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
							err = rest[0];
							return null != err ? fn.apply(null, rest) : void 0
						}
					};
					compensateForLatency = function (cursor) {
						var hasFailMethod, hasFinalizeMethod, node;
						node = cursor.node;
						if (node && "object" == typeof node && "compensate" in node) {
							node.compensate();
							hasFailMethod = "fail" in node;
							hasFinalizeMethod = "finalize" in node;
							hasFinalizeMethod && hasFailMethod && error("Provide a handler only for finalize, or fail, not both");
							return cursor.update(hasFailMethod ? createFailHandler(node.fail) : hasFinalizeMethod ? node.finalize : noop)
						}
					};
					return BongoScrubber
				}(Scrubber)
			}).call(this)
		});
		require.define("/node_modules_koding/bongo-client/src/model.coffee", function (require, module) {
			(function () {
				"use strict";
				var EventEmitter, Model, __hasProp = {}.hasOwnProperty,
					__extends = function (child, parent) {
						function ctor() {
							this.constructor = child
						}
						for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
						ctor.prototype = parent.prototype;
						child.prototype = new ctor;
						child.__super__ = parent.prototype;
						return child
					};
				EventEmitter = require("microemitter").EventEmitter;
				module.exports = Model = function (_super) {
					function Model() {
						return Model.__super__.constructor.apply(this, arguments)
					}
					var JsPath, MongoOp, Traverse, createId, extend;
					__extends(Model, _super);
					MongoOp = require("mongoop");
					JsPath = require("jspath");
					createId = Model.createId = require("hat");
					Traverse = require("traverse");
					extend = require("./util").extend;
					Model.isOpaque = function () {
						return !1
					};
					Model.streamModels = function (selector, options, callback) {
						var ids;
						if (!("each" in this)) throw new Error("streamModels depends on Model#each, but cursor was not found!\n(Hint: it may not be whitelisted)");
						ids = [];
						return this.each(selector, options, function (err, model) {
							if (err) return callback(err);
							if (null != model) {
								ids.push("function" == typeof model.getId ? model.getId() : void 0);
								return callback(err, [model])
							}
							return callback(null, null, ids)
						})
					};
					Model.prototype.mixin = Model.mixin = function (source) {
						var key, val, _results;
						_results = [];
						for (key in source) {
							val = source[key];
							"constructor" !== key && _results.push(this[key] = val)
						}
						return _results
					};
					Model.prototype.watch = function (field, watcher) {
						var _base;
						(_base = this.watchers)[field] || (_base[field] = []);
						return this.watchers[field].push(watcher)
					};
					Model.prototype.unwatch = function (field, watcher) {
						var index;
						if (!watcher) return delete this.watchers[field];
						index = this.watchers.indexOf(watcher);
						return ~index ? this.watchers.splice(index, 1) : void 0
					};
					Model.prototype.init = function (data) {
						var model, _this = this;
						model = this;
						model.watchers = {};
						model.bongo_ || (model.bongo_ = {});
						null != data && model.set(data);
						"instanceId" in model.bongo_ || (model.bongo_.instanceId = createId());
						this.emit("init");
						return this.on("updateInstance", function (data) {
							null != ("undefined" != typeof Encoder && null !== Encoder ? Encoder.XSSEncode : void 0) && (data = new Traverse(data).map(function (node) {
								return "string" == typeof node ? Encoder.XSSEncode(node) : node
							}));
							return _this.update_(data)
						})
					};
					Model.prototype.set = function (data) {
						var model;
						null == data && (data = {});
						model = this;
						delete data.data;
						extend(model, data);
						return model
					};
					Model.prototype.getFlagValue = function (flagName) {
						var _ref;
						return null != (_ref = this.flags_) ? _ref[flagName] : void 0
					};
					Model.prototype.watchFlagValue = function (flagName, callback) {
						return this.watch("flags_." + flagName, callback)
					};
					Model.prototype.unwatchFlagValue = function (flagName) {
						return this.unwatch("flags_." + flagName)
					};
					Model.prototype.decoded = "undefined" != typeof Encoder && null !== Encoder ? function (path) {
						return Encoder.htmlDecode(this.getAt(path))
					} : Model.prototype.getAt;
					Model.prototype.getAt = function (path) {
						return JsPath.getAt(this, path)
					};
					Model.prototype.setAt = function (path, value) {
						return JsPath.setAt(this, path, value)
					};
					Model.prototype.getId = function () {
						return this._id
					};
					Model.prototype.getSubscribable = function () {
						var subscribable;
						subscribable = this.bongo_.subscribable;
						return null != subscribable ? subscribable : !0
					};
					Model.prototype.equals = function (model) {
						return this.getId && (null != model ? model.getId : void 0) ? this.getId() === model.getId() : this === model
					};
					Model.prototype.valueOf = function () {
						var _ref;
						return null != (_ref = "function" == typeof this.getValue ? this.getValue() : void 0) ? _ref : this
					};
					Model.prototype.save = function (callback) {
						var model;
						model = this;
						return model.save_(function (err, docs) {
							if (err) return callback(err);
							extend(model, docs[0]);
							bongo.addReferences(model);
							return callback(null, docs)
						})
					};
					Model.prototype.update_ = function (data) {
						var fields, _this = this;
						fields = new MongoOp(data).applyTo(this);
						Object.keys(fields).forEach(function (field) {
							var _ref;
							return null != (_ref = _this.watchers[field]) ? _ref.forEach(function (watcher) {
								return watcher.call(_this, fields[field])
							}) : void 0
						});
						return this.emit("update", Object.keys(fields.result))
					};
					Model.prototype.addListener = Model.prototype.on;
					Model.prototype.removeListener = Model.prototype.off;
					return Model
				}(EventEmitter)
			}).call(this)
		});
		require.define("/node_modules/mongoop/package.json", function (require, module) {
			module.exports = {
				main: "index.js"
			}
		});
		require.define("/node_modules/mongoop/index.js", function (require, module) {
			(function () {
				var MongoOp, __slice = [].slice;
				MongoOp = function () {
					function MongoOp(operation) {
						if (!(this instanceof MongoOp)) return new MongoOp(operation);
						this.operation = operation;
						return void 0
					}
					var deleteAt, getAt, isEqual, keys, popAt, pushAt, setAt, _ref;
					_ref = require("jspath"), setAt = _ref.setAt, getAt = _ref.getAt, deleteAt = _ref.deleteAt, pushAt = _ref.pushAt, popAt = _ref.popAt;
					keys = Object.keys;
					isEqual = require("deep-equal");
					MongoOp.prototype.applyTo = function (target) {
						this.result = {};
						keys(this.operation).forEach(function (_this) {
							return function (operator) {
								if ("function" != typeof _this[operator]) throw new Error("Unrecognized operator: " + operator);
								return _this[operator](target, _this.operation[operator])
							}
						}(this));
						return this
					};
					MongoOp.prototype.map = function (fn) {
						var op;
						op = this.operation;
						this.operation = {};
						keys(op).forEach(function (_this) {
							return function (operator) {
								return _this.operation[operator] = fn(operator, op[operator])
							}
						}(this));
						return this
					};
					MongoOp.prototype.forEachField = function (fields, fn) {
						return keys(fields).map(function (_this) {
							return function (path) {
								var val;
								val = fields[path];
								return _this.result[path] = fn(path, val)
							}
						}(this))
					};
					MongoOp.prototype.$addToSet = function () {
						var $addToSet;
						$addToSet = function (collection, val) {
							var item, matchFound, _i, _len;
							matchFound = !1;
							for (_i = 0, _len = collection.length; _len > _i; _i++) {
								item = collection[_i];
								if (isEqual(item, val)) {
									matchFound = !0;
									break
								}
							}
							return matchFound ? void 0 : collection.push(val)
						};
						return function (target, fields) {
							return this.forEachField(fields, function () {
								return function (path, val) {
									var child, collection, _i, _len, _ref1, _results;
									collection = getAt(target, path);
									if (null == collection) {
										collection = [];
										setAt(target, path, collection)
									}
									if (null != val.$each) {
										_ref1 = val.$each;
										_results = [];
										for (_i = 0, _len = _ref1.length; _len > _i; _i++) {
											child = _ref1[_i];
											_results.push($addToSet(collection, child))
										}
										return _results
									}
									return $addToSet(collection, val)
								}
							}(this))
						}
					}();
					MongoOp.prototype.$push = function (target, fields) {
						return this.forEachField(fields, function (path, val) {
							return pushAt(target, path, val)
						})
					};
					MongoOp.prototype.$pushAll = function (target, fields) {
						return this.forEachField(fields, function (path, vals) {
							return pushAt.apply(null, [target, path].concat(__slice.call(vals)))
						})
					};
					MongoOp.prototype.$pull = function () {
						throw new Error("This version of MongoOp does not implement $pull...\nLook for that in a future version.  You can use $pullAll instead.")
					};
					MongoOp.prototype.$pullAll = function (target, fields) {
						return this.forEachField(fields, function (path, val) {
							var collection, i, index, _results;
							collection = getAt(target, path);
							index = 0;
							_results = [];
							for (; collection && index < collection.length;) {
								i = index++;
								_results.push(isEqual(collection[i], val) ? collection.splice(i, 1) : void 0)
							}
							return _results
						})
					};
					MongoOp.prototype.$pop = function (target, fields) {
						return this.forEachField(fields, function (path) {
							return popAt(target, path)
						})
					};
					MongoOp.prototype.$set = function (target, fields) {
						return this.forEachField(fields, function (path, val) {
							setAt(target, path, val);
							return val
						})
					};
					MongoOp.prototype.$unset = function (target, fields) {
						return this.forEachField(fields, function (path) {
							return deleteAt(target, path)
						})
					};
					MongoOp.prototype.$rename = function (target, fields) {
						return this.forEachField(fields, function (oldPath, newPath) {
							var val;
							val = getAt(target, oldPath);
							deleteAt(target, oldPath);
							return setAt(target, newPath, val)
						})
					};
					MongoOp.prototype.$inc = function () {
						var $inc;
						$inc = function (val, amt) {
							return val += amt
						};
						return function (target, fields) {
							return this.forEachField(fields, function (path, val) {
								return setAt(target, path, $inc(getAt(target, path), val))
							})
						}
					}();
					return MongoOp
				}();
				null != ("undefined" != typeof module && null !== module ? module.exports : void 0) ? module.exports = MongoOp : "undefined" != typeof window && null !== window && (window.MongoOp = MongoOp)
			}).call(this)
		});
		require.define("/node_modules/deep-equal/package.json", function (require, module) {
			module.exports = {
				main: "index.js"
			}
		});
		require.define("/node_modules/deep-equal/index.js", function (require, module) {
			function isUndefinedOrNull(value) {
				return null === value || void 0 === value
			}

			function objEquiv(a, b, opts) {
				if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return !1;
				if (a.prototype !== b.prototype) return !1;
				if (isArguments(a)) {
					if (!isArguments(b)) return !1;
					a = pSlice.call(a);
					b = pSlice.call(b);
					return deepEqual(a, b, opts)
				}
				try {
					var key, i, ka = objectKeys(a),
						kb = objectKeys(b)
				} catch (e) {
					return !1
				}
				if (ka.length != kb.length) return !1;
				ka.sort();
				kb.sort();
				for (i = ka.length - 1; i >= 0; i--)
					if (ka[i] != kb[i]) return !1;
				for (i = ka.length - 1; i >= 0; i--) {
					key = ka[i];
					if (!deepEqual(a[key], b[key], opts)) return !1
				}
				return !0
			}
			var pSlice = Array.prototype.slice,
				objectKeys = require("./lib/keys.js"),
				isArguments = require("./lib/is_arguments.js"),
				deepEqual = module.exports = function (actual, expected, opts) {
					opts || (opts = {});
					return actual === expected ? !0 : actual instanceof Date && expected instanceof Date ? actual.getTime() === expected.getTime() : "object" != typeof actual && "object" != typeof expected ? opts.strict ? actual === expected : actual == expected : objEquiv(actual, expected, opts)
				}
		});
		require.define("/node_modules/deep-equal/lib/keys.js", function (require, module, exports) {
			function shim(obj) {
				var keys = [];
				for (var key in obj) keys.push(key);
				return keys
			}
			exports = module.exports = "function" == typeof Object.keys ? Object.keys : shim;
			exports.shim = shim
		});
		require.define("/node_modules/deep-equal/lib/is_arguments.js", function (require, module, exports) {
			function supported(object) {
				return "[object Arguments]" == Object.prototype.toString.call(object)
			}

			function unsupported(object) {
				return object && "object" == typeof object && "number" == typeof object.length && Object.prototype.hasOwnProperty.call(object, "callee") && !Object.prototype.propertyIsEnumerable.call(object, "callee") || !1
			}
			var supportsArgumentsClass = "[object Arguments]" == function () {
				return Object.prototype.toString.call(arguments)
			}();
			exports = module.exports = supportsArgumentsClass ? supported : unsupported;
			exports.supported = supported;
			exports.unsupported = unsupported
		});
		require.define("/node_modules_koding/bongo-client/src/util.coffee", function (require, module) {
			(function () {
				"use strict";
				var __slice = [].slice;
				module.exports = {
					extend: function () {
						var key, obj, rest, source, val, _i, _len;
						obj = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
						for (_i = 0, _len = rest.length; _len > _i; _i++) {
							source = rest[_i];
							for (key in source) {
								val = source[key];
								obj[key] = val
							}
						}
						return obj
					},
					asynchronizeOwnMethods: function (ofObject) {
						var result;
						result = {};
						Object.keys(ofObject).forEach(function (key) {
							var fn;
							return "function" == typeof (fn = ofObject[key]) ? result[key] = function () {
								var callback, rest, _i;
								rest = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
								return callback(fn.apply(null, rest))
							} : void 0
						});
						return result
					}
				}
			}).call(this)
		});
		require.define("/node_modules_koding/bongo-client/src/listenertree.coffee", function (require, module) {
			(function () {
				"use strict";
				var ListenerTree, __slice = [].slice;
				module.exports = ListenerTree = function () {
					function ListenerTree() {
						this.tree = Object.create(null)
					}
					var assureAt, getAt, pushAt, _ref;
					_ref = require("jspath"), assureAt = _ref.assureAt, pushAt = _ref.pushAt, getAt = _ref.getAt;
					ListenerTree.prototype.on = function (routingKey, listener) {
						assureAt(this.tree, routingKey, []);
						pushAt(this.tree, routingKey, listener);
						return this
					};
					ListenerTree.prototype.off = function () {
						console.log("ListenerTree#off is still unimplemented.");
						return this
					};
					ListenerTree.prototype.emit = function () {
						var listener, listeners, params, rest, routingKey, _i, _len;
						routingKey = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
						listeners = getAt(this.tree, routingKey);
						params = rest.map(function (param) {
							try {
								return JSON.parse(param)
							} catch (e) {
								return param
							}
						});
						if (null != listeners ? listeners.length : void 0)
							for (_i = 0, _len = listeners.length; _len > _i; _i++) {
								listener = listeners[_i];
								listener.apply(null, params)
							}
						return this
					};
					return ListenerTree
				}()
			}).call(this)
		});
		require.define("/node_modules_koding/bongo-client/src/eventbus.coffee", function (require, module) {
			(function () {
				"use strict";
				var EventBus;
				module.exports = EventBus = function () {
					function EventBus(mq) {
						this.mq = mq;
						this.tree = new ListenerTree;
						this.channels = {};
						this.counts = {}
					}
					var ListenerTree, getGenericInstanceRoutingKey, getGenericStaticRoutingKey, getInstanceRoutingKey, getStaticRoutingKey;
					ListenerTree = require("./listenertree");
					EventBus.prototype.bound = require("koding-bound");
					EventBus.prototype.dispatch = function (routingKey, payload) {
						return this.tree.emit(routingKey, payload)
					};
					EventBus.prototype.addListener = function (getGenericRoutingKey, getRoutingKey, name, event, listener) {
						var channel, genericRoutingKey;
						if (null == this.channels[name]) {
							this.counts[name] = 0;
							genericRoutingKey = getGenericRoutingKey(name);
							channel = this.channels[name] = this.mq.subscribe(genericRoutingKey, {
								isReadOnly: !0,
								mustAuthenticate: !1
							})
						} else channel = this.channels[name];
						channel.isListeningTo(event) || channel.on(event, this.dispatch.bind(this, getRoutingKey(name, event)));
						this.counts[name]++;
						return this.tree.on(getRoutingKey(name, event), listener)
					};
					EventBus.prototype.removeListener = function (getRoutingKey, name, event, listener) {
						var channel;
						if (0 === --this.counts[name]) {
							channel = this.channels[name];
							channel.close();
							delete this.channels[name]
						}
						return this.tree.off(getRoutingKey(name, event), listener)
					};
					getStaticRoutingKey = function (constructorName, event) {
						return "constructor." + constructorName + ".event." + event
					};
					getGenericStaticRoutingKey = function (constructorName) {
						return "constructor." + constructorName + ".event"
					};
					EventBus.prototype.staticOn = function (konstructor, event, listener) {
						return this.addListener(getGenericStaticRoutingKey, getStaticRoutingKey, konstructor.name, event, listener)
					};
					EventBus.prototype.staticOff = function (konstructor, event, listener) {
						return this.removeListener(getStaticRoutingKey, konstructor.name, event, listener)
					};
					getInstanceRoutingKey = function (oid, event) {
						return "oid." + oid + ".event." + event
					};
					getGenericInstanceRoutingKey = function (oid) {
						return "oid." + oid + ".event"
					};
					EventBus.prototype.on = function (inst, event, listener) {
						return inst.getSubscribable() ? this.addListener(getGenericInstanceRoutingKey, getInstanceRoutingKey, inst.getId(), event, listener) : void 0
					};
					EventBus.prototype.off = function (inst, event, listener) {
						return this.removeListener(getInstanceRoutingKey, inst.getId(), event, listener)
					};
					return EventBus
				}()
			}).call(this)
		});
		require.define("/node_modules/koding-bound/package.json", function (require, module) {
			module.exports = {
				main: "index.js"
			}
		});
		require.define("/node_modules/koding-bound/index.js", function (require, module) {
			module.exports = require("./lib/koding-bound")
		});
		require.define("/node_modules/koding-bound/lib/koding-bound/index.js", function (require, module) {
			module.exports = function (method) {
				var boundMethod;
				if (null == this[method]) throw new Error("@bound: unknown method! " + method);
				boundMethod = "__bound__" + method;
				boundMethod in this || Object.defineProperty(this, boundMethod, {
					value: this[method].bind(this)
				});
				return this[boundMethod]
			}
		});
		require.define("/node_modules_koding/bongo-client/src/opaquetype.coffee", function (require, module) {
			(function () {
				var OpaqueType, __hasProp = {}.hasOwnProperty,
					__extends = function (child, parent) {
						function ctor() {
							this.constructor = child
						}
						for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
						ctor.prototype = parent.prototype;
						child.prototype = new ctor;
						child.__super__ = parent.prototype;
						return child
					};
				module.exports = OpaqueType = function () {
					function OpaqueType(type) {
						var konstructor;
						konstructor = Function("return function " + type + "() {}")();
						__extends(konstructor, OpaqueType);
						return konstructor
					}
					OpaqueType.isOpaque = function () {
						return !0
					};
					return OpaqueType
				}()
			}).call(this)
		});
		require.define("/node_modules_koding/bongo-client/src/signature.coffee", function (require, module) {
			(function () {
				var Rest, Signature, __slice = [].slice;
				Rest = require("./rest");
				module.exports = Signature = function () {
					function Signature(signatureStr) {
						var i, rest, type, _i, _len, _ref;
						if (!(this instanceof Signature)) return new Signature(signatureStr);
						this.paramTypes = signatureStr.split(",").map(interpretType);
						_ref = this.paramTypes;
						for (i = _i = 0, _len = _ref.length; _len > _i; i = ++_i) {
							type = _ref[i];
							if (type.isRest) {
								if (rest) throw new Error("Multiple rest parameters are not allowed.");
								this.restParamType = type;
								this.restParamIndex = i;
								this.paramTypesBefore = this.paramTypes.slice(0, i);
								this.paramTypesAfter = this.paramTypes.slice(i + 1, this.paramTypes.length + 1 || 9e9);
								rest = !0
							}
						}
					}
					var arrayRe, interpretType, restRe;
					arrayRe = /^\[(.)\]$/;
					restRe = /^R\((.)\)$/;
					Signature.prototype.hasCallback = function () {
						return this.paramTypes[this.paramTypes.length - 1] === Function
					};
					Signature.prototype.spread = function () {
						var rest;
						rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
						return this.test(rest)
					};
					Signature.prototype.test = function (params) {
						return this.testLength(params) ? null != this.restParamType ? this.testWithRest(params) : this.testEach(params) : !1
					};
					Signature.prototype.testEach = function (params, types) {
						var i, param, _i, _len, _ref;
						null == types && (types = this.paramTypes);
						for (i = _i = 0, _len = params.length; _len > _i; i = ++_i) {
							param = params[i];
							if (!this.testType(param, null != (_ref = types[i]) ? _ref : types.tag)) return !1
						}
						return !0
					};
					Signature.prototype.testWithRest = function (params) {
						var after, i, paramsAfter, paramsBefore, restParam;
						i = this.restParamIndex;
						after = params.length - this.paramTypesAfter.length;
						paramsBefore = params.slice(0, i);
						restParam = params.slice(i, after);
						paramsAfter = params.slice(after, params.length);
						return this.testEach(paramsBefore, this.paramTypesBefore) && this.testEach(restParam, this.restParamType) && this.testEach(paramsAfter, this.paramTypesAfter) ? !0 : !1
					};
					Signature.prototype.testLength = function (params) {
						return null != this.restParamType ? this.paramTypesBefore.length + this.paramTypesAfter.length <= params.length : this.paramTypes.length === params.length
					};
					Signature.prototype.testType = function (param, type) {
						var p, _i, _len;
						switch (!1) {
						case !(null === param || void 0 === param):
							return !0;
						case type !== Boolean:
							return "boolean" == typeof param;
						case type !== Number:
							return "number" == typeof param;
						case type !== String:
							return "string" == typeof param;
						case type !== Function:
							return "function" == typeof param;
						case type !== Object:
							return Object(param) === param;
						case !Array.isArray(type):
							if (!Array.isArray(param)) return !1;
							for (_i = 0, _len = param.length; _len > _i; _i++) {
								p = param[_i];
								if (!this.testType(p, type[0])) return !1
							}
							return !0;
						default:
							return !1
						}
					};
					interpretType = function (typeStr) {
						var arrType, m, restType, _;
						switch (!1) {
						case "O" !== typeStr:
							return Object;
						case "F" !== typeStr:
							return Function;
						case "B" !== typeStr:
							return Boolean;
						case "N" !== typeStr:
							return Number;
						case "S" !== typeStr:
							return String;
						case !(m = typeStr.match(arrayRe)):
							_ = m[0], arrType = m[1];
							return [interpretType(arrType)];
						case !(m = typeStr.match(restRe)):
							_ = m[0], restType = m[1];
							return new Rest(interpretType(restType));
						default:
							throw new Error("Couldn't interpret type: type")
						}
					};
					return Signature
				}()
			}).call(this)
		});
		require.define("/node_modules_koding/bongo-client/src/rest.coffee", function (require, module) {
			(function () {
				var Rest;
				module.exports = Rest = function () {
					function Rest(paramType) {
						this.paramType = paramType
					}
					Rest.prototype.isRest = !0;
					return Rest
				}()
			}).call(this)
		});
		require.define("/node_modules_koding/bongo-client/src/promibackify.coffee", function (require, module) {
			(function () {
				var __slice = [].slice;
				module.exports = function (fn) {
					var hasMandatoryCallback;
					hasMandatoryCallback = fn.signatures[0].hasCallback();
					return function () {
						var args, callback, _this = this;
						args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
						"function" == typeof args[args.length - 1] && (callback = args.pop());
						return new Promise(function (resolve, reject) {
							if (hasMandatoryCallback) return fn.call.apply(fn, [_this].concat(__slice.call(args), [
								function () {
									var err, rest, result;
									err = arguments[0], result = arguments[1], rest = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
									switch (!1) {
									case null == err:
										return reject(err);
									case !rest.length:
										warn(new Error("Trailing callback parameters detected!"));
										return resolve(result);
									default:
										return resolve(result)
									}
								}
							]));
							fn.apply(_this, args);
							return resolve()
						}).nodeify(callback)
					}
				}
			}).call(this)
		});
		require.define("/node_modules_koding/bongo-client/src/eventemitter/broker.coffee", function (require, module) {
			(function () {
				"use strict";
				module.exports = function () {
					var defineProperty, getPusherEvent;
					getPusherEvent = function (event) {
						return Array.isArray(event) ? event = event.join(":") : event
					};
					defineProperty = Object.defineProperty;
					return {
						destroy: function () {
							return null != this.channel ? this.mq.unsubscribe(this.channel) : void 0
						},
						removeListener: function (event, listener) {
							this.emit("listenerRemoved", event, listener);
							return this.constructor.__super__.prototype.removeListener.call(this, event, listener)
						}
					}
				}()
			}).call(this)
		});
		require.define("/node_modules/sinkrow/package.json", function (require, module) {
			module.exports = {
				main: "lib/sinkrow/index.js"
			}
		});
		require.define("/node_modules/sinkrow/lib/sinkrow/index.js", function (require, module, exports, __dirname, __filename, process) {
			this.sequence = require("./sequence");
			this.race = require("./race");
			this.daisy = function (args) {
				process.nextTick(args.next = function () {
					var fn;
					return (fn = args.shift()) ? !!fn(args) || !0 : !1
				});
				return args.next
			};
			this.dash = function (args, cb) {
				var arg, count, length, _i, _len, _ref;
				"function" == typeof args && (_ref = [args, cb], cb = _ref[0], args = _ref[1]);
				length = args.length;
				if (0 === length) process.nextTick(cb);
				else {
					count = 0;
					args.fin = function () {
						return ++count === length ? !!cb() || !0 : !1
					};
					for (_i = 0, _len = args.length; _len > _i; _i++) {
						arg = args[_i];
						process.nextTick(arg)
					}
				}
				return args.fin
			}
		});
		require.define("/node_modules/sinkrow/lib/sinkrow/sequence.js", function (require, module, exports, __dirname, __filename, process) {
			var Sequence, slice;
			Sequence = function () {
				function Sequence(fn, cb) {
					this.fn = fn;
					this.cb = cb;
					this.times = 0;
					this.args = []
				}
				Sequence.prototype.next = function (args) {
					var nextArgs, nextFn;
					nextFn = (nextArgs = this.args.shift()) ? this.next.bind(this, nextArgs) : this.cb;
					return this.times-- ? this.fn.apply(this, args.concat(nextFn)) : void 0
				};
				Sequence.prototype.add = function (args) {
					return this.times++ ? this.args.push(args) : process.nextTick(this.next.bind(this, args))
				};
				return Sequence
			}();
			slice = [].slice;
			module.exports = function (fn, cb) {
				var sequence;
				sequence = new Sequence(fn, cb);
				return function () {
					return sequence.add(slice.call(arguments))
				}
			}
		});
		require.define("/node_modules/sinkrow/lib/sinkrow/race.js", function (require, module) {
			var Race, __bind = function (fn, me) {
					return function () {
						return fn.apply(me, arguments)
					}
				},
				__slice = [].slice;
			Race = function () {
				function Race(fn, cb) {
					this.fn = fn;
					this.cb = cb;
					this.fin = __bind(this.fin, this);
					this.times = 0;
					this.finTimes = 0
				}
				Race.prototype.fin = function () {
					return this.times === ++this.finTimes && "function" == typeof this.cb ? this.cb.apply(this, arguments) : void 0
				};
				Race.prototype.add = function (args) {
					var i;
					i = this.times++;
					return this.fn.apply(this, [i].concat(args.concat(this.fin)))
				};
				return Race
			}();
			module.exports = function (fn, cb) {
				var race;
				race = new Race(fn, cb);
				return function () {
					var args;
					args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
					return race.add(args)
				}
			}
		});
		require.define("/node_modules_koding/bongo-client/src/cacheable.coffee", function (require, module) {
			(function () {
				"use strict";
				var ModelLoader, dash, getModelLoader, handleBatch, handleByName, handleSingle;
				ModelLoader = require("./modelloader");
				dash = require("sinkrow").dash;
				module.exports = function () {
					switch (arguments.length) {
					case 2:
						return handleBatch.apply(this, arguments);
					case 3:
						return handleSingle.apply(this, arguments);
					default:
						throw new Error("Bongo#cacheable expects either 2 or 3 arguments.")
					}
				};
				getModelLoader = function () {
					var loading_;
					loading_ = {};
					return function (constructor, id) {
						var loader, _base, _name;
						loading_[_name = constructor.name] || (loading_[_name] = {});
						return loader = (_base = loading_[constructor.name])[id] || (_base[id] = new ModelLoader(constructor, id))
					}
				}();
				handleByName = function (strName, callback) {
					return "function" == typeof this.fetchName ? this.fetchName(strName, callback) : callback(new Error("Client must provide an implementation of fetchName!"))
				};
				handleSingle = function (constructorName, _id, callback) {
					var constructor, model;
					constructor = "string" == typeof constructorName ? this.api[constructorName] : "function" == typeof constructorName ? constructorName : void 0;
					if (constructor) {
						constructor.cache || (constructor.cache = {});
						(model = constructor.cache[_id]) ? callback(null, model): getModelLoader(constructor, _id).load(function (err, model) {
							constructor.cache[_id] = model;
							return callback(err, model)
						})
					} else callback(new Error("Unknown type " + constructorName))
				};
				handleBatch = function (batch, callback) {
					var models, queue, _this = this;
					if ("string" == typeof batch) return handleByName.call(this, batch, callback);
					models = [];
					queue = batch.map(function (single, i) {
						return function () {
							var constructorName, id, name, type;
							name = single.name, type = single.type, constructorName = single.constructorName, id = single.id;
							return handleSingle.call(_this, type || name || constructorName, id, function (err, model) {
								if (err) return callback(err);
								models[i] = model;
								return queue.fin()
							})
						}
					});
					dash(queue, function () {
						return callback(null, models)
					})
				}
			}).call(this)
		});
		require.define("/node_modules_koding/bongo-client/src/modelloader.coffee", function (require, module) {
			(function () {
				"use strict";
				var EventEmitter, ModelLoader, __hasProp = {}.hasOwnProperty,
					__extends = function (child, parent) {
						function ctor() {
							this.constructor = child
						}
						for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
						ctor.prototype = parent.prototype;
						child.prototype = new ctor;
						child.__super__ = parent.prototype;
						return child
					};
				EventEmitter = require("microemitter").EventEmitter;
				module.exports = ModelLoader = function (_super) {
					function ModelLoader(konstructor, _id) {
						this._id = _id;
						this.konstructor = konstructor
					}
					var load_;
					__extends(ModelLoader, _super);
					load_ = function () {
						var _this = this;
						return this.konstructor.one({
							_id: this._id
						}, function (err, model) {
							return _this.emit("load", err, model)
						})
					};
					ModelLoader.prototype.load = function (listener) {
						this.once("load", listener);
						if (!this.isLoading) {
							this.isLoading = !0;
							return load_.call(this)
						}
					};
					return ModelLoader
				}(EventEmitter)
			}).call(this)
		});
		require.define("/node_modules_koding/bongo-client/bongo.js", function (require, module, exports, __dirname, __filename, process) {
			"use strict";
			var Bongo, EventEmitter, isBrowser, __hasProp = {}.hasOwnProperty,
				__extends = function (child, parent) {
					function ctor() {
						this.constructor = child
					}
					for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				},
				__slice = [].slice,
				__indexOf = [].indexOf || function (item) {
					for (var i = 0, l = this.length; l > i; i++)
						if (i in this && this[i] === item) return i;
					return -1
				};
			isBrowser = "undefined" != typeof window;
			EventEmitter = require("microemitter").EventEmitter;
			Bongo = function (_super) {
				function Bongo(options) {
					EventEmitter(this);
					this.mq = options.mq, this.getSessionToken = options.getSessionToken, this.getUserArea = options.getUserArea, this.fetchName = options.fetchName, this.resourceName = options.resourceName, this.apiEndpoint = options.apiEndpoint, this.useWebsockets = options.useWebsockets, this.batchRequests = options.batchRequests, this.apiDescriptor = options.apiDescriptor;
					null == this.useWebsockets && (this.useWebsockets = !1);
					null == this.batchRequests && (this.batchRequests = !0);
					null == this.getUserArea && (this.getUserArea = function () {});
					this.localStore = new Store;
					this.remoteStore = new Store;
					this.readyState = NOTCONNECTED;
					this.stack = [];
					this.opaqueTypes = {};
					this.on("newListener", function (_this) {
						return function (event) {
							return "ready" === event && _this.readyState === CONNECTED ? process.nextTick(function () {
								_this.emit("ready");
								return _this.off("ready")
							}) : void 0
						}
					}(this));
					this.batchRequests && this.setOutboundTimer();
					this.useWebsockets || process.nextTick(this.bound("xhrHandshake"));
					process.nextTick(function (_this) {
						return function () {
							return _this.api = _this.createRemoteApiShims(_this.apiDescriptor)
						}
					}(this));
					if (null != this.mq) {
						this.eventBus = new EventBus(this.mq);
						this.mq.on("disconnected", function (_this) {
							return function () {
								_this.disconnectedAt = Date.now();
								_this.emit("disconnected");
								return _this.readyState = DISCONNECTED
							}
						}(this))
					}
				}
				var BATCH_CHUNK_MS, CONNECTED, CONNECTING, DISCONNECTED, EventBus, JsPath, Model, NOTCONNECTED, OpaqueType, Scrubber, Signature, Store, Traverse, addGlobalListener, createBongoName, createId, dash, extend, getEventChannelName, getRevivingListener, guardMethod, race, sequence, slice, _ref, _ref1, _ref2, _ref3;
				__extends(Bongo, _super);
				_ref = [0, 1, 2, 3], NOTCONNECTED = _ref[0], CONNECTING = _ref[1], CONNECTED = _ref[2], DISCONNECTED = _ref[3];
				BATCH_CHUNK_MS = 300;
				Traverse = require("traverse");
				createId = Bongo.createId = require("hat");
				JsPath = Bongo.JsPath = require("jspath");
				Bongo.dnodeProtocol = require("koding-dnode-protocol");
				Bongo.dnodeProtocol.Scrubber = require("./src/scrubber");
				_ref1 = Bongo.dnodeProtocol, Store = _ref1.Store, Scrubber = _ref1.Scrubber;
				Bongo.EventEmitter = EventEmitter;
				Model = Bongo.Model = require("./src/model");
				Bongo.ListenerTree = require("./src/listenertree");
				EventBus = Bongo.EventBus = require("./src/eventbus");
				OpaqueType = require("./src/opaquetype");
				Signature = require("./src/signature");
				Bongo.promibackify = require("./src/promibackify");
				Model.prototype.mixin(require("./src/eventemitter/broker"));
				Model.prototype.off = Model.prototype.removeListener;
				Model.prototype.addGlobalListener = Model.prototype.on;
				slice = [].slice;
				extend = require("./src/util").extend;
				_ref2 = require("sinkrow"), race = _ref2.race, sequence = _ref2.sequence, dash = _ref2.dash;
				_ref3 = require("sinkrow"), Bongo.daisy = _ref3.daisy, Bongo.dash = _ref3.dash, Bongo.sequence = _ref3.sequence, Bongo.race = _ref3.race;
				Bongo.bound = require("koding-bound");
				Bongo.prototype.bound = require("koding-bound");
				createBongoName = function (resourceName) {
					return "" + createId(128) + ".unknown.bongo-" + resourceName
				};
				Bongo.prototype.isConnected = function () {
					return this.readyState === CONNECTED
				};
				Bongo.prototype.cacheable = require("./src/cacheable");
				Bongo.prototype.createRemoteApiShims = function (api) {
					var instance, name, options, shimmedApi, statik, _ref4;
					shimmedApi = {};
					for (name in api)
						if (__hasProp.call(api, name)) {
							_ref4 = api[name], statik = _ref4.statik, instance = _ref4.instance, options = _ref4.options;
							shimmedApi[name] = this.createConstructor(name, statik, instance, options)
						}
					return shimmedApi
				};
				guardMethod = function (signatures, fn) {
					return function () {
						var rest, signature, _i, _len;
						rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
						for (_i = 0, _len = signatures.length; _len > _i; _i++) {
							signature = signatures[_i];
							if (signature.test(rest)) return fn.apply(this, rest)
						}
						throw new Error("Unrecognized signature!")
					}
				};
				Bongo.prototype.wrapStaticMethods = function () {
					var optimizeThese;
					optimizeThese = ["on", "off"];
					return function (constructor, constructorName, methods) {
						var bongo;
						bongo = this;
						return Object.keys(methods).forEach(function (method) {
							var signatures, wrapper;
							signatures = methods[method].map(Signature);
							__indexOf.call(optimizeThese, method) >= 0 && (method += "_");
							wrapper = guardMethod(signatures, function () {
								var rest, rpc;
								rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
								rpc = {
									type: "static",
									constructorName: constructorName,
									method: method
								};
								return bongo.send(rpc, rest)
							});
							wrapper.signatures = signatures;
							return constructor[method] = Bongo.promibackify(wrapper)
						})
					}
				}();
				Bongo.prototype.wrapInstanceMethods = function () {
					var optimizeThese;
					optimizeThese = ["on", "addListener", "off", "removeListener", "save"];
					return function (constructor, constructorName, methods) {
						var bongo;
						bongo = this;
						return Object.keys(methods).forEach(function (method) {
							var signatures, wrapper;
							signatures = methods[method].map(Signature);
							__indexOf.call(optimizeThese, method) >= 0 && (method += "_");
							wrapper = guardMethod(signatures, function () {
								var data, id, rest, rpc;
								rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
								id = this.getId();
								null == id && (data = this.data);
								rpc = {
									type: "instance",
									constructorName: constructorName,
									method: method,
									id: id,
									data: data
								};
								return bongo.send(rpc, rest)
							});
							wrapper.signatures = signatures;
							return constructor.prototype[method] = Bongo.promibackify(wrapper)
						})
					}
				}();
				Bongo.prototype.registerInstance = function (inst) {
					inst.on("listenerRemoved", function (_this) {
						return function (event, listener) {
							return _this.eventBus.off(inst, event, listener.bind(inst))
						}
					}(this));
					return inst.on("newListener", function (_this) {
						return function (event, listener) {
							return _this.eventBus.on(inst, event, listener.bind(inst))
						}
					}(this))
				};
				getEventChannelName = function (name) {
					return "event-" + name
				};
				getRevivingListener = function (bongo, ctx, listener) {
					return function () {
						var rest;
						rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
						return listener.apply(ctx, bongo.revive(rest))
					}
				};
				addGlobalListener = function (konstructor, event, listener) {
					return this.eventBus.staticOn(konstructor, event, function (_this) {
						return function () {
							var rest, revived;
							rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
							revived = _this.revive(rest);
							return listener.apply(konstructor, revived)
						}
					}(this))
				};
				Bongo.prototype.reviveType = function (type, shouldWrap) {
					var revived, _base, _ref4, _ref5;
					if (Array.isArray(type)) return this.reviveType(type[0], !0);
					if ("string" != typeof type) return type;
					revived = null != (_ref4 = null != (_ref5 = this.api[type]) ? _ref5 : window[type]) ? _ref4 : null != (_base = this.opaqueTypes)[type] ? _base[type] : _base[type] = new OpaqueType(type);
					return shouldWrap ? [revived] : revived
				};
				Bongo.prototype.reviveSchema = function () {
					var isArray, keys, reviveSchema, reviveSchemaRecursively;
					keys = Object.keys;
					isArray = Array.isArray;
					reviveSchemaRecursively = function (bongo, schema) {
						return keys(schema).map(function (slot) {
							var type;
							type = schema[slot];
							type && "object" == typeof type && !isArray(type) && (type = reviveSchemaRecursively(bongo, type));
							return [slot, type]
						}).reduce(function (acc, _arg) {
							var slot, type;
							slot = _arg[0], type = _arg[1];
							acc[slot] = bongo.reviveType(type);
							return acc
						}, {})
					};
					return reviveSchema = function (schema) {
						return reviveSchemaRecursively(this, schema)
					}
				}();
				Bongo.prototype.reviveOption = function (option, value) {
					switch (option) {
					case "schema":
						return this.reviveSchema(value);
					default:
						return value
					}
				};
				Bongo.prototype.createConstructor = function (name, staticMethods, instanceMethods, options) {
					var konstructor;
					konstructor = Function("bongo", "return function " + name + " () {\n  bongo.registerInstance(this);\n  this.init.apply(this, [].slice.call(arguments));\n  this.bongo_.constructorName = '" + name + "';\n}")(this);
					EventEmitter(konstructor);
					this.wrapStaticMethods(konstructor, name, staticMethods);
					__extends(konstructor, Model);
					konstructor.prototype.updateInstanceChannel = this.updateInstanceChannel;
					konstructor.on("newListener", addGlobalListener.bind(this, konstructor));
					process.nextTick(function (_this) {
						return function () {
							var option, _results;
							_results = [];
							for (option in options) __hasProp.call(options, option) && _results.push(konstructor[option] = _this.reviveOption(option, options[option]));
							return _results
						}
					}(this));
					this.wrapInstanceMethods(konstructor, name, instanceMethods);
					return konstructor
				};
				Bongo.prototype.getInstancesById = function () {};
				Bongo.prototype.getInstanceMethods = function () {
					return ["changeLoggedInState", "updateSessionToken"]
				};
				Bongo.prototype.revive = function (obj) {
					var bongo, hasEncoder;
					bongo = this;
					hasEncoder = null != ("undefined" != typeof Encoder && null !== Encoder ? Encoder.XSSEncode : void 0);
					return new Traverse(obj).map(function (node) {
						var constructorName, instance, instanceId, konstructor, _ref4;
						if (null != (null != node ? node.bongo_ : void 0)) {
							_ref4 = node.bongo_, constructorName = _ref4.constructorName, instanceId = _ref4.instanceId;
							instance = bongo.getInstancesById(instanceId);
							if (null != instance) return this.update(instance, !0);
							konstructor = bongo.api[node.bongo_.constructorName];
							return this.update(null == konstructor ? node : new konstructor(node))
						}
						return this.update(hasEncoder && "string" == typeof node ? Encoder.XSSEncode(node) : node)
					})
				};
				Bongo.prototype.reviveFromSnapshots = function () {
					var snapshotReviver;
					snapshotReviver = function (k, v) {
						return "_events" !== k ? v : void 0
					};
					return function (instances, callback) {
						var results;
						results = instances.map(function (_this) {
							return function (instance) {
								var e, revivee;
								revivee = null;
								try {
									null != instance.snapshot && (revivee = JSON.parse(instance.snapshot, snapshotReviver))
								} catch (_error) {
									e = _error;
									console.warn("couldn't revive snapshot! " + instance._id);
									revivee = null
								}
								return revivee ? _this.revive(revivee) : null
							}
						}(this));
						results = results.filter(Boolean);
						return callback(null, results)
					}
				}();
				Bongo.prototype.handleRequest = function (message) {
					var callback, context, method, revived, scrubber, unscrubbed;
					if ("defineApi" === (null != message ? message.method : void 0) && null == this.api) return this.defineApi(message.arguments[0]);
					if ("handshakeDone" === (null != message ? message.method : void 0)) return this.handshakeDone();
					method = message.method, context = message.context;
					scrubber = new Scrubber(this.localStore);
					unscrubbed = scrubber.unscrub(message, function (_this) {
						return function (callbackId) {
							_this.remoteStore.has(callbackId) || _this.remoteStore.add(callbackId, function () {
								var args;
								args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
								return _this.send(callbackId, args)
							});
							return _this.remoteStore.get(callbackId)
						}
					}(this));
					revived = this.revive(unscrubbed);
					if (__indexOf.call(this.getInstanceMethods(), method) >= 0) return this[method].apply(this, revived);
					if (!isNaN(+method)) {
						callback = this.localStore.get(method);
						return null != callback ? callback.apply(null, revived) : void 0
					}
					return "auth.authOk" !== method ? console.warn("Unhandleable message; dropping it on the floor.") : void 0
				};
				Bongo.prototype.reconnectHelper = function () {
					if (null != this.api) {
						this.readyState = CONNECTED;
						return this.emit("ready")
					}
				};
				Bongo.prototype.connectHelper = function (callback) {
					null != callback && this.mq.once("connected", callback.bind(this));
					this.channelName = createBongoName(this.resourceName);
					this.channel = this.mq.subscribe(this.channelName, {
						connectDirectly: !0
					});
					this.channel.exchange = this.resourceName;
					this.channel.setAuthenticationInfo({
						serviceType: "bongo",
						name: this.resourceName,
						clientId: this.getSessionToken()
					});
					this.channel.off("message", this.bound("handleRequest"));
					this.channel.on("message", this.bound("handleRequest"));
					this.reconnectHelper();
					this.channel.once("broker.subscribed", function (_this) {
						return function () {
							return _this.stack.forEach(function (fn) {
								return fn.call(_this)
							})
						}
					}(this));
					return this.channel.on("broker.subscribed", function (_this) {
						return function () {
							_this.emit("connected");
							if (_this.disconnectedAt) {
								_this.emit("reconnected", {
									disconnectedFor: Date.now() - _this.disconnectedAt
								});
								_this.disconnectedAt = null
							}
							if (_this.lastMessage) {
								_this.channel.publish(_this.lastMessage);
								return _this.lastMessage = null
							}
						}
					}(this))
				};
				Bongo.prototype.connect = function (callback) {
					if (null == this.mq) throw new Error("no broker client");
					switch (this.readyState) {
					case CONNECTED:
					case CONNECTING:
						return "already connected";
					case DISCONNECTED:
						this.readyState = CONNECTING;
						this.mq.connect();
						null != callback && this.mq.on("connected", function () {
							return callback(null)
						});
						break;
					default:
						this.readyState = CONNECTING;
						this.connectHelper(callback)
					}
					return this.mq.autoReconnect ? this.mq.once("disconnected", function (_this) {
						return function () {
							return _this.mq.once("connected", function () {
								return _this.reconnectHelper()
							})
						}
					}(this)) : void 0
				};
				Bongo.prototype.disconnect = function (shouldReconnect, callback) {
					if (null == this.mq) throw new Error("no broker client");
					if ("function" == typeof shouldReconnect) {
						callback = shouldReconnect;
						shouldReconnect = !1
					}
					if (this.readyState === NOTCONNECTED || this.readyState === DISCONNECTED) return "already disconnected";
					null != callback && this.mq.once("disconnected", callback.bind(this));
					this.mq.disconnect(shouldReconnect);
					return this.readyState = DISCONNECTED
				};
				Bongo.prototype.messageFailed = function (message) {
					return console.log("MESSAGE FAILED", message)
				};
				Bongo.prototype.getTimeout = function (message, clientTimeout) {
					null == clientTimeout && (clientTimeout = 5e3);
					return setTimeout(this.messageFailed.bind(this, message), clientTimeout)
				};
				Bongo.prototype.ping = function (callback) {
					return this.readyState === CONNECTED && this.useWebsockets ? this.send("ping", callback) : void 0
				};
				Bongo.prototype.send = function (method, args) {
					var scrubber;
					Array.isArray(args) || (args = [args]);
					if (null != this.mq && !this.channel) throw new Error("No channel!");
					scrubber = new Scrubber(this.localStore);
					return scrubber.scrub(args, function (_this) {
						return function () {
							var message;
							message = scrubber.toDnodeProtocol();
							message.method = method;
							message.sessionToken = _this.getSessionToken();
							message.userArea = _this.getUserArea();
							return _this.sendHelper(message)
						}
					}(this))
				};
				Bongo.prototype.sendHelper = function (message) {
					var messageString;
					if (this.useWebsockets) {
						messageString = JSON.stringify(message);
						if (this.channel.isOpen) return this.channel.publish(messageString);
						this.lastMessage = messageString;
						return this.connect()
					}
					return this.apiEndpoint ? this.batchRequests ? this.enqueueMessage(message) : this.sendXhr(this.apiEndpoint, "POST", [message]) : void 0
				};
				Bongo.prototype.setOutboundTimer = function () {
					this.outboundQueue = [];
					return this.outboundTimer = setInterval(function (_this) {
						return function () {
							_this.outboundQueue.length && _this.sendXhr(_this.apiEndpoint, "POST", _this.outboundQueue);
							return _this.outboundQueue.length = 0
						}
					}(this), BATCH_CHUNK_MS)
				};
				Bongo.prototype.enqueueMessage = function (message) {
					return this.outboundQueue.push(message)
				};
				Bongo.prototype.sendXhr = function (url, method, queue) {
					var messageString, xhr;
					xhr = new XMLHttpRequest;
					xhr.open(method, url);
					xhr.setRequestHeader("Content-type", "application/json;charset=UTF-8");
					xhr.onreadystatechange = function (_this) {
						return function () {
							var request, requests, _i, _len, _ref4, _results;
							if (0 !== xhr.status) {
								xhr.status >= 400 && _this.emit("error", new Error("XHR Error: " + xhr.status));
								if (4 === xhr.readyState && (200 === (_ref4 = xhr.status) || 304 === _ref4)) {
									requests = JSON.parse(xhr.response);
									_results = [];
									for (_i = 0, _len = requests.length; _len > _i; _i++) {
										request = requests[_i];
										request && _results.push(_this.handleRequest(request))
									}
									return _results
								}
							}
						}
					}(this);
					messageString = JSON.stringify({
						channelName: this.channelName,
						queue: queue
					});
					return xhr.send(messageString)
				};
				Bongo.prototype.authenticateUser = function () {
					var clientId;
					clientId = this.getSessionToken();
					return this.send("authenticateUser", [clientId, this.bound("changeLoggedInState")])
				};
				Bongo.prototype.handshakeDone = function () {
					if (this.readyState !== CONNECTED) {
						this.readyState = CONNECTED;
						this.emit("ready");
						return this.authenticateUser()
					}
				};
				Bongo.prototype.defineApi = function (api) {
					null != api && (this.api || (this.api = this.createRemoteApiShims(api)));
					return this.handshakeDone()
				};
				Bongo.prototype.changeLoggedInState = function (state) {
					return this.emit("loggedInStateChanged", state)
				};
				Bongo.prototype.updateSessionToken = function (token) {
					return this.emit("sessionTokenChanged", token)
				};
				Bongo.prototype.fetchChannel = function (channelName, callback) {
					var channel;
					if (null == this.mq) throw new Error("no broker client");
					channel = this.mq.subscribe(channelName);
					return channel.once("broker.subscribed", function () {
						return callback(channel)
					})
				};
				Bongo.prototype.use = function (fn) {
					return this.stack.push(fn)
				};
				Bongo.prototype.monitorPresence = function (callbacks) {
					return this.send("monitorPresence", callbacks)
				};
				Bongo.prototype.subscribe = function (name, options, callback) {
					var channel;
					null == options && (options = {});
					if (null == this.mq) throw new Error("no broker client");
					null == options.serviceType && (options.serviceType = "application");
					channel = this.mq.subscribe(name, options);
					options.name = name;
					options.clientId = this.getSessionToken();
					channel.setAuthenticationInfo(options);
					null != callback && channel.once("broker.subscribed", function () {
						return callback(channel)
					});
					return channel
				};
				Bongo.prototype.xhrHandshake = function () {
					return this.send("xhrHandshake", function (_this) {
						return function (api) {
							return _this.api ? _this.handshakeDone() : _this.defineApi(api)
						}
					}(this))
				};
				return Bongo
			}(EventEmitter);
			!isBrowser && module ? module.exports = Bongo : "undefined" != typeof window && null !== window && (window.Bongo = Bongo)
		});
		require("/node_modules_koding/bongo-client/bongo.js")
	}()
}();
(function () {
	var Pistachio, __slice = Array.prototype.slice,
		__hasProp = Object.prototype.hasOwnProperty;
	Pistachio = function () {
		function Pistachio(view, template, options) {
			var _ref;
			this.view = view;
			this.template = template;
			this.options = null != options ? options : {};
			_ref = this.options, this.prefix = _ref.prefix, this.params = _ref.params;
			this.params || (this.params = {});
			this.symbols = {};
			this.symbolsByDataPath = {};
			this.symbolsBySubViewName = {};
			this.dataPaths = {};
			this.subViewNames = {};
			this.prefix || (this.prefix = "");
			this.html = this.init()
		}
		var cleanSubviewNames, pistachios, symbolKeys;
		Pistachio.createId = function () {
			var counter;
			counter = 0;
			return function (prefix) {
				return "" + prefix + "el-" + counter++
			}
		}();
		Pistachio.getAt = function (ref, path) {
			var prop;
			path = "function" == typeof path.split ? path.split(".") : path.slice();
			for (; null != ref && (prop = path.shift());) ref = ref[prop];
			return ref
		};
		pistachios = /\{([\w|-]*)?(\#[\w|-]*)?((?:\.[\w|-]*)*)(\[(?:\b[\w|-]*\b)(?:\=[\"|\']?.*[\"|\']?)\])*\{([^{}]*)\}\s*\}/g;
		Pistachio.prototype.createId = Pistachio.createId;
		Pistachio.prototype.toString = function () {
			return this.template
		};
		Pistachio.prototype.init = function () {
			var dataGetter, getEmbedderFn, init;
			dataGetter = function (prop) {
				var data;
				data = "function" == typeof this.getData ? this.getData() : void 0;
				return null != data ? ("function" == typeof data.getAt ? data.getAt(prop) : void 0) || Pistachio.getAt(data, prop) : void 0
			};
			getEmbedderFn = function (pistachio, view, id, symbol) {
				return function (childView) {
					view.embedChild(id, childView, symbol.isCustom);
					if (!symbol.isCustom) {
						symbol.id = childView.id;
						symbol.tagName = "function" == typeof childView.getTagName ? childView.getTagName() : void 0;
						delete pistachio.symbols[id];
						return pistachio.symbols[childView.id] = symbol
					}
				}
			};
			return init = function () {
				var createId, prefix, view, _this = this;
				prefix = this.prefix, view = this.view, createId = this.createId;
				return this.template.replace(pistachios, function (_, tagName, id, classes, attrs, expression) {
					var classAttr, classNames, code, dataPaths, dataPathsAttr, embedChild, formalParams, isCustom, js, paramKeys, paramValues, render, subViewNames, subViewNamesAttr, symbol;
					id = null != id ? id.split("#")[1] : void 0;
					classNames = (null != classes ? classes.split(".").slice(1) : void 0) || [];
					attrs = (null != attrs ? attrs.replace(/\]\[/g, " ").replace(/\[|\]/g, "") : void 0) || "";
					isCustom = !!(tagName || id || classes.length || attrs.length);
					tagName || (tagName = "span");
					dataPaths = [];
					subViewNames = [];
					expression = expression.replace(/#\(([^)]*)\)/g, function (_, dataPath) {
						dataPaths.push(dataPath);
						return "data('" + dataPath + "')"
					}).replace(/^(?:> ?|embedChild )(.+)/, function (_, subViewName) {
						subViewNames.push(subViewName.replace(/\@\.?|this\./, ""));
						return "embedChild(" + subViewName + ")"
					});
					_this.registerDataPaths(dataPaths);
					_this.registerSubViewNames(subViewNames);
					js = "return " + expression;
					if ("debug" === tagName) {
						console.debug(js);
						tagName = "span"
					}
					paramKeys = Object.keys(_this.params);
					paramValues = paramKeys.map(function (key) {
						return _this.params[key]
					});
					formalParams = ["data", "embedChild"].concat(__slice.call(paramKeys));
					try {
						code = Function.apply(null, __slice.call(formalParams).concat([js]))
					} catch (e) {
						throw new Error("Pistachio encountered an error: " + e + "\nSource: " + js)
					}
					id || (id = createId(prefix));
					render = function () {
						return "" + code.apply(view, [dataGetter.bind(view), embedChild].concat(__slice.call(paramValues)))
					};
					symbol = {
						tagName: tagName,
						id: id,
						isCustom: isCustom,
						js: js,
						code: code,
						render: render,
						dataPaths: dataPaths,
						subViewNames: subViewNames
					};
					_this.addSymbolInternal(symbol);
					embedChild = getEmbedderFn(_this, view, id, symbol);
					dataPathsAttr = dataPaths.length ? " data-" + prefix + "paths='" + dataPaths.join(" ") + "'" : "";
					subViewNamesAttr = subViewNames.length ? (classNames.push("" + prefix + "subview"), " data-" + prefix + "subviews='" + cleanSubviewNames(subViewNames.join(" ")) + "'") : "";
					classAttr = classNames.length ? " class='" + classNames.join(" ") + "'" : "";
					return "<" + tagName + classAttr + dataPathsAttr + subViewNamesAttr + " " + attrs + " id='" + id + "'></" + tagName + ">"
				})
			}
		}();
		Pistachio.prototype.addSymbolInternal = function (symbol) {
			var dataPath, dataPaths, subViewName, subViewNames, _base, _base2, _i, _j, _len, _len2;
			dataPaths = symbol.dataPaths, subViewNames = symbol.subViewNames;
			this.symbols[symbol.id] = symbol;
			for (_i = 0, _len = dataPaths.length; _len > _i; _i++) {
				dataPath = dataPaths[_i];
				null == (_base = this.symbolsByDataPath)[dataPath] && (_base[dataPath] = []);
				this.symbolsByDataPath[dataPath].push(symbol)
			}
			for (_j = 0, _len2 = subViewNames.length; _len2 > _j; _j++) {
				subViewName = subViewNames[_j];
				null == (_base2 = this.symbolsBySubViewName)[subViewName] && (_base2[subViewName] = []);
				this.symbolsBySubViewName[subViewName].push(symbol)
			}
			return symbol
		};
		Pistachio.prototype.addSymbol = function (childView) {
			return this.symbols[childView.id] = {
				id: childView.id,
				tagName: "function" == typeof childView.getTagName ? childView.getTagName() : void 0
			}
		};
		Pistachio.prototype.appendChild = function (childView) {
			return this.addAdhocSymbol(childView)
		};
		Pistachio.prototype.prependChild = function (childView) {
			return this.addAdhocSymbol(childView)
		};
		Pistachio.prototype.registerDataPaths = function (paths) {
			var path, _i, _len, _results;
			_results = [];
			for (_i = 0, _len = paths.length; _len > _i; _i++) {
				path = paths[_i];
				_results.push(this.dataPaths[path] = !0)
			}
			return _results
		};
		Pistachio.prototype.registerSubViewNames = function (subViewNames) {
			var subViewName, _i, _len, _results;
			_results = [];
			for (_i = 0, _len = subViewNames.length; _len > _i; _i++) {
				subViewName = subViewNames[_i];
				_results.push(this.subViewNames[subViewName] = !0)
			}
			return _results
		};
		Pistachio.prototype.getDataPaths = function () {
			return Object.keys(this.dataPaths)
		};
		Pistachio.prototype.getSubViewNames = function () {
			return Object.keys(this.subViewNames)
		};
		cleanSubviewNames = function (name) {
			return name.replace(/(this\["|\"])/g, "")
		};
		symbolKeys = {
			subview: "symbolsBySubViewName",
			path: "symbolsByDataPath"
		};
		Pistachio.prototype.refreshChildren = function (childType, items, forEach) {
			var el, id, item, out, symbol, symbols, unique, _i, _j, _len, _len2, _results;
			null == forEach && (forEach = function () {});
			unique = {};
			for (_i = 0, _len = items.length; _len > _i; _i++) {
				item = items[_i];
				symbols = this[symbolKeys[childType]][item];
				if (null != symbols)
					for (_j = 0, _len2 = symbols.length; _len2 > _j; _j++) {
						symbol = symbols[_j];
						unique[symbol.id] = symbol
					}
			}
			_results = [];
			for (id in unique)
				if (__hasProp.call(unique, id)) {
					symbol = unique[id];
					el = this.view.getElement().querySelector("#" + id);
					if (null != el) {
						out = null != symbol ? symbol.render() : void 0;
						_results.push(out ? forEach.call(el, out) : void 0)
					}
				}
			return _results
		};
		Pistachio.prototype.embedSubViews = function (subviews) {
			null == subviews && (subviews = this.getSubViewNames());
			return this.refreshChildren("subview", subviews)
		};
		Pistachio.prototype.update = function (paths) {
			null == paths && (paths = this.getDataPaths());
			return this.refreshChildren("path", paths, function (html) {
				return this.innerHTML = html
			})
		};
		return Pistachio
	}();
	this.Pistachio = Pistachio
}).call(this);
var md5;
md5 = function () {
	function hex_md5(a) {
		return rstr2hex(rstr_md5(str2rstr_utf8(a)))
	}

	function rstr_md5(a) {
		return binl2rstr(binl_md5(rstr2binl(a), 8 * a.length))
	}

	function rstr2hex(c) {
		try {} catch (g) {
			hexcase = 0
		}
		for (var a, f = hexcase ? "0123456789ABCDEF" : "0123456789abcdef", b = "", d = 0; d < c.length; d++) {
			a = c.charCodeAt(d);
			b += f.charAt(a >>> 4 & 15) + f.charAt(15 & a)
		}
		return b
	}

	function str2rstr_utf8(c) {
		for (var a, e, b = "", d = -1; ++d < c.length;) {
			a = c.charCodeAt(d);
			e = d + 1 < c.length ? c.charCodeAt(d + 1) : 0;
			if (a >= 55296 && 56319 >= a && e >= 56320 && 57343 >= e) {
				a = 65536 + ((1023 & a) << 10) + (1023 & e);
				d++
			}
			127 >= a ? b += String.fromCharCode(a) : 2047 >= a ? b += String.fromCharCode(192 | a >>> 6 & 31, 128 | 63 & a) : 65535 >= a ? b += String.fromCharCode(224 | a >>> 12 & 15, 128 | a >>> 6 & 63, 128 | 63 & a) : 2097151 >= a && (b += String.fromCharCode(240 | a >>> 18 & 7, 128 | a >>> 12 & 63, 128 | a >>> 6 & 63, 128 | 63 & a))
		}
		return b
	}

	function rstr2binl(b) {
		for (var a = Array(b.length >> 2), c = 0; c < a.length; c++) a[c] = 0;
		for (var c = 0; c < 8 * b.length; c += 8) a[c >> 5] |= (255 & b.charCodeAt(c / 8)) << c % 32;
		return a
	}

	function binl2rstr(b) {
		for (var a = "", c = 0; c < 32 * b.length; c += 8) a += String.fromCharCode(b[c >> 5] >>> c % 32 & 255);
		return a
	}

	function binl_md5(p, k) {
		p[k >> 5] |= 128 << k % 32;
		p[(k + 64 >>> 9 << 4) + 14] = k;
		for (var o = 1732584193, n = -271733879, m = -1732584194, l = 271733878, g = 0; g < p.length; g += 16) {
			var j = o,
				h = n,
				f = m,
				e = l;
			o = md5_ff(o, n, m, l, p[g + 0], 7, -680876936);
			l = md5_ff(l, o, n, m, p[g + 1], 12, -389564586);
			m = md5_ff(m, l, o, n, p[g + 2], 17, 606105819);
			n = md5_ff(n, m, l, o, p[g + 3], 22, -1044525330);
			o = md5_ff(o, n, m, l, p[g + 4], 7, -176418897);
			l = md5_ff(l, o, n, m, p[g + 5], 12, 1200080426);
			m = md5_ff(m, l, o, n, p[g + 6], 17, -1473231341);
			n = md5_ff(n, m, l, o, p[g + 7], 22, -45705983);
			o = md5_ff(o, n, m, l, p[g + 8], 7, 1770035416);
			l = md5_ff(l, o, n, m, p[g + 9], 12, -1958414417);
			m = md5_ff(m, l, o, n, p[g + 10], 17, -42063);
			n = md5_ff(n, m, l, o, p[g + 11], 22, -1990404162);
			o = md5_ff(o, n, m, l, p[g + 12], 7, 1804603682);
			l = md5_ff(l, o, n, m, p[g + 13], 12, -40341101);
			m = md5_ff(m, l, o, n, p[g + 14], 17, -1502002290);
			n = md5_ff(n, m, l, o, p[g + 15], 22, 1236535329);
			o = md5_gg(o, n, m, l, p[g + 1], 5, -165796510);
			l = md5_gg(l, o, n, m, p[g + 6], 9, -1069501632);
			m = md5_gg(m, l, o, n, p[g + 11], 14, 643717713);
			n = md5_gg(n, m, l, o, p[g + 0], 20, -373897302);
			o = md5_gg(o, n, m, l, p[g + 5], 5, -701558691);
			l = md5_gg(l, o, n, m, p[g + 10], 9, 38016083);
			m = md5_gg(m, l, o, n, p[g + 15], 14, -660478335);
			n = md5_gg(n, m, l, o, p[g + 4], 20, -405537848);
			o = md5_gg(o, n, m, l, p[g + 9], 5, 568446438);
			l = md5_gg(l, o, n, m, p[g + 14], 9, -1019803690);
			m = md5_gg(m, l, o, n, p[g + 3], 14, -187363961);
			n = md5_gg(n, m, l, o, p[g + 8], 20, 1163531501);
			o = md5_gg(o, n, m, l, p[g + 13], 5, -1444681467);
			l = md5_gg(l, o, n, m, p[g + 2], 9, -51403784);
			m = md5_gg(m, l, o, n, p[g + 7], 14, 1735328473);
			n = md5_gg(n, m, l, o, p[g + 12], 20, -1926607734);
			o = md5_hh(o, n, m, l, p[g + 5], 4, -378558);
			l = md5_hh(l, o, n, m, p[g + 8], 11, -2022574463);
			m = md5_hh(m, l, o, n, p[g + 11], 16, 1839030562);
			n = md5_hh(n, m, l, o, p[g + 14], 23, -35309556);
			o = md5_hh(o, n, m, l, p[g + 1], 4, -1530992060);
			l = md5_hh(l, o, n, m, p[g + 4], 11, 1272893353);
			m = md5_hh(m, l, o, n, p[g + 7], 16, -155497632);
			n = md5_hh(n, m, l, o, p[g + 10], 23, -1094730640);
			o = md5_hh(o, n, m, l, p[g + 13], 4, 681279174);
			l = md5_hh(l, o, n, m, p[g + 0], 11, -358537222);
			m = md5_hh(m, l, o, n, p[g + 3], 16, -722521979);
			n = md5_hh(n, m, l, o, p[g + 6], 23, 76029189);
			o = md5_hh(o, n, m, l, p[g + 9], 4, -640364487);
			l = md5_hh(l, o, n, m, p[g + 12], 11, -421815835);
			m = md5_hh(m, l, o, n, p[g + 15], 16, 530742520);
			n = md5_hh(n, m, l, o, p[g + 2], 23, -995338651);
			o = md5_ii(o, n, m, l, p[g + 0], 6, -198630844);
			l = md5_ii(l, o, n, m, p[g + 7], 10, 1126891415);
			m = md5_ii(m, l, o, n, p[g + 14], 15, -1416354905);
			n = md5_ii(n, m, l, o, p[g + 5], 21, -57434055);
			o = md5_ii(o, n, m, l, p[g + 12], 6, 1700485571);
			l = md5_ii(l, o, n, m, p[g + 3], 10, -1894986606);
			m = md5_ii(m, l, o, n, p[g + 10], 15, -1051523);
			n = md5_ii(n, m, l, o, p[g + 1], 21, -2054922799);
			o = md5_ii(o, n, m, l, p[g + 8], 6, 1873313359);
			l = md5_ii(l, o, n, m, p[g + 15], 10, -30611744);
			m = md5_ii(m, l, o, n, p[g + 6], 15, -1560198380);
			n = md5_ii(n, m, l, o, p[g + 13], 21, 1309151649);
			o = md5_ii(o, n, m, l, p[g + 4], 6, -145523070);
			l = md5_ii(l, o, n, m, p[g + 11], 10, -1120210379);
			m = md5_ii(m, l, o, n, p[g + 2], 15, 718787259);
			n = md5_ii(n, m, l, o, p[g + 9], 21, -343485551);
			o = safe_add(o, j);
			n = safe_add(n, h);
			m = safe_add(m, f);
			l = safe_add(l, e)
		}
		return Array(o, n, m, l)
	}

	function md5_cmn(h, e, d, c, g, f) {
		return safe_add(bit_rol(safe_add(safe_add(e, h), safe_add(c, f)), g), d)
	}

	function md5_ff(g, f, k, j, e, i, h) {
		return md5_cmn(f & k | ~f & j, g, f, e, i, h)
	}

	function md5_gg(g, f, k, j, e, i, h) {
		return md5_cmn(f & j | k & ~j, g, f, e, i, h)
	}

	function md5_hh(g, f, k, j, e, i, h) {
		return md5_cmn(f ^ k ^ j, g, f, e, i, h)
	}

	function md5_ii(g, f, k, j, e, i, h) {
		return md5_cmn(k ^ (f | ~j), g, f, e, i, h)
	}

	function safe_add(a, d) {
		var c = (65535 & a) + (65535 & d),
			b = (a >> 16) + (d >> 16) + (c >> 16);
		return b << 16 | 65535 & c
	}

	function bit_rol(a, b) {
		return a << b | a >>> 32 - b
	}

	function md5() {}
	var hexcase = 0;
	md5.name = "md5";
	md5.digest = hex_md5;
	return md5
}();
! function (app) {
	"use strict";
	var namespace = "v4",
		c = 0,
		blockSize = 4,
		base = 36,
		discreteValues = Math.pow(base, blockSize),
		pad = function (num, size) {
			var s = "000000000" + num;
			return s.substr(s.length - size)
		},
		randomBlock = function () {
			return pad((Math.random() * discreteValues << 0).toString(base), blockSize)
		},
		api = function () {
			var counter, letter = "c",
				timestamp = (new Date).getTime().toString(base),
				fingerprint = api.fingerprint(),
				random = randomBlock() + randomBlock();
			c = discreteValues > c ? c : 0;
			counter = pad(c.toString(base), blockSize);
			c++;
			return letter + timestamp + counter + fingerprint + random
		};
	api.slug = function () {
		var date = (new Date).getTime().toString(36),
			counter = c.toString(36).slice(-1),
			print = api.fingerprint().slice(0, 1) + api.fingerprint().slice(-1),
			random = randomBlock().slice(-1);
		c++;
		return date.slice(2, 4) + date.slice(-2) + counter + print + random
	};
	api.globalCount = function () {
		var cache = function () {
			var i, count = 0;
			for (i in window) count++;
			return count
		}();
		api.globalCount = function () {
			return cache
		};
		return cache
	};
	api.fingerprint = function () {
		return pad((navigator.mimeTypes.length + navigator.userAgent.length).toString(36) + api.globalCount().toString(36), 4)
	};
	app.register ? app.register(namespace, api) : "undefined" != typeof module ? module.exports = api : app[namespace] = api
}(this.uuid = {});
! function (root) {
	function isString(obj) {
		return !!("" === obj || obj && obj.charCodeAt && obj.substr)
	}

	function isArray(obj) {
		return nativeIsArray ? nativeIsArray(obj) : "[object Array]" === toString.call(obj)
	}

	function isObject(obj) {
		return obj && "[object Object]" === toString.call(obj)
	}

	function defaults(object, defs) {
		var key;
		object = object || {};
		defs = defs || {};
		for (key in defs) defs.hasOwnProperty(key) && null == object[key] && (object[key] = defs[key]);
		return object
	}

	function map(obj, iterator, context) {
		var i, j, results = [];
		if (!obj) return results;
		if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
		for (i = 0, j = obj.length; j > i; i++) results[i] = iterator.call(context, obj[i], i, obj);
		return results
	}

	function checkPrecision(val, base) {
		val = Math.round(Math.abs(val));
		return isNaN(val) ? base : val
	}

	function checkCurrencyFormat(format) {
		var defaults = lib.settings.currency.format;
		"function" == typeof format && (format = format());
		return isString(format) && format.match("%v") ? {
			pos: format,
			neg: format.replace("-", "").replace("%v", "-%v"),
			zero: format
		} : format && format.pos && format.pos.match("%v") ? format : isString(defaults) ? lib.settings.currency.format = {
			pos: defaults,
			neg: defaults.replace("%v", "-%v"),
			zero: defaults
		} : defaults
	}
	var lib = {};
	lib.version = "0.3.2";
	lib.settings = {
		currency: {
			symbol: "$",
			format: "%s%v",
			decimal: ".",
			thousand: ",",
			precision: 2,
			grouping: 3
		},
		number: {
			precision: 0,
			grouping: 3,
			thousand: ",",
			decimal: "."
		}
	};
	var nativeMap = Array.prototype.map,
		nativeIsArray = Array.isArray,
		toString = Object.prototype.toString,
		unformat = lib.unformat = lib.parse = function (value, decimal) {
			if (isArray(value)) return map(value, function (val) {
				return unformat(val, decimal)
			});
			value = value || 0;
			if ("number" == typeof value) return value;
			decimal = decimal || lib.settings.number.decimal;
			var regex = new RegExp("[^0-9-" + decimal + "]", ["g"]),
				unformatted = parseFloat(("" + value).replace(/\((.*)\)/, "-$1").replace(regex, "").replace(decimal, "."));
			return isNaN(unformatted) ? 0 : unformatted
		},
		toFixed = lib.toFixed = function (value, precision) {
			precision = checkPrecision(precision, lib.settings.number.precision);
			var power = Math.pow(10, precision);
			return (Math.round(lib.unformat(value) * power) / power).toFixed(precision)
		},
		formatNumber = lib.formatNumber = function (number, precision, thousand, decimal) {
			if (isArray(number)) return map(number, function (val) {
				return formatNumber(val, precision, thousand, decimal)
			});
			number = unformat(number);
			var opts = defaults(isObject(precision) ? precision : {
					precision: precision,
					thousand: thousand,
					decimal: decimal
				}, lib.settings.number),
				usePrecision = checkPrecision(opts.precision),
				negative = 0 > number ? "-" : "",
				base = parseInt(toFixed(Math.abs(number || 0), usePrecision), 10) + "",
				mod = base.length > 3 ? base.length % 3 : 0;
			return negative + (mod ? base.substr(0, mod) + opts.thousand : "") + base.substr(mod).replace(/(\d{3})(?=\d)/g, "$1" + opts.thousand) + (usePrecision ? opts.decimal + toFixed(Math.abs(number), usePrecision).split(".")[1] : "")
		},
		formatMoney = lib.formatMoney = function (number, symbol, precision, thousand, decimal, format) {
			if (isArray(number)) return map(number, function (val) {
				return formatMoney(val, symbol, precision, thousand, decimal, format)
			});
			number = unformat(number);
			var opts = defaults(isObject(symbol) ? symbol : {
					symbol: symbol,
					precision: precision,
					thousand: thousand,
					decimal: decimal,
					format: format
				}, lib.settings.currency),
				formats = checkCurrencyFormat(opts.format),
				useFormat = number > 0 ? formats.pos : 0 > number ? formats.neg : formats.zero;
			return useFormat.replace("%s", opts.symbol).replace("%v", formatNumber(Math.abs(number), checkPrecision(opts.precision), opts.thousand, opts.decimal))
		};
	lib.formatColumn = function (list, symbol, precision, thousand, decimal, format) {
		if (!list) return [];
		var opts = defaults(isObject(symbol) ? symbol : {
				symbol: symbol,
				precision: precision,
				thousand: thousand,
				decimal: decimal,
				format: format
			}, lib.settings.currency),
			formats = checkCurrencyFormat(opts.format),
			padAfterSymbol = formats.pos.indexOf("%s") < formats.pos.indexOf("%v") ? !0 : !1,
			maxLength = 0,
			formatted = map(list, function (val) {
				if (isArray(val)) return lib.formatColumn(val, opts);
				val = unformat(val);
				var useFormat = val > 0 ? formats.pos : 0 > val ? formats.neg : formats.zero,
					fVal = useFormat.replace("%s", opts.symbol).replace("%v", formatNumber(Math.abs(val), checkPrecision(opts.precision), opts.thousand, opts.decimal));
				fVal.length > maxLength && (maxLength = fVal.length);
				return fVal
			});
		return map(formatted, function (val) {
			return isString(val) && val.length < maxLength ? padAfterSymbol ? val.replace(opts.symbol, opts.symbol + new Array(maxLength - val.length + 1).join(" ")) : new Array(maxLength - val.length + 1).join(" ") + val : val
		})
	};
	root.accounting = lib
}(this);
! function (e) {
	"object" == typeof exports ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : "undefined" != typeof window ? window.Promise = e() : "undefined" != typeof global ? global.Promise = e() : "undefined" != typeof self && (self.Promise = e())
}(function () {
	return function e(t, n, r) {
		function s(o, u) {
			if (!n[o]) {
				if (!t[o]) {
					var a = "function" == typeof require && require;
					if (!u && a) return a(o, !0);
					if (i) return i(o, !0);
					throw new Error("Cannot find module '" + o + "'")
				}
				var f = n[o] = {
					exports: {}
				};
				t[o][0].call(f.exports, function (e) {
					var n = t[o][1][e];
					return s(n ? n : e)
				}, f, f.exports, e, t, n, r)
			}
			return n[o].exports
		}
		for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
		return s
	}({
		1: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, Promise$_CreatePromiseArray, PromiseArray) {
					function Promise$_Any(promises, useBound, caller) {
						var ret = Promise$_CreatePromiseArray(promises, SomePromiseArray, caller, useBound === !0 && promises._isBound() ? promises._boundTo : void 0),
							promise = ret.promise();
						if (promise.isRejected()) return promise;
						ret.setHowMany(1);
						ret.setUnwrap();
						ret.init();
						return promise
					} {
						var SomePromiseArray = require("./some_promise_array.js")(PromiseArray);
						require("./assert.js")
					}
					Promise.any = function (promises) {
						return Promise$_Any(promises, !1, Promise.any)
					};
					Promise.prototype.any = function () {
						return Promise$_Any(this, !0, this.any)
					}
				}
			}, {
				"./assert.js": 2,
				"./some_promise_array.js": 35
			}
		],
		2: [
			function (require, module) {
				"use strict";
				module.exports = function () {
					var AssertionError = function () {
						function AssertionError(a) {
							this.constructor$(a);
							this.message = a;
							this.name = "AssertionError"
						}
						AssertionError.prototype = new Error;
						AssertionError.prototype.constructor = AssertionError;
						AssertionError.prototype.constructor$ = Error;
						return AssertionError
					}();
					return function assert(boolExpr, message) {
						if (boolExpr !== !0) {
							var ret = new AssertionError(message);
							Error.captureStackTrace && Error.captureStackTrace(ret, assert);
							console && console.error && console.error(ret.stack + "");
							throw ret
						}
					}
				}()
			}, {}
		],
		3: [
			function (require, module) {
				"use strict";

				function Async() {
					this._isTickUsed = !1;
					this._length = 0;
					this._lateBuffer = new Queue;
					this._functionBuffer = new Queue(75e3);
					var self = this;
					this.consumeFunctionBuffer = function () {
						self._consumeFunctionBuffer()
					}
				}
				var schedule = (require("./assert.js"), require("./schedule.js")),
					Queue = require("./queue.js"),
					errorObj = require("./util.js").errorObj,
					tryCatch1 = require("./util.js").tryCatch1;
				Async.prototype.haveItemsQueued = function () {
					return this._length > 0
				};
				Async.prototype.invokeLater = function (fn, receiver, arg) {
					this._lateBuffer.push(fn, receiver, arg);
					this._queueTick()
				};
				Async.prototype.invoke = function (fn, receiver, arg) {
					var functionBuffer = this._functionBuffer;
					functionBuffer.push(fn, receiver, arg);
					this._length = functionBuffer.length();
					this._queueTick()
				};
				Async.prototype._consumeFunctionBuffer = function () {
					for (var functionBuffer = this._functionBuffer; functionBuffer.length() > 0;) {
						var fn = functionBuffer.shift(),
							receiver = functionBuffer.shift(),
							arg = functionBuffer.shift();
						fn.call(receiver, arg)
					}
					this._reset();
					this._consumeLateBuffer()
				};
				Async.prototype._consumeLateBuffer = function () {
					for (var buffer = this._lateBuffer; buffer.length() > 0;) {
						var fn = buffer.shift(),
							receiver = buffer.shift(),
							arg = buffer.shift(),
							res = tryCatch1(fn, receiver, arg);
						if (res === errorObj) {
							this._queueTick();
							throw res.e
						}
					}
				};
				Async.prototype._queueTick = function () {
					if (!this._isTickUsed) {
						schedule(this.consumeFunctionBuffer);
						this._isTickUsed = !0
					}
				};
				Async.prototype._reset = function () {
					this._isTickUsed = !1;
					this._length = 0
				};
				module.exports = new Async
			}, {
				"./assert.js": 2,
				"./queue.js": 28,
				"./schedule.js": 31,
				"./util.js": 39
			}
		],
		4: [
			function (require, module) {
				"use strict";
				var Promise = require("./promise.js")();
				module.exports = Promise
			}, {
				"./promise.js": 20
			}
		],
		5: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise) {
					function Promise$getter(obj) {
						var prop = "string" == typeof this ? this : "" + this;
						return obj[prop]
					}
					Promise.prototype.call = function (propertyName) {
						for (var $_len = arguments.length, args = new Array($_len - 1), $_i = 1; $_len > $_i; ++$_i) args[$_i - 1] = arguments[$_i];
						return this._then(function (obj) {
							return obj[propertyName].apply(obj, args)
						}, void 0, void 0, void 0, void 0, this.call)
					};
					Promise.prototype.get = function (propertyName) {
						return this._then(Promise$getter, void 0, void 0, propertyName, void 0, this.get)
					}
				}
			}, {}
		],
		6: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, INTERNAL) {
					var errors = require("./errors.js"),
						async = require("./async.js"),
						CancellationError = (require("./assert.js"), errors.CancellationError),
						SYNC_TOKEN = {};
					Promise.prototype._cancel = function () {
						if (!this.isCancellable()) return this;
						var parent;
						if (void 0 === (parent = this._cancellationParent)) {
							var err = new CancellationError;
							this._attachExtraTrace(err);
							this._rejectUnchecked(err)
						} else parent.cancel(SYNC_TOKEN)
					};
					Promise.prototype.cancel = function (token) {
						if (!this.isCancellable()) return this;
						if (token === SYNC_TOKEN) {
							this._cancel();
							return this
						}
						async.invokeLater(this._cancel, this, void 0);
						return this
					};
					Promise.prototype.cancellable = function () {
						if (this._cancellable()) return this;
						this._setCancellable();
						this._cancellationParent = void 0;
						return this
					};
					Promise.prototype.uncancellable = function () {
						var ret = new Promise(INTERNAL);
						ret._setTrace(this.uncancellable, this);
						ret._follow(this);
						ret._unsetCancellable();
						this._isBound() && ret._setBoundTo(this._boundTo);
						return ret
					};
					Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
						var ret = this._then(didFulfill, didReject, didProgress, void 0, void 0, this.fork);
						ret._setCancellable();
						ret._cancellationParent = void 0;
						return ret
					}
				}
			}, {
				"./assert.js": 2,
				"./async.js": 3,
				"./errors.js": 10
			}
		],
		7: [
			function (require, module) {
				"use strict";
				module.exports = function () {
					function formatNonError(obj) {
						var str;
						if ("function" == typeof obj) str = "[function " + (obj.name || "anonymous") + "]";
						else {
							str = obj.toString();
							var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
							if (ruselessToString.test(str)) try {
								var newStr = JSON.stringify(obj);
								str = newStr
							} catch (e) {}
							0 === str.length && (str = "(empty array)")
						}
						return "(<" + snip(str) + ">, no stack trace)"
					}

					function snip(str) {
						var maxChars = 41;
						return str.length < maxChars ? str : str.substr(0, maxChars - 3) + "..."
					}

					function CapturedTrace(ignoreUntil, isTopLevel) {
						this.captureStackTrace(ignoreUntil, isTopLevel)
					}
					var inherits = (require("./assert.js"), require("./util.js").inherits),
						defineProperty = require("./es5.js").defineProperty,
						rignore = new RegExp("\\b(?:[\\w.]*Promise(?:Array|Spawn)?\\$_\\w+|tryCatch(?:1|2|Apply)|new \\w*PromiseArray|\\w*PromiseArray\\.\\w*PromiseArray|setTimeout|CatchFilter\\$_\\w+|makeNodePromisified|processImmediate|process._tickCallback|nextTick|Async\\$\\w+)\\b"),
						rtraceline = null,
						formatStack = null,
						areNamesMangled = !1;
					inherits(CapturedTrace, Error);
					CapturedTrace.prototype.captureStackTrace = function (ignoreUntil, isTopLevel) {
						captureStackTrace(this, ignoreUntil, isTopLevel)
					};
					CapturedTrace.possiblyUnhandledRejection = function (reason) {
						if ("object" == typeof console) {
							var message;
							if ("object" == typeof reason || "function" == typeof reason) {
								var stack = reason.stack;
								message = "Possibly unhandled " + formatStack(stack, reason)
							} else message = "Possibly unhandled " + String(reason);
							"function" == typeof console.error || "object" == typeof console.error ? console.error(message) : ("function" == typeof console.log || "object" == typeof console.error) && console.log(message)
						}
					};
					areNamesMangled = "CapturedTrace$captureStackTrace" !== CapturedTrace.prototype.captureStackTrace.name;
					CapturedTrace.combine = function (current, prev) {
						for (var curLast = current.length - 1, i = prev.length - 1; i >= 0; --i) {
							var line = prev[i];
							if (current[curLast] !== line) break;
							current.pop();
							curLast--
						}
						current.push("From previous event:");
						for (var lines = current.concat(prev), ret = [], i = 0, len = lines.length; len > i; ++i) rignore.test(lines[i]) || i > 0 && !rtraceline.test(lines[i]) && "From previous event:" !== lines[i] || ret.push(lines[i]);
						return ret
					};
					CapturedTrace.isSupported = function () {
						return "function" == typeof captureStackTrace
					};
					var captureStackTrace = function stackDetection() {
						if ("number" == typeof Error.stackTraceLimit && "function" == typeof Error.captureStackTrace) {
							rtraceline = /^\s*at\s*/;
							formatStack = function (stack, error) {
								return "string" == typeof stack ? stack : void 0 !== error.name && void 0 !== error.message ? error.name + ". " + error.message : formatNonError(error)
							};
							var captureStackTrace = Error.captureStackTrace;
							return function (receiver, ignoreUntil) {
								captureStackTrace(receiver, ignoreUntil)
							}
						}
						var err = new Error;
						if (!areNamesMangled && "string" == typeof err.stack && "function" == typeof "".startsWith && err.stack.startsWith("stackDetection@") && "stackDetection" === stackDetection.name) {
							defineProperty(Error, "stackTraceLimit", {
								writable: !0,
								enumerable: !1,
								configurable: !1,
								value: 25
							});
							rtraceline = /@/;
							var rline = /[@\n]/;
							formatStack = function (stack, error) {
								return "string" == typeof stack ? error.name + ". " + error.message + "\n" + stack : void 0 !== error.name && void 0 !== error.message ? error.name + ". " + error.message : formatNonError(error)
							};
							return function (o, fn) {
								var i, name = fn.name,
									stack = (new Error).stack,
									split = stack.split(rline),
									len = split.length;
								for (i = 0; len > i && split[i] !== name; i += 2);
								split = split.slice(i + 2);
								len = split.length - 2;
								var ret = "";
								for (i = 0; len > i; i += 2) {
									ret += split[i];
									ret += "@";
									ret += split[i + 1];
									ret += "\n"
								}
								o.stack = ret
							}
						}
						formatStack = function (stack, error) {
							return "string" == typeof stack ? stack : "object" != typeof error && "function" != typeof error || void 0 === error.name || void 0 === error.message ? formatNonError(error) : error.name + ". " + error.message
						};
						return null
					}();
					return CapturedTrace
				}
			}, {
				"./assert.js": 2,
				"./es5.js": 12,
				"./util.js": 39
			}
		],
		8: [
			function (require, module) {
				"use strict";
				module.exports = function (NEXT_FILTER) {
					function CatchFilter(instances, callback, promise) {
						this._instances = instances;
						this._callback = callback;
						this._promise = promise
					}

					function CatchFilter$_safePredicate(predicate, e) {
						var safeObject = {},
							retfilter = tryCatch1(predicate, safeObject, e);
						if (retfilter === errorObj) return retfilter;
						var safeKeys = keys(safeObject);
						if (safeKeys.length) {
							errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function");
							return errorObj
						}
						return retfilter
					}
					var util = require("./util.js"),
						errors = require("./errors.js"),
						tryCatch1 = util.tryCatch1,
						errorObj = util.errorObj,
						keys = require("./es5.js").keys;
					CatchFilter.prototype.doFilter = function (e) {
						for (var cb = this._callback, promise = this._promise, boundTo = promise._isBound() ? promise._boundTo : void 0, i = 0, len = this._instances.length; len > i; ++i) {
							var item = this._instances[i],
								itemIsErrorType = item === Error || null != item && item.prototype instanceof Error;
							if (itemIsErrorType && e instanceof item) {
								var ret = tryCatch1(cb, boundTo, e);
								if (ret === errorObj) {
									NEXT_FILTER.e = ret.e;
									return NEXT_FILTER
								}
								return ret
							}
							if ("function" == typeof item && !itemIsErrorType) {
								var shouldHandle = CatchFilter$_safePredicate(item, e);
								if (shouldHandle === errorObj) {
									var trace = errors.canAttach(errorObj.e) ? errorObj.e : new Error(errorObj.e + "");
									this._promise._attachExtraTrace(trace);
									e = errorObj.e;
									break
								}
								if (shouldHandle) {
									var ret = tryCatch1(cb, boundTo, e);
									if (ret === errorObj) {
										NEXT_FILTER.e = ret.e;
										return NEXT_FILTER
									}
									return ret
								}
							}
						}
						NEXT_FILTER.e = e;
						return NEXT_FILTER
					};
					return CatchFilter
				}
			}, {
				"./errors.js": 10,
				"./es5.js": 12,
				"./util.js": 39
			}
		],
		9: [
			function (require, module) {
				"use strict";
				var util = require("./util.js"),
					isPrimitive = (require("./assert.js"), util.isPrimitive),
					wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
				module.exports = function (Promise) {
					var returner = function () {
							return this
						},
						thrower = function () {
							throw this
						},
						wrapper = function (value, action) {
							return 1 === action ? function () {
								throw value
							} : 2 === action ? function () {
								return value
							} : void 0
						};
					Promise.prototype["return"] = Promise.prototype.thenReturn = function (value) {
						return wrapsPrimitiveReceiver && isPrimitive(value) ? this._then(wrapper(value, 2), void 0, void 0, void 0, void 0, this.thenReturn) : this._then(returner, void 0, void 0, value, void 0, this.thenReturn)
					};
					Promise.prototype["throw"] = Promise.prototype.thenThrow = function (reason) {
						return wrapsPrimitiveReceiver && isPrimitive(reason) ? this._then(wrapper(reason, 1), void 0, void 0, void 0, void 0, this.thenThrow) : this._then(thrower, void 0, void 0, reason, void 0, this.thenThrow)
					}
				}
			}, {
				"./assert.js": 2,
				"./util.js": 39
			}
		],
		10: [
			function (require, module) {
				"use strict";

				function markAsOriginatingFromRejection(e) {
					try {
						notEnumerableProp(e, "isAsync", !0)
					} catch (ignore) {}
				}

				function originatesFromRejection(e) {
					return null == e ? !1 : e instanceof RejectionError || e.isAsync === !0
				}

				function isError(obj) {
					return obj instanceof Error
				}

				function canAttach(obj) {
					return isError(obj)
				}

				function subError(nameProperty, defaultMessage) {
					function SubError(message) {
						if (!(this instanceof SubError)) return new SubError(message);
						this.message = "string" == typeof message ? message : defaultMessage;
						this.name = nameProperty;
						Error.captureStackTrace && Error.captureStackTrace(this, this.constructor)
					}
					inherits(SubError, Error);
					return SubError
				}

				function RejectionError(message) {
					this.name = "RejectionError";
					this.message = message;
					this.cause = message;
					this.isAsync = !0;
					if (message instanceof Error) {
						this.message = message.message;
						this.stack = message.stack
					} else Error.captureStackTrace && Error.captureStackTrace(this, this.constructor)
				}
				var global = require("./global.js"),
					Objectfreeze = require("./es5.js").freeze,
					util = require("./util.js"),
					inherits = util.inherits,
					notEnumerableProp = util.notEnumerableProp,
					Error = global.Error,
					TypeError = global.TypeError;
				"function" != typeof TypeError && (TypeError = subError("TypeError", "type error"));
				var RangeError = global.RangeError;
				"function" != typeof RangeError && (RangeError = subError("RangeError", "range error"));
				var CancellationError = subError("CancellationError", "cancellation error"),
					TimeoutError = subError("TimeoutError", "timeout error");
				inherits(RejectionError, Error);
				var key = "__BluebirdErrorTypes__",
					errorTypes = global[key];
				if (!errorTypes) {
					errorTypes = Objectfreeze({
						CancellationError: CancellationError,
						TimeoutError: TimeoutError,
						RejectionError: RejectionError
					});
					notEnumerableProp(global, key, errorTypes)
				}
				module.exports = {
					Error: Error,
					TypeError: TypeError,
					RangeError: RangeError,
					CancellationError: errorTypes.CancellationError,
					RejectionError: errorTypes.RejectionError,
					TimeoutError: errorTypes.TimeoutError,
					originatesFromRejection: originatesFromRejection,
					markAsOriginatingFromRejection: markAsOriginatingFromRejection,
					canAttach: canAttach
				}
			}, {
				"./es5.js": 12,
				"./global.js": 16,
				"./util.js": 39
			}
		],
		11: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise) {
					function apiRejection(msg) {
						var error = new TypeError(msg),
							ret = Promise.rejected(error),
							parent = ret._peekContext();
						null != parent && parent._attachExtraTrace(error);
						return ret
					}
					var TypeError = require("./errors.js").TypeError;
					return apiRejection
				}
			}, {
				"./errors.js": 10
			}
		],
		12: [
			function (require, module) {
				function ObjectKeys(o) {
					var ret = [];
					for (var key in o) has.call(o, key) && ret.push(key);
					return ret
				}

				function ObjectDefineProperty(o, key, desc) {
					o[key] = desc.value;
					return o
				}

				function ObjectFreeze(obj) {
					return obj
				}

				function ObjectGetPrototypeOf(obj) {
					try {
						return Object(obj).constructor.prototype
					} catch (e) {
						return proto
					}
				}

				function ArrayIsArray(obj) {
					try {
						return "[object Array]" === str.call(obj)
					} catch (e) {
						return !1
					}
				}
				var isES5 = function () {
					"use strict";
					return void 0 === this
				}();
				if (isES5) module.exports = {
					freeze: Object.freeze,
					defineProperty: Object.defineProperty,
					keys: Object.keys,
					getPrototypeOf: Object.getPrototypeOf,
					isArray: Array.isArray,
					isES5: isES5
				};
				else {
					var has = {}.hasOwnProperty,
						str = {}.toString,
						proto = {}.constructor.prototype;
					module.exports = {
						isArray: ArrayIsArray,
						keys: ObjectKeys,
						defineProperty: ObjectDefineProperty,
						freeze: ObjectFreeze,
						getPrototypeOf: ObjectGetPrototypeOf,
						isES5: isES5
					}
				}
			}, {}
		],
		13: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise) {
					function Promise$_filter(booleans) {
						for (var values = this._settledValue, len = values.length, ret = new Array(len), j = 0, i = 0; len > i; ++i) booleans[i] && (ret[j++] = values[i]);
						ret.length = j;
						return ret
					}
					var ref = (require("./assert.js"), require("./util.js").isArray, {
						ref: null
					});
					Promise.filter = function (promises, fn) {
						return Promise.map(promises, fn, ref)._then(Promise$_filter, void 0, void 0, ref.ref, void 0, Promise.filter)
					};
					Promise.prototype.filter = function (fn) {
						return this.map(fn, ref)._then(Promise$_filter, void 0, void 0, ref.ref, void 0, this.filter)
					}
				}
			}, {
				"./assert.js": 2,
				"./util.js": 39
			}
		],
		14: [
			function (require, module) {
				module.exports = function (Promise, NEXT_FILTER) {
					function returnThis() {
						return this
					}

					function throwThis() {
						throw this
					}

					function makeReturner(r) {
						return function () {
							return r
						}
					}

					function makeThrower(r) {
						return function () {
							throw r
						}
					}

					function promisedFinally(ret, reasonOrValue, isFulfilled) {
						var useConstantFunction = wrapsPrimitiveReceiver && isPrimitive(reasonOrValue);
						return isFulfilled ? ret._then(useConstantFunction ? returnThis : makeReturner(reasonOrValue), thrower, void 0, reasonOrValue, void 0, promisedFinally) : ret._then(useConstantFunction ? throwThis : makeThrower(reasonOrValue), thrower, void 0, reasonOrValue, void 0, promisedFinally)
					}

					function finallyHandler(reasonOrValue) {
						var promise = this.promise,
							handler = this.handler,
							ret = promise._isBound() ? handler.call(promise._boundTo) : handler();
						if (void 0 !== ret) {
							var maybePromise = Promise._cast(ret, finallyHandler, void 0);
							if (Promise.is(maybePromise)) return promisedFinally(maybePromise, reasonOrValue, promise.isFulfilled())
						}
						if (promise.isRejected()) {
							NEXT_FILTER.e = reasonOrValue;
							return NEXT_FILTER
						}
						return reasonOrValue
					}
					var util = require("./util.js"),
						wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver,
						isPrimitive = util.isPrimitive,
						thrower = util.thrower;
					Promise.prototype.lastly = Promise.prototype["finally"] = function (handler) {
						if ("function" != typeof handler) return this.then();
						var promiseAndHandler = {
							promise: this,
							handler: handler
						};
						return this._then(finallyHandler, finallyHandler, void 0, promiseAndHandler, void 0, this.lastly)
					}
				}
			}, {
				"./util.js": 39
			}
		],
		15: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, apiRejection, INTERNAL) {
					var PromiseSpawn = require("./promise_spawn.js")(Promise, INTERNAL),
						errors = require("./errors.js"),
						TypeError = errors.TypeError;
					Promise.coroutine = function (generatorFunction) {
						if ("function" != typeof generatorFunction) throw new TypeError("generatorFunction must be a function");
						var PromiseSpawn$ = PromiseSpawn;
						return function anonymous() {
							var generator = generatorFunction.apply(this, arguments),
								spawn = new PromiseSpawn$(void 0, void 0, anonymous);
							spawn._generator = generator;
							spawn._next(void 0);
							return spawn.promise()
						}
					};
					Promise.spawn = function (generatorFunction) {
						if ("function" != typeof generatorFunction) return apiRejection("generatorFunction must be a function");
						var spawn = new PromiseSpawn(generatorFunction, this, Promise.spawn),
							ret = spawn.promise();
						spawn._run(Promise.spawn);
						return ret
					}
				}
			}, {
				"./errors.js": 10,
				"./promise_spawn.js": 24
			}
		],
		16: [
			function (require, module) {
				"use strict";
				module.exports = function () {
					return "undefined" != typeof this ? this : "undefined" != typeof process && "undefined" != typeof global && "string" == typeof process.execPath ? global : "undefined" != typeof window && "undefined" != typeof document && "undefined" != typeof navigator && null !== navigator && "string" == typeof navigator.appName ? void 0 !== window.wrappedJSObject ? window.wrappedJSObject : window : void 0
				}()
			}, {}
		],
		17: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, Promise$_CreatePromiseArray, PromiseArray, apiRejection) {
					function Promise$_mapper(values) {
						var fn = this,
							receiver = void 0;
						if ("function" != typeof fn) {
							receiver = fn.receiver;
							fn = fn.fn
						}
						var shouldDefer = !1,
							ret = new Array(values.length);
						if (void 0 === receiver)
							for (var i = 0, len = values.length; len > i; ++i) {
								var value = fn(values[i], i, len);
								if (!shouldDefer) {
									var maybePromise = Promise._cast(value, Promise$_mapper, void 0);
									if (maybePromise instanceof Promise) {
										if (maybePromise.isFulfilled()) {
											ret[i] = maybePromise._settledValue;
											continue
										}
										shouldDefer = !0;
										value = maybePromise
									}
								}
								ret[i] = value
							} else
								for (var i = 0, len = values.length; len > i; ++i) {
									var value = fn.call(receiver, values[i], i, len);
									if (!shouldDefer) {
										var maybePromise = Promise._cast(value, Promise$_mapper, void 0);
										if (maybePromise instanceof Promise) {
											if (maybePromise.isFulfilled()) {
												ret[i] = maybePromise._settledValue;
												continue
											}
											shouldDefer = !0;
											value = maybePromise
										}
									}
									ret[i] = value
								}
						return shouldDefer ? Promise$_CreatePromiseArray(ret, PromiseArray, Promise$_mapper, void 0).promise() : ret
					}

					function Promise$_Map(promises, fn, useBound, caller, ref) {
						if ("function" != typeof fn) return apiRejection("fn must be a function");
						useBound === !0 && promises._isBound() && (fn = {
							fn: fn,
							receiver: promises._boundTo
						});
						var ret = Promise$_CreatePromiseArray(promises, PromiseArray, caller, useBound === !0 && promises._isBound() ? promises._boundTo : void 0).promise();
						void 0 !== ref && (ref.ref = ret);
						return ret._then(Promise$_mapper, void 0, void 0, fn, void 0, caller)
					}
					require("./assert.js");
					Promise.prototype.map = function (fn, ref) {
						return Promise$_Map(this, fn, !0, this.map, ref)
					};
					Promise.map = function (promises, fn, ref) {
						return Promise$_Map(promises, fn, !1, Promise.map, ref)
					}
				}
			}, {
				"./assert.js": 2
			}
		],
		18: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise) {
					function thrower(r) {
						throw r
					}

					function Promise$_successAdapter(val, receiver) {
						var nodeback = this,
							ret = tryCatch2(nodeback, receiver, null, val);
						ret === errorObj && async.invokeLater(thrower, void 0, ret.e)
					}

					function Promise$_errorAdapter(reason, receiver) {
						var nodeback = this,
							ret = tryCatch1(nodeback, receiver, reason);
						ret === errorObj && async.invokeLater(thrower, void 0, ret.e)
					}
					var util = require("./util.js"),
						async = require("./async.js"),
						tryCatch2 = (require("./assert.js"), util.tryCatch2),
						tryCatch1 = util.tryCatch1,
						errorObj = util.errorObj;
					Promise.prototype.nodeify = function (nodeback) {
						"function" == typeof nodeback && this._then(Promise$_successAdapter, Promise$_errorAdapter, void 0, nodeback, this._isBound() ? this._boundTo : null, this.nodeify);
						return this
					}
				}
			}, {
				"./assert.js": 2,
				"./async.js": 3,
				"./util.js": 39
			}
		],
		19: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, isPromiseArrayProxy) {
					var util = (require("./assert.js"), require("./util.js")),
						async = require("./async.js"),
						errors = require("./errors.js"),
						tryCatch1 = util.tryCatch1,
						errorObj = util.errorObj;
					Promise.prototype.progressed = function (handler) {
						return this._then(void 0, void 0, handler, void 0, void 0, this.progressed)
					};
					Promise.prototype._progress = function (progressValue) {
						this._isFollowingOrFulfilledOrRejected() || this._progressUnchecked(progressValue)
					};
					Promise.prototype._progressHandlerAt = function (index) {
						return 0 === index ? this._progressHandler0 : this[index + 2 - 5]
					};
					Promise.prototype._doProgressWith = function (progression) {
						var progressValue = progression.value,
							handler = progression.handler,
							promise = progression.promise,
							receiver = progression.receiver;
						this._pushContext();
						var ret = tryCatch1(handler, receiver, progressValue);
						this._popContext();
						if (ret === errorObj) {
							if (null != ret.e && "StopProgressPropagation" !== ret.e.name) {
								var trace = errors.canAttach(ret.e) ? ret.e : new Error(ret.e + "");
								promise._attachExtraTrace(trace);
								promise._progress(ret.e)
							}
						} else Promise.is(ret) ? ret._then(promise._progress, null, null, promise, void 0, this._progress) : promise._progress(ret)
					};
					Promise.prototype._progressUnchecked = function (progressValue) {
						if (this.isPending())
							for (var len = this._length(), i = 0; len > i; i += 5) {
								var handler = this._progressHandlerAt(i),
									promise = this._promiseAt(i);
								if (Promise.is(promise)) "function" == typeof handler ? async.invoke(this._doProgressWith, this, {
									handler: handler,
									promise: promise,
									receiver: this._receiverAt(i),
									value: progressValue
								}) : async.invoke(promise._progress, promise, progressValue);
								else {
									var receiver = this._receiverAt(i);
									"function" == typeof handler ? handler.call(receiver, progressValue, promise) : Promise.is(receiver) && receiver._isProxied() ? receiver._progressUnchecked(progressValue) : isPromiseArrayProxy(receiver, promise) && receiver._promiseProgressed(progressValue, promise)
								}
							}
					}
				}
			}, {
				"./assert.js": 2,
				"./async.js": 3,
				"./errors.js": 10,
				"./util.js": 39
			}
		],
		20: [
			function (require, module) {
				"use strict";
				module.exports = function () {
					function isPromise(obj) {
						return void 0 === obj ? !1 : obj instanceof Promise
					}

					function isPromiseArrayProxy(receiver, promiseSlotValue) {
						return receiver instanceof PromiseArray ? promiseSlotValue >= 0 : !1
					}

					function Promise(resolver) {
						if ("function" != typeof resolver) throw new TypeError("the promise constructor requires a resolver function");
						if (this.constructor !== Promise) throw new TypeError("the promise constructor cannot be invoked directly");
						this._bitField = 0;
						this._fulfillmentHandler0 = void 0;
						this._rejectionHandler0 = void 0;
						this._promise0 = void 0;
						this._receiver0 = void 0;
						this._settledValue = void 0;
						this._boundTo = void 0;
						resolver !== INTERNAL && this._resolveFromResolver(resolver)
					}

					function Promise$_all(promises, useBound, caller) {
						return Promise$_CreatePromiseArray(promises, PromiseArray, caller, useBound === !0 && promises._isBound() ? promises._boundTo : void 0).promise()
					}

					function Promise$_CreatePromiseArray(promises, PromiseArrayConstructor, caller, boundTo) {
						var list = null;
						if (isArray(promises)) list = promises;
						else {
							list = Promise._cast(promises, caller, void 0);
							list !== promises ? list._setBoundTo(boundTo) : isPromise(list) || (list = null)
						}
						return null !== list ? new PromiseArrayConstructor(list, "function" == typeof caller ? caller : Promise$_CreatePromiseArray, boundTo) : {
							promise: function () {
								return apiRejection("expecting an array, a promise or a thenable")
							}
						}
					}
					var global = require("./global.js"),
						util = (require("./assert.js"), require("./util.js")),
						async = require("./async.js"),
						errors = require("./errors.js"),
						INTERNAL = function () {},
						APPLY = {},
						NEXT_FILTER = {
							e: null
						},
						PromiseArray = require("./promise_array.js")(Promise, INTERNAL),
						CapturedTrace = require("./captured_trace.js")(),
						CatchFilter = require("./catch_filter.js")(NEXT_FILTER),
						PromiseResolver = require("./promise_resolver.js"),
						isArray = util.isArray,
						errorObj = util.errorObj,
						tryCatch1 = util.tryCatch1,
						tryCatch2 = util.tryCatch2,
						tryCatchApply = util.tryCatchApply,
						RangeError = errors.RangeError,
						TypeError = errors.TypeError,
						CancellationError = errors.CancellationError,
						TimeoutError = errors.TimeoutError,
						RejectionError = errors.RejectionError,
						originatesFromRejection = errors.originatesFromRejection,
						markAsOriginatingFromRejection = errors.markAsOriginatingFromRejection,
						canAttach = errors.canAttach,
						thrower = util.thrower,
						apiRejection = require("./errors_api_rejection")(Promise),
						makeSelfResolutionError = function () {
							return new TypeError("circular promise resolution chain")
						};
					Promise.prototype.bind = function (thisArg) {
						var ret = new Promise(INTERNAL);
						debugging && ret._setTrace(this.bind, this);
						ret._follow(this);
						ret._setBoundTo(thisArg);
						if (this._cancellable()) {
							ret._setCancellable();
							ret._cancellationParent = this
						}
						return ret
					};
					Promise.prototype.toString = function () {
						return "[object Promise]"
					};
					Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
						var len = arguments.length;
						if (len > 1) {
							var i, catchInstances = new Array(len - 1),
								j = 0;
							for (i = 0; len - 1 > i; ++i) {
								var item = arguments[i];
								if ("function" != typeof item) {
									var catchFilterTypeError = new TypeError("A catch filter must be an error constructor or a filter function");
									this._attachExtraTrace(catchFilterTypeError);
									async.invoke(this._reject, this, catchFilterTypeError);
									return
								}
								catchInstances[j++] = item
							}
							catchInstances.length = j;
							fn = arguments[i];
							this._resetTrace(this.caught);
							var catchFilter = new CatchFilter(catchInstances, fn, this);
							return this._then(void 0, catchFilter.doFilter, void 0, catchFilter, void 0, this.caught)
						}
						return this._then(void 0, fn, void 0, void 0, void 0, this.caught)
					};
					Promise.prototype.then = function (didFulfill, didReject, didProgress) {
						return this._then(didFulfill, didReject, didProgress, void 0, void 0, this.then)
					};
					Promise.prototype.done = function (didFulfill, didReject, didProgress) {
						var promise = this._then(didFulfill, didReject, didProgress, void 0, void 0, this.done);
						promise._setIsFinal()
					};
					Promise.prototype.spread = function (didFulfill, didReject) {
						return this._then(didFulfill, didReject, void 0, APPLY, void 0, this.spread)
					};
					Promise.prototype.isFulfilled = function () {
						return (268435456 & this._bitField) > 0
					};
					Promise.prototype.isRejected = function () {
						return (134217728 & this._bitField) > 0
					};
					Promise.prototype.isPending = function () {
						return !this.isResolved()
					};
					Promise.prototype.isResolved = function () {
						return (402653184 & this._bitField) > 0
					};
					Promise.prototype.isCancellable = function () {
						return !this.isResolved() && this._cancellable()
					};
					Promise.prototype.toJSON = function () {
						var ret = {
							isFulfilled: !1,
							isRejected: !1,
							fulfillmentValue: void 0,
							rejectionReason: void 0
						};
						if (this.isFulfilled()) {
							ret.fulfillmentValue = this._settledValue;
							ret.isFulfilled = !0
						} else if (this.isRejected()) {
							ret.rejectionReason = this._settledValue;
							ret.isRejected = !0
						}
						return ret
					};
					Promise.prototype.all = function () {
						return Promise$_all(this, !0, this.all)
					};
					Promise.is = isPromise;
					Promise.all = function (promises) {
						return Promise$_all(promises, !1, Promise.all)
					};
					Promise.join = function () {
						for (var $_len = arguments.length, args = new Array($_len), $_i = 0; $_len > $_i; ++$_i) args[$_i] = arguments[$_i];
						return Promise$_CreatePromiseArray(args, PromiseArray, Promise.join, void 0).promise()
					};
					Promise.resolve = Promise.fulfilled = function (value, caller) {
						var ret = new Promise(INTERNAL);
						debugging && ret._setTrace("function" == typeof caller ? caller : Promise.resolve, void 0);
						if (ret._tryFollow(value)) return ret;
						ret._cleanValues();
						ret._setFulfilled();
						ret._settledValue = value;
						return ret
					};
					Promise.reject = Promise.rejected = function (reason) {
						var ret = new Promise(INTERNAL);
						debugging && ret._setTrace(Promise.reject, void 0);
						markAsOriginatingFromRejection(reason);
						ret._cleanValues();
						ret._setRejected();
						ret._settledValue = reason;
						if (!canAttach(reason)) {
							var trace = new Error(reason + "");
							ret._setCarriedStackTrace(trace)
						}
						ret._ensurePossibleRejectionHandled();
						return ret
					};
					Promise.prototype.error = function (fn) {
						return this.caught(originatesFromRejection, fn)
					};
					Promise.prototype._resolveFromSyncValue = function (value, caller) {
						if (value === errorObj) {
							this._cleanValues();
							this._setRejected();
							this._settledValue = value.e;
							this._ensurePossibleRejectionHandled()
						} else {
							var maybePromise = Promise._cast(value, caller, void 0);
							if (maybePromise instanceof Promise) this._follow(maybePromise);
							else {
								this._cleanValues();
								this._setFulfilled();
								this._settledValue = value
							}
						}
					};
					Promise.method = function (fn) {
						if ("function" != typeof fn) throw new TypeError("fn must be a function");
						return function Promise$_method() {
							var value;
							switch (arguments.length) {
							case 0:
								value = tryCatch1(fn, this, void 0);
								break;
							case 1:
								value = tryCatch1(fn, this, arguments[0]);
								break;
							case 2:
								value = tryCatch2(fn, this, arguments[0], arguments[1]);
								break;
							default:
								for (var $_len = arguments.length, args = new Array($_len), $_i = 0; $_len > $_i; ++$_i) args[$_i] = arguments[$_i];
								value = tryCatchApply(fn, args, this)
							}
							var ret = new Promise(INTERNAL);
							debugging && ret._setTrace(Promise$_method, void 0);
							ret._resolveFromSyncValue(value, Promise$_method);
							return ret
						}
					};
					Promise.attempt = Promise["try"] = function (fn, args, ctx) {
						if ("function" != typeof fn) return apiRejection("fn must be a function");
						var value = isArray(args) ? tryCatchApply(fn, args, ctx) : tryCatch1(fn, ctx, args),
							ret = new Promise(INTERNAL);
						debugging && ret._setTrace(Promise.attempt, void 0);
						ret._resolveFromSyncValue(value, Promise.attempt);
						return ret
					};
					Promise.defer = Promise.pending = function (caller) {
						var promise = new Promise(INTERNAL);
						debugging && promise._setTrace("function" == typeof caller ? caller : Promise.defer, void 0);
						return new PromiseResolver(promise)
					};
					Promise.bind = function (thisArg) {
						var ret = new Promise(INTERNAL);
						debugging && ret._setTrace(Promise.bind, void 0);
						ret._setFulfilled();
						ret._setBoundTo(thisArg);
						return ret
					};
					Promise.cast = function (obj, caller) {
						"function" != typeof caller && (caller = Promise.cast);
						var ret = Promise._cast(obj, caller, void 0);
						return ret instanceof Promise ? ret : Promise.resolve(ret, caller)
					};
					Promise.onPossiblyUnhandledRejection = function (fn) {
						CapturedTrace.possiblyUnhandledRejection = "function" == typeof fn ? fn : void 0
					};
					var debugging = !1 || !("undefined" == typeof process || "string" != typeof process.execPath || "object" != typeof process.env || !process.env.BLUEBIRD_DEBUG && "development" !== process.env.NODE_ENV);
					Promise.longStackTraces = function () {
						if (async.haveItemsQueued() && debugging === !1) throw new Error("cannot enable long stack traces after promises have been created");
						debugging = CapturedTrace.isSupported()
					};
					Promise.hasLongStackTraces = function () {
						return debugging && CapturedTrace.isSupported()
					};
					Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
						var index = this._length();
						if (index >= 1048570) {
							index = 0;
							this._setLength(0)
						}
						if (0 === index) {
							this._promise0 = promiseSlotValue;
							this._receiver0 = receiver
						} else {
							var i = index - 5;
							this[i + 3] = promiseSlotValue;
							this[i + 4] = receiver;
							this[i + 0] = this[i + 1] = this[i + 2] = void 0
						}
						this._setLength(index + 5)
					};
					Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
						this._setProxyHandlers(promiseArray, index)
					};
					Promise.prototype._proxyPromise = function (promise) {
						promise._setProxied();
						this._setProxyHandlers(promise, -1)
					};
					Promise.prototype._then = function (didFulfill, didReject, didProgress, receiver, internalData, caller) {
						var haveInternalData = void 0 !== internalData,
							ret = haveInternalData ? internalData : new Promise(INTERNAL);
						if (debugging && !haveInternalData) {
							var haveSameContext = this._peekContext() === this._traceParent;
							ret._traceParent = haveSameContext ? this._traceParent : this;
							ret._setTrace("function" == typeof caller ? caller : this._then, this)
						}!haveInternalData && this._isBound() && ret._setBoundTo(this._boundTo);
						var callbackIndex = this._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);
						if (!haveInternalData && this._cancellable()) {
							ret._setCancellable();
							ret._cancellationParent = this
						}
						this.isResolved() && async.invoke(this._queueSettleAt, this, callbackIndex);
						return ret
					};
					Promise.prototype._length = function () {
						return 1048575 & this._bitField
					};
					Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
						return (939524096 & this._bitField) > 0
					};
					Promise.prototype._isFollowing = function () {
						return 536870912 === (536870912 & this._bitField)
					};
					Promise.prototype._setLength = function (len) {
						this._bitField = -1048576 & this._bitField | 1048575 & len
					};
					Promise.prototype._setFulfilled = function () {
						this._bitField = 268435456 | this._bitField
					};
					Promise.prototype._setRejected = function () {
						this._bitField = 134217728 | this._bitField
					};
					Promise.prototype._setFollowing = function () {
						this._bitField = 536870912 | this._bitField
					};
					Promise.prototype._setIsFinal = function () {
						this._bitField = 33554432 | this._bitField
					};
					Promise.prototype._isFinal = function () {
						return (33554432 & this._bitField) > 0
					};
					Promise.prototype._cancellable = function () {
						return (67108864 & this._bitField) > 0
					};
					Promise.prototype._setCancellable = function () {
						this._bitField = 67108864 | this._bitField
					};
					Promise.prototype._unsetCancellable = function () {
						this._bitField = -67108865 & this._bitField
					};
					Promise.prototype._setRejectionIsUnhandled = function () {
						this._bitField = 2097152 | this._bitField
					};
					Promise.prototype._unsetRejectionIsUnhandled = function () {
						this._bitField = -2097153 & this._bitField
					};
					Promise.prototype._isRejectionUnhandled = function () {
						return (2097152 & this._bitField) > 0
					};
					Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
						this._bitField = 1048576 | this._bitField;
						this._fulfillmentHandler0 = capturedTrace
					};
					Promise.prototype._unsetCarriedStackTrace = function () {
						this._bitField = -1048577 & this._bitField;
						this._fulfillmentHandler0 = void 0
					};
					Promise.prototype._isCarryingStackTrace = function () {
						return (1048576 & this._bitField) > 0
					};
					Promise.prototype._getCarriedStackTrace = function () {
						return this._isCarryingStackTrace() ? this._fulfillmentHandler0 : void 0
					};
					Promise.prototype._receiverAt = function (index) {
						var ret;
						ret = 0 === index ? this._receiver0 : this[index + 4 - 5];
						return this._isBound() && void 0 === ret ? this._boundTo : ret
					};
					Promise.prototype._promiseAt = function (index) {
						return 0 === index ? this._promise0 : this[index + 3 - 5]
					};
					Promise.prototype._fulfillmentHandlerAt = function (index) {
						return 0 === index ? this._fulfillmentHandler0 : this[index + 0 - 5]
					};
					Promise.prototype._rejectionHandlerAt = function (index) {
						return 0 === index ? this._rejectionHandler0 : this[index + 1 - 5]
					};
					Promise.prototype._unsetAt = function (index) {
						if (0 === index) {
							this._rejectionHandler0 = this._progressHandler0 = this._promise0 = this._receiver0 = void 0;
							this._isCarryingStackTrace() || (this._fulfillmentHandler0 = void 0)
						} else this[index - 5 + 0] = this[index - 5 + 1] = this[index - 5 + 2] = this[index - 5 + 3] = this[index - 5 + 4] = void 0
					};
					Promise.prototype._resolveFromResolver = function (resolver) {
						function Promise$_resolver(val) {
							promise._tryFollow(val) || promise._fulfill(val)
						}

						function Promise$_rejecter(val) {
							var trace = canAttach(val) ? val : new Error(val + "");
							promise._attachExtraTrace(trace);
							markAsOriginatingFromRejection(val);
							promise._reject(val, trace === val ? void 0 : trace)
						}
						var promise = this,
							localDebugging = debugging;
						if (localDebugging) {
							this._setTrace(this._resolveFromResolver, void 0);
							this._pushContext()
						}
						var r = tryCatch2(resolver, void 0, Promise$_resolver, Promise$_rejecter);
						localDebugging && this._popContext();
						if (void 0 !== r && r === errorObj) {
							var trace = canAttach(r.e) ? r.e : new Error(r.e + "");
							promise._reject(r.e, trace)
						}
					};
					Promise.prototype._addCallbacks = function (fulfill, reject, progress, promise, receiver) {
						var index = this._length();
						if (index >= 1048570) {
							index = 0;
							this._setLength(0)
						}
						if (0 === index) {
							this._promise0 = promise;
							void 0 !== receiver && (this._receiver0 = receiver);
							"function" != typeof fulfill || this._isCarryingStackTrace() || (this._fulfillmentHandler0 = fulfill);
							"function" == typeof reject && (this._rejectionHandler0 = reject);
							"function" == typeof progress && (this._progressHandler0 = progress)
						} else {
							var i = index - 5;
							this[i + 3] = promise;
							this[i + 4] = receiver;
							this[i + 0] = "function" == typeof fulfill ? fulfill : void 0;
							this[i + 1] = "function" == typeof reject ? reject : void 0;
							this[i + 2] = "function" == typeof progress ? progress : void 0
						}
						this._setLength(index + 5);
						return index
					};
					Promise.prototype._setBoundTo = function (obj) {
						if (void 0 !== obj) {
							this._bitField = 8388608 | this._bitField;
							this._boundTo = obj
						} else this._bitField = -8388609 & this._bitField
					};
					Promise.prototype._isBound = function () {
						return 8388608 === (8388608 & this._bitField)
					};
					Promise.prototype._spreadSlowCase = function (targetFn, promise, values, boundTo) {
						var promiseForAll = Promise$_CreatePromiseArray(values, PromiseArray, this._spreadSlowCase, boundTo).promise()._then(function () {
							return targetFn.apply(boundTo, arguments)
						}, void 0, void 0, APPLY, void 0, this._spreadSlowCase);
						promise._follow(promiseForAll)
					};
					Promise.prototype._callSpread = function (handler, promise, value, localDebugging) {
						var boundTo = this._isBound() ? this._boundTo : void 0;
						if (isArray(value))
							for (var caller = this._settlePromiseFromHandler, i = 0, len = value.length; len > i; ++i)
								if (isPromise(Promise._cast(value[i], caller, void 0))) {
									this._spreadSlowCase(handler, promise, value, boundTo);
									return
								}
						localDebugging && promise._pushContext();
						return tryCatchApply(handler, value, boundTo)
					};
					Promise.prototype._callHandler = function (handler, receiver, promise, value, localDebugging) {
						var x;
						if (receiver !== APPLY || this.isRejected()) {
							localDebugging && promise._pushContext();
							x = tryCatch1(handler, receiver, value)
						} else x = this._callSpread(handler, promise, value, localDebugging);
						localDebugging && promise._popContext();
						return x
					};
					Promise.prototype._settlePromiseFromHandler = function (handler, receiver, value, promise) {
						if (isPromise(promise)) {
							var localDebugging = debugging,
								x = this._callHandler(handler, receiver, promise, value, localDebugging);
							if (!promise._isFollowing())
								if (x === errorObj || x === promise || x === NEXT_FILTER) {
									var err = x === promise ? makeSelfResolutionError() : x.e,
										trace = canAttach(err) ? err : new Error(err + "");
									x !== NEXT_FILTER && promise._attachExtraTrace(trace);
									promise._rejectUnchecked(err, trace)
								} else {
									var castValue = Promise._cast(x, localDebugging ? this._settlePromiseFromHandler : void 0, promise);
									if (isPromise(castValue)) {
										if (castValue.isRejected() && !castValue._isCarryingStackTrace() && !canAttach(castValue._settledValue)) {
											var trace = new Error(castValue._settledValue + "");
											promise._attachExtraTrace(trace);
											castValue._setCarriedStackTrace(trace)
										}
										promise._follow(castValue);
										if (castValue._cancellable()) {
											promise._cancellationParent = castValue;
											promise._setCancellable()
										}
									} else promise._fulfillUnchecked(x)
								}
						} else handler.call(receiver, value, promise)
					};
					Promise.prototype._follow = function (promise) {
						this._setFollowing();
						if (promise.isPending()) {
							if (promise._cancellable()) {
								this._cancellationParent = promise;
								this._setCancellable()
							}
							promise._proxyPromise(this)
						} else promise.isFulfilled() ? this._fulfillUnchecked(promise._settledValue) : this._rejectUnchecked(promise._settledValue, promise._getCarriedStackTrace());
						debugging && null == promise._traceParent && (promise._traceParent = this)
					};
					Promise.prototype._tryFollow = function (value) {
						if (this._isFollowingOrFulfilledOrRejected() || value === this) return !1;
						var maybePromise = Promise._cast(value, this._tryFollow, void 0);
						if (!isPromise(maybePromise)) return !1;
						this._follow(maybePromise);
						return !0
					};
					Promise.prototype._resetTrace = function (caller) {
						if (debugging) {
							var context = this._peekContext(),
								isTopLevel = void 0 === context;
							this._trace = new CapturedTrace("function" == typeof caller ? caller : this._resetTrace, isTopLevel)
						}
					};
					Promise.prototype._setTrace = function (caller, parent) {
						if (debugging) {
							var context = this._peekContext();
							this._traceParent = context;
							var isTopLevel = void 0 === context;
							this._trace = void 0 !== parent && parent._traceParent === context ? parent._trace : new CapturedTrace("function" == typeof caller ? caller : this._setTrace, isTopLevel)
						}
						return this
					};
					Promise.prototype._attachExtraTrace = function (error) {
						if (debugging) {
							var promise = this,
								stack = error.stack;
							stack = "string" == typeof stack ? stack.split("\n") : [];
							for (var headerLineCount = 1; null != promise && null != promise._trace;) {
								stack = CapturedTrace.combine(stack, promise._trace.stack.split("\n"));
								promise = promise._traceParent
							}
							var max = Error.stackTraceLimit + headerLineCount,
								len = stack.length;
							len > max && (stack.length = max);
							error.stack = stack.length <= headerLineCount ? "(No stack trace)" : stack.join("\n")
						}
					};
					Promise.prototype._cleanValues = function () {
						this._cancellable() && (this._cancellationParent = void 0)
					};
					Promise.prototype._fulfill = function (value) {
						this._isFollowingOrFulfilledOrRejected() || this._fulfillUnchecked(value)
					};
					Promise.prototype._reject = function (reason, carriedStackTrace) {
						this._isFollowingOrFulfilledOrRejected() || this._rejectUnchecked(reason, carriedStackTrace)
					};
					Promise.prototype._settlePromiseAt = function (index) {
						var handler = this.isFulfilled() ? this._fulfillmentHandlerAt(index) : this._rejectionHandlerAt(index),
							value = this._settledValue,
							receiver = this._receiverAt(index),
							promise = this._promiseAt(index);
						if ("function" == typeof handler) this._settlePromiseFromHandler(handler, receiver, value, promise);
						else {
							var done = !1,
								isFulfilled = this.isFulfilled();
							if (void 0 !== receiver)
								if (receiver instanceof Promise && receiver._isProxied()) {
									receiver._unsetProxied();
									isFulfilled ? receiver._fulfillUnchecked(value) : receiver._rejectUnchecked(value, this._getCarriedStackTrace());
									done = !0
								} else if (isPromiseArrayProxy(receiver, promise)) {
								isFulfilled ? receiver._promiseFulfilled(value, promise) : receiver._promiseRejected(value, promise);
								done = !0
							}
							done || (isFulfilled ? promise._fulfill(value) : promise._reject(value, this._getCarriedStackTrace()))
						}
						index >= 256 && this._queueGC()
					};
					Promise.prototype._isProxied = function () {
						return 4194304 === (4194304 & this._bitField)
					};
					Promise.prototype._setProxied = function () {
						this._bitField = 4194304 | this._bitField
					};
					Promise.prototype._unsetProxied = function () {
						this._bitField = -4194305 & this._bitField
					};
					Promise.prototype._isGcQueued = function () {
						return -1073741824 === (-1073741824 & this._bitField)
					};
					Promise.prototype._setGcQueued = function () {
						this._bitField = -1073741824 | this._bitField
					};
					Promise.prototype._unsetGcQueued = function () {
						this._bitField = 1073741823 & this._bitField
					};
					Promise.prototype._queueGC = function () {
						if (!this._isGcQueued()) {
							this._setGcQueued();
							async.invokeLater(this._gc, this, void 0)
						}
					};
					Promise.prototype._gc = function () {
						var len = this._length();
						this._unsetAt(0);
						for (var i = 0; len > i; i++) delete this[i];
						this._setLength(0);
						this._unsetGcQueued()
					};
					Promise.prototype._queueSettleAt = function (index) {
						this._isRejectionUnhandled() && this._unsetRejectionIsUnhandled();
						async.invoke(this._settlePromiseAt, this, index)
					};
					Promise.prototype._fulfillUnchecked = function (value) {
						if (this.isPending()) {
							if (value === this) {
								var err = makeSelfResolutionError();
								this._attachExtraTrace(err);
								return this._rejectUnchecked(err, void 0)
							}
							this._cleanValues();
							this._setFulfilled();
							this._settledValue = value;
							var len = this._length();
							len > 0 && async.invoke(this._fulfillPromises, this, len)
						}
					};
					Promise.prototype._rejectUncheckedCheckError = function (reason) {
						var trace = canAttach(reason) ? reason : new Error(reason + "");
						this._rejectUnchecked(reason, trace === reason ? void 0 : trace)
					};
					Promise.prototype._rejectUnchecked = function (reason, trace) {
						if (this.isPending()) {
							if (reason === this) {
								var err = makeSelfResolutionError();
								this._attachExtraTrace(err);
								return this._rejectUnchecked(err)
							}
							this._cleanValues();
							this._setRejected();
							this._settledValue = reason;
							if (this._isFinal()) async.invokeLater(thrower, void 0, void 0 === trace ? reason : trace);
							else {
								var len = this._length();
								void 0 !== trace && this._setCarriedStackTrace(trace);
								len > 0 ? async.invoke(this._rejectPromises, this, len) : this._ensurePossibleRejectionHandled()
							}
						}
					};
					Promise.prototype._rejectPromises = function (len) {
						len = this._length();
						for (var i = 0; len > i; i += 5) this._settlePromiseAt(i);
						this._unsetCarriedStackTrace()
					};
					Promise.prototype._fulfillPromises = function (len) {
						len = this._length();
						for (var i = 0; len > i; i += 5) this._settlePromiseAt(i)
					};
					Promise.prototype._ensurePossibleRejectionHandled = function () {
						this._setRejectionIsUnhandled();
						void 0 !== CapturedTrace.possiblyUnhandledRejection && async.invokeLater(this._notifyUnhandledRejection, this, void 0)
					};
					Promise.prototype._notifyUnhandledRejection = function () {
						if (this._isRejectionUnhandled()) {
							var reason = this._settledValue,
								trace = this._getCarriedStackTrace();
							this._unsetRejectionIsUnhandled();
							if (void 0 !== trace) {
								this._unsetCarriedStackTrace();
								reason = trace
							}
							"function" == typeof CapturedTrace.possiblyUnhandledRejection && CapturedTrace.possiblyUnhandledRejection(reason, this)
						}
					};
					var contextStack = [];
					Promise.prototype._peekContext = function () {
						var lastIndex = contextStack.length - 1;
						return lastIndex >= 0 ? contextStack[lastIndex] : void 0
					};
					Promise.prototype._pushContext = function () {
						debugging && contextStack.push(this)
					};
					Promise.prototype._popContext = function () {
						debugging && contextStack.pop()
					};
					var old = global.Promise;
					Promise.noConflict = function () {
						global.Promise === Promise && (global.Promise = old);
						return Promise
					};
					if (!CapturedTrace.isSupported()) {
						Promise.longStackTraces = function () {};
						debugging = !1
					}
					Promise._makeSelfResolutionError = makeSelfResolutionError;
					require("./finally.js")(Promise, NEXT_FILTER);
					require("./direct_resolve.js")(Promise);
					require("./thenables.js")(Promise, INTERNAL);
					Promise.RangeError = RangeError;
					Promise.CancellationError = CancellationError;
					Promise.TimeoutError = TimeoutError;
					Promise.TypeError = TypeError;
					Promise.RejectionError = RejectionError;
					require("./timers.js")(Promise, INTERNAL);
					require("./synchronous_inspection.js")(Promise);
					require("./any.js")(Promise, Promise$_CreatePromiseArray, PromiseArray);
					require("./race.js")(Promise, INTERNAL);
					require("./call_get.js")(Promise);
					require("./filter.js")(Promise, Promise$_CreatePromiseArray, PromiseArray, apiRejection);
					require("./generators.js")(Promise, apiRejection, INTERNAL);
					require("./map.js")(Promise, Promise$_CreatePromiseArray, PromiseArray, apiRejection);
					require("./nodeify.js")(Promise);
					require("./promisify.js")(Promise, INTERNAL);
					require("./props.js")(Promise, PromiseArray);
					require("./reduce.js")(Promise, Promise$_CreatePromiseArray, PromiseArray, apiRejection, INTERNAL);
					require("./settle.js")(Promise, Promise$_CreatePromiseArray, PromiseArray);
					require("./some.js")(Promise, Promise$_CreatePromiseArray, PromiseArray, apiRejection);
					require("./progress.js")(Promise, isPromiseArrayProxy);
					require("./cancel.js")(Promise, INTERNAL);
					Promise.prototype = Promise.prototype;
					return Promise
				}
			}, {
				"./any.js": 1,
				"./assert.js": 2,
				"./async.js": 3,
				"./call_get.js": 5,
				"./cancel.js": 6,
				"./captured_trace.js": 7,
				"./catch_filter.js": 8,
				"./direct_resolve.js": 9,
				"./errors.js": 10,
				"./errors_api_rejection": 11,
				"./filter.js": 13,
				"./finally.js": 14,
				"./generators.js": 15,
				"./global.js": 16,
				"./map.js": 17,
				"./nodeify.js": 18,
				"./progress.js": 19,
				"./promise_array.js": 21,
				"./promise_resolver.js": 23,
				"./promisify.js": 25,
				"./props.js": 27,
				"./race.js": 29,
				"./reduce.js": 30,
				"./settle.js": 32,
				"./some.js": 34,
				"./synchronous_inspection.js": 36,
				"./thenables.js": 37,
				"./timers.js": 38,
				"./util.js": 39
			}
		],
		21: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, INTERNAL) {
					function toResolutionValue(val) {
						switch (val) {
						case -1:
							return void 0;
						case -2:
							return [];
						case -3:
							return {}
						}
					}

					function PromiseArray(values, caller, boundTo) {
						var promise = this._promise = new Promise(INTERNAL),
							parent = void 0;
						if (Promise.is(values)) {
							parent = values;
							if (values._cancellable()) {
								promise._setCancellable();
								promise._cancellationParent = values
							}
							values._isBound() && promise._setBoundTo(boundTo)
						}
						promise._setTrace(caller, parent);
						this._values = values;
						this._length = 0;
						this._totalResolved = 0;
						this._init(void 0, -2)
					}
					var canAttach = (require("./assert.js"), require("./errors.js").canAttach),
						util = require("./util.js"),
						async = require("./async.js"),
						hasOwn = {}.hasOwnProperty,
						isArray = util.isArray;
					PromiseArray.PropertiesPromiseArray = function () {};
					PromiseArray.prototype.length = function () {
						return this._length
					};
					PromiseArray.prototype.promise = function () {
						return this._promise
					};
					PromiseArray.prototype._init = function (_, resolveValueIfEmpty) {
						var values = this._values;
						if (Promise.is(values)) {
							if (!values.isFulfilled()) {
								if (values.isPending()) {
									values._then(this._init, this._reject, void 0, this, resolveValueIfEmpty, this.constructor);
									return
								}
								this._reject(values._settledValue);
								return
							}
							values = values._settledValue;
							if (!isArray(values)) {
								var err = new Promise.TypeError("expecting an array, a promise or a thenable");
								this.__hardReject__(err);
								return
							}
							this._values = values
						}
						if (0 !== values.length) {
							var newValues, len = values.length,
								newLen = len;
							newValues = this instanceof PromiseArray.PropertiesPromiseArray ? this._values : new Array(len);
							for (var isDirectScanNeeded = !1, i = 0; len > i; ++i) {
								var promise = values[i];
								if (void 0 !== promise || hasOwn.call(values, i)) {
									var maybePromise = Promise._cast(promise, void 0, void 0);
									maybePromise instanceof Promise && maybePromise.isPending() ? maybePromise._proxyPromiseArray(this, i) : isDirectScanNeeded = !0;
									newValues[i] = maybePromise
								} else newLen--
							}
							if (0 !== newLen) {
								this._values = newValues;
								this._length = newLen;
								if (isDirectScanNeeded) {
									var scanMethod = newLen === len ? this._scanDirectValues : this._scanDirectValuesHoled;
									async.invoke(scanMethod, this, len)
								}
							} else this._resolve(-2 === resolveValueIfEmpty ? newValues : toResolutionValue(resolveValueIfEmpty))
						} else this._resolve(toResolutionValue(resolveValueIfEmpty))
					};
					PromiseArray.prototype._settlePromiseAt = function (index) {
						var value = this._values[index];
						Promise.is(value) ? value.isFulfilled() ? this._promiseFulfilled(value._settledValue, index) : value.isRejected() && this._promiseRejected(value._settledValue, index) : this._promiseFulfilled(value, index)
					};
					PromiseArray.prototype._scanDirectValuesHoled = function (len) {
						for (var i = 0; len > i && !this._isResolved(); ++i) hasOwn.call(this._values, i) && this._settlePromiseAt(i)
					};
					PromiseArray.prototype._scanDirectValues = function (len) {
						for (var i = 0; len > i && !this._isResolved(); ++i) this._settlePromiseAt(i)
					};
					PromiseArray.prototype._isResolved = function () {
						return null === this._values
					};
					PromiseArray.prototype._resolve = function (value) {
						this._values = null;
						this._promise._fulfill(value)
					};
					PromiseArray.prototype.__hardReject__ = PromiseArray.prototype._reject = function (reason) {
						this._values = null;
						var trace = canAttach(reason) ? reason : new Error(reason + "");
						this._promise._attachExtraTrace(trace);
						this._promise._reject(reason, trace)
					};
					PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
						this._isResolved() || this._promise._progress({
							index: index,
							value: progressValue
						})
					};
					PromiseArray.prototype._promiseFulfilled = function (value, index) {
						if (!this._isResolved()) {
							this._values[index] = value;
							var totalResolved = ++this._totalResolved;
							totalResolved >= this._length && this._resolve(this._values)
						}
					};
					PromiseArray.prototype._promiseRejected = function (reason) {
						if (!this._isResolved()) {
							this._totalResolved++;
							this._reject(reason)
						}
					};
					return PromiseArray
				}
			}, {
				"./assert.js": 2,
				"./async.js": 3,
				"./errors.js": 10,
				"./util.js": 39
			}
		],
		22: [
			function (require, module) {
				"use strict";

				function PromiseInspection(promise) {
					if (void 0 !== promise) {
						this._bitField = promise._bitField;
						this._settledValue = promise.isResolved() ? promise._settledValue : void 0
					} else {
						this._bitField = 0;
						this._settledValue = void 0
					}
				}
				var TypeError = require("./errors.js").TypeError;
				PromiseInspection.prototype.isFulfilled = function () {
					return (268435456 & this._bitField) > 0
				};
				PromiseInspection.prototype.isRejected = function () {
					return (134217728 & this._bitField) > 0
				};
				PromiseInspection.prototype.isPending = function () {
					return 0 === (402653184 & this._bitField)
				};
				PromiseInspection.prototype.value = function () {
					if (!this.isFulfilled()) throw new TypeError("cannot get fulfillment value of a non-fulfilled promise");
					return this._settledValue
				};
				PromiseInspection.prototype.error = function () {
					if (!this.isRejected()) throw new TypeError("cannot get rejection reason of a non-rejected promise");
					return this._settledValue
				};
				module.exports = PromiseInspection
			}, {
				"./errors.js": 10
			}
		],
		23: [
			function (require, module) {
				"use strict";

				function isUntypedError(obj) {
					return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype
				}

				function wrapAsRejectionError(obj) {
					var ret;
					ret = isUntypedError(obj) ? new RejectionError(obj) : obj;
					errors.markAsOriginatingFromRejection(ret);
					return ret
				}

				function nodebackForPromise(promise) {
					function PromiseResolver$_callback(err, value) {
						if (null !== promise) {
							if (err) {
								var wrapped = wrapAsRejectionError(maybeWrapAsError(err));
								promise._attachExtraTrace(wrapped);
								promise._reject(wrapped)
							} else if (arguments.length > 2) {
								for (var $_len = arguments.length, args = new Array($_len - 1), $_i = 1; $_len > $_i; ++$_i) args[$_i - 1] = arguments[$_i];
								promise._fulfill(args)
							} else promise._fulfill(value);
							promise = null
						}
					}
					return PromiseResolver$_callback
				}
				var PromiseResolver, util = require("./util.js"),
					maybeWrapAsError = util.maybeWrapAsError,
					errors = require("./errors.js"),
					TimeoutError = errors.TimeoutError,
					RejectionError = errors.RejectionError,
					async = require("./async.js"),
					haveGetters = util.haveGetters,
					es5 = require("./es5.js");
				PromiseResolver = haveGetters ? function (promise) {
					this.promise = promise
				} : function (promise) {
					this.promise = promise;
					this.asCallback = nodebackForPromise(promise);
					this.callback = this.asCallback
				};
				if (haveGetters) {
					var prop = {
						get: function () {
							return nodebackForPromise(this.promise)
						}
					};
					es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
					es5.defineProperty(PromiseResolver.prototype, "callback", prop)
				}
				PromiseResolver._nodebackForPromise = nodebackForPromise;
				PromiseResolver.prototype.toString = function () {
					return "[object PromiseResolver]"
				};
				PromiseResolver.prototype.resolve = PromiseResolver.prototype.fulfill = function (value) {
					var promise = this.promise;
					promise._tryFollow(value) || async.invoke(promise._fulfill, promise, value)
				};
				PromiseResolver.prototype.reject = function (reason) {
					var promise = this.promise;
					errors.markAsOriginatingFromRejection(reason);
					var trace = errors.canAttach(reason) ? reason : new Error(reason + "");
					promise._attachExtraTrace(trace);
					async.invoke(promise._reject, promise, reason);
					trace !== reason && async.invoke(this._setCarriedStackTrace, this, trace)
				};
				PromiseResolver.prototype.progress = function (value) {
					async.invoke(this.promise._progress, this.promise, value)
				};
				PromiseResolver.prototype.cancel = function () {
					async.invoke(this.promise.cancel, this.promise, void 0)
				};
				PromiseResolver.prototype.timeout = function () {
					this.reject(new TimeoutError("timeout"))
				};
				PromiseResolver.prototype.isResolved = function () {
					return this.promise.isResolved()
				};
				PromiseResolver.prototype.toJSON = function () {
					return this.promise.toJSON()
				};
				PromiseResolver.prototype._setCarriedStackTrace = function (trace) {
					this.promise.isRejected() && this.promise._setCarriedStackTrace(trace)
				};
				module.exports = PromiseResolver
			}, {
				"./async.js": 3,
				"./errors.js": 10,
				"./es5.js": 12,
				"./util.js": 39
			}
		],
		24: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, INTERNAL) {
					function PromiseSpawn(generatorFunction, receiver, caller) {
						var promise = this._promise = new Promise(INTERNAL);
						promise._setTrace(caller, void 0);
						this._generatorFunction = generatorFunction;
						this._receiver = receiver;
						this._generator = void 0
					}
					var errors = require("./errors.js"),
						TypeError = errors.TypeError,
						util = require("./util.js"),
						isArray = util.isArray,
						errorObj = util.errorObj,
						tryCatch1 = util.tryCatch1;
					PromiseSpawn.prototype.promise = function () {
						return this._promise
					};
					PromiseSpawn.prototype._run = function () {
						this._generator = this._generatorFunction.call(this._receiver);
						this._receiver = this._generatorFunction = void 0;
						this._next(void 0)
					};
					PromiseSpawn.prototype._continue = function PromiseSpawn$_continue(result) {
						if (result !== errorObj) {
							var value = result.value;
							if (result.done === !0) {
								this._generator = void 0;
								this._promise._tryFollow(value) || this._promise._fulfill(value)
							} else {
								var maybePromise = Promise._cast(value, PromiseSpawn$_continue, void 0);
								if (!(maybePromise instanceof Promise)) {
									if (!isArray(maybePromise)) {
										this._throw(new TypeError("A value was yielded that could not be treated as a promise"));
										return
									}
									maybePromise = Promise.all(maybePromise)
								}
								maybePromise._then(this._next, this._throw, void 0, this, null, void 0)
							}
						} else {
							this._generator = void 0;
							var trace = errors.canAttach(result.e) ? result.e : new Error(result.e + "");
							this._promise._attachExtraTrace(trace);
							this._promise._reject(result.e, trace)
						}
					};
					PromiseSpawn.prototype._throw = function (reason) {
						errors.canAttach(reason) && this._promise._attachExtraTrace(reason);
						this._continue(tryCatch1(this._generator["throw"], this._generator, reason))
					};
					PromiseSpawn.prototype._next = function (value) {
						this._continue(tryCatch1(this._generator.next, this._generator, value))
					};
					return PromiseSpawn
				}
			}, {
				"./errors.js": 10,
				"./util.js": 39
			}
		],
		25: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, INTERNAL) {
					function isPromisified(fn) {
						return fn.__isPromisified__ === !0
					}

					function switchCaseArgumentOrder(likelyArgumentCount) {
						for (var ret = [likelyArgumentCount], min = Math.max(0, likelyArgumentCount - 1 - 5), i = likelyArgumentCount - 1; i >= min; --i) i !== likelyArgumentCount && ret.push(i);
						for (var i = likelyArgumentCount + 1; 5 >= i; ++i) ret.push(i);
						return ret
					}

					function parameterDeclaration(parameterCount) {
						for (var ret = new Array(parameterCount), i = 0; i < ret.length; ++i) ret[i] = "_arg" + i;
						return ret.join(", ")
					}

					function parameterCount(fn) {
						return "number" == typeof fn.length ? Math.max(Math.min(fn.length, 1024), 0) : 0
					}

					function propertyAccess(id) {
						var rident = /^[a-z$_][a-z$_0-9]*$/i;
						return rident.test(id) ? "." + id : "['" + id.replace(/(['\\])/g, "\\$1") + "']"
					}

					function makeNodePromisifiedEval(callback, receiver, originalName, fn) {
						function generateCallForArgumentCount(count) {
							for (var args = new Array(count), i = 0, len = args.length; len > i; ++i) args[i] = "arguments[" + i + "]";
							var comma = count > 0 ? "," : "";
							return "string" == typeof callback && receiver === THIS ? "this" + propertyAccess(callback) + "(" + args.join(",") + comma + " fn);break;" : (void 0 === receiver ? "callback(" + args.join(",") + comma + " fn);" : "callback.call(" + (receiver === THIS ? "this" : "receiver") + ", " + args.join(",") + comma + " fn);") + "break;"
						}

						function generateArgumentSwitchCase() {
							for (var ret = "", i = 0; i < argumentOrder.length; ++i) ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
							ret += "default: var args = new Array(len + 1);var i = 0;for (var i = 0; i < len; ++i) {    args[i] = arguments[i];}args[i] = fn;" + ("string" == typeof callback ? "this" + propertyAccess(callback) + ".apply(" : "callback.apply(") + (receiver === THIS ? "this" : "receiver") + ", args); break;";
							return ret
						}
						var newParameterCount = Math.max(0, parameterCount(fn) - 1),
							argumentOrder = switchCaseArgumentOrder(newParameterCount),
							callbackName = "string" == typeof originalName ? originalName + "Async" : "promisified";
						return new Function("Promise", "callback", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "INTERNAL", "var ret = function " + callbackName + "(" + parameterDeclaration(newParameterCount) + ') {"use strict";var len = arguments.length;var promise = new Promise(INTERNAL);promise._setTrace(' + callbackName + ", void 0);var fn = nodebackForPromise(promise);try {switch(len) {" + generateArgumentSwitchCase() + "}}catch(e){ var wrapped = maybeWrapAsError(e);promise._attachExtraTrace(wrapped);promise._reject(wrapped);}return promise;}; ret.__isPromisified__ = true; return ret;")(Promise, callback, receiver, withAppended, maybeWrapAsError, nodebackForPromise, INTERNAL)
					}

					function makeNodePromisifiedClosure(callback, receiver) {
						function promisified() {
							var _receiver = receiver;
							receiver === THIS && (_receiver = this);
							"string" == typeof callback && (callback = _receiver[callback]);
							var promise = new Promise(INTERNAL);
							promise._setTrace(promisified, void 0);
							var fn = nodebackForPromise(promise);
							try {
								callback.apply(_receiver, withAppended(arguments, fn))
							} catch (e) {
								var wrapped = maybeWrapAsError(e);
								promise._attachExtraTrace(wrapped);
								promise._reject(wrapped)
							}
							return promise
						}
						promisified.__isPromisified__ = !0;
						return promisified
					}

					function f() {}

					function _promisify(callback, receiver, isAll) {
						if (isAll) {
							for (var methods = inheritedMethods(callback), i = 0, len = methods.length; len > i; i += 2) {
								var key = methods[i],
									fn = methods[i + 1],
									originalKey = key + "__beforePromisified__",
									promisifiedKey = key + "Async";
								notEnumerableProp(callback, originalKey, fn);
								callback[promisifiedKey] = makeNodePromisified(originalKey, THIS, key, fn)
							}
							methods.length > 16 && (f.prototype = callback);
							return callback
						}
						return makeNodePromisified(callback, receiver, void 0, callback)
					}
					var THIS = {},
						util = require("./util.js"),
						es5 = require("./es5.js"),
						nodebackForPromise = require("./promise_resolver.js")._nodebackForPromise,
						withAppended = util.withAppended,
						maybeWrapAsError = util.maybeWrapAsError,
						canEvaluate = util.canEvaluate,
						notEnumerableProp = util.notEnumerableProp,
						deprecated = util.deprecated,
						roriginal = (require("./assert.js"), new RegExp("__beforePromisified__$")),
						hasProp = {}.hasOwnProperty,
						inheritedMethods = function () {
							if (es5.isES5) {
								var create = Object.create,
									getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
								return function (cur) {
									for (var original = cur, ret = [], visitedKeys = create(null); null !== cur;) {
										for (var keys = es5.keys(cur), i = 0, len = keys.length; len > i; ++i) {
											var key = keys[i];
											if (!(visitedKeys[key] || roriginal.test(key) || hasProp.call(original, key + "__beforePromisified__"))) {
												visitedKeys[key] = !0;
												var desc = getOwnPropertyDescriptor(cur, key);
												null == desc || "function" != typeof desc.value || isPromisified(desc.value) || ret.push(key, desc.value)
											}
										}
										cur = es5.getPrototypeOf(cur)
									}
									return ret
								}
							}
							return function (obj) {
								var ret = [];
								for (var key in obj)
									if (!roriginal.test(key) && !hasProp.call(obj, key + "__beforePromisified__")) {
										var fn = obj[key];
										"function" != typeof fn || isPromisified(fn) || ret.push(key, fn)
									}
								return ret
							}
						}(),
						makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
					Promise.promisify = function (fn, receiver) {
						if ("object" == typeof fn && null !== fn) {
							deprecated("Promise.promisify for promisifying entire objects is deprecated. Use Promise.promisifyAll instead.");
							return _promisify(fn, receiver, !0)
						}
						if ("function" != typeof fn) throw new TypeError("fn must be a function");
						return isPromisified(fn) ? fn : _promisify(fn, arguments.length < 2 ? THIS : receiver, !1)
					};
					Promise.promisifyAll = function (target) {
						if ("function" != typeof target && "object" != typeof target) throw new TypeError("the target of promisifyAll must be an object or a function");
						return _promisify(target, void 0, !0)
					}
				}
			}, {
				"./assert.js": 2,
				"./es5.js": 12,
				"./promise_resolver.js": 23,
				"./util.js": 39
			}
		],
		26: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, PromiseArray) {
					function PropertiesPromiseArray(obj, caller, boundTo) {
						for (var keys = es5.keys(obj), values = new Array(keys.length), i = 0, len = values.length; len > i; ++i) values[i] = obj[keys[i]];
						this.constructor$(values, caller, boundTo);
						if (!this._isResolved())
							for (var i = 0, len = keys.length; len > i; ++i) values.push(keys[i])
					}
					var util = (require("./assert.js"), require("./util.js")),
						inherits = util.inherits,
						es5 = require("./es5.js");
					inherits(PropertiesPromiseArray, PromiseArray);
					PropertiesPromiseArray.prototype._init = function () {
						this._init$(void 0, -3)
					};
					PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
						if (!this._isResolved()) {
							this._values[index] = value;
							var totalResolved = ++this._totalResolved;
							if (totalResolved >= this._length) {
								for (var val = {}, keyOffset = this.length(), i = 0, len = this.length(); len > i; ++i) val[this._values[i + keyOffset]] = this._values[i];
								this._resolve(val)
							}
						}
					};
					PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
						this._isResolved() || this._promise._progress({
							key: this._values[index + this.length()],
							value: value
						})
					};
					PromiseArray.PropertiesPromiseArray = PropertiesPromiseArray;
					return PropertiesPromiseArray
				}
			}, {
				"./assert.js": 2,
				"./es5.js": 12,
				"./util.js": 39
			}
		],
		27: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, PromiseArray) {
					function Promise$_Props(promises, useBound, caller) {
						var ret, castValue = Promise._cast(promises, caller, void 0);
						if (!isObject(castValue)) return apiRejection("cannot await properties of a non-object");
						if (Promise.is(castValue)) ret = castValue._then(Promise.props, void 0, void 0, void 0, void 0, caller);
						else {
							ret = new PropertiesPromiseArray(castValue, caller, useBound === !0 && castValue._isBound() ? castValue._boundTo : void 0).promise();
							useBound = !1
						}
						useBound === !0 && castValue._isBound() && ret._setBoundTo(castValue._boundTo);
						return ret
					}
					var PropertiesPromiseArray = require("./properties_promise_array.js")(Promise, PromiseArray),
						util = require("./util.js"),
						apiRejection = require("./errors_api_rejection")(Promise),
						isObject = util.isObject;
					Promise.prototype.props = function () {
						return Promise$_Props(this, !0, this.props)
					};
					Promise.props = function (promises) {
						return Promise$_Props(promises, !1, Promise.props)
					}
				}
			}, {
				"./errors_api_rejection": 11,
				"./properties_promise_array.js": 26,
				"./util.js": 39
			}
		],
		28: [
			function (require, module) {
				"use strict";

				function arrayCopy(src, srcIndex, dst, dstIndex, len) {
					for (var j = 0; len > j; ++j) dst[j + dstIndex] = src[j + srcIndex]
				}

				function pow2AtLeast(n) {
					n >>>= 0;
					n -= 1;
					n |= n >> 1;
					n |= n >> 2;
					n |= n >> 4;
					n |= n >> 8;
					n |= n >> 16;
					return n + 1
				}

				function getCapacity(capacity) {
					return "number" != typeof capacity ? 16 : pow2AtLeast(Math.min(Math.max(16, capacity), 1073741824))
				}

				function Queue(capacity) {
					this._capacity = getCapacity(capacity);
					this._length = 0;
					this._front = 0;
					this._makeCapacity()
				}
				require("./assert.js");
				Queue.prototype._willBeOverCapacity = function (size) {
					return this._capacity < size
				};
				Queue.prototype._pushOne = function (arg) {
					var length = this.length();
					this._checkCapacity(length + 1);
					var i = this._front + length & this._capacity - 1;
					this[i] = arg;
					this._length = length + 1
				};
				Queue.prototype.push = function (fn, receiver, arg) {
					var length = this.length() + 3;
					if (this._willBeOverCapacity(length)) {
						this._pushOne(fn);
						this._pushOne(receiver);
						this._pushOne(arg)
					} else {
						var j = this._front + length - 3;
						this._checkCapacity(length);
						var wrapMask = this._capacity - 1;
						this[j + 0 & wrapMask] = fn;
						this[j + 1 & wrapMask] = receiver;
						this[j + 2 & wrapMask] = arg;
						this._length = length
					}
				};
				Queue.prototype.shift = function () {
					var front = this._front,
						ret = this[front];
					this[front] = void 0;
					this._front = front + 1 & this._capacity - 1;
					this._length--;
					return ret
				};
				Queue.prototype.length = function () {
					return this._length
				};
				Queue.prototype._makeCapacity = function () {
					for (var len = this._capacity, i = 0; len > i; ++i) this[i] = void 0
				};
				Queue.prototype._checkCapacity = function (size) {
					this._capacity < size && this._resizeTo(this._capacity << 3)
				};
				Queue.prototype._resizeTo = function (capacity) {
					var oldFront = this._front,
						oldCapacity = this._capacity,
						oldQueue = new Array(oldCapacity),
						length = this.length();
					arrayCopy(this, 0, oldQueue, 0, oldCapacity);
					this._capacity = capacity;
					this._makeCapacity();
					this._front = 0;
					if (oldCapacity >= oldFront + length) arrayCopy(oldQueue, oldFront, this, 0, length);
					else {
						var lengthBeforeWrapping = length - (oldFront + length & oldCapacity - 1);
						arrayCopy(oldQueue, oldFront, this, 0, lengthBeforeWrapping);
						arrayCopy(oldQueue, 0, this, lengthBeforeWrapping, length - lengthBeforeWrapping)
					}
				};
				module.exports = Queue
			}, {
				"./assert.js": 2
			}
		],
		29: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, INTERNAL) {
					function Promise$_Race(promises, caller, parent) {
						var maybePromise = Promise._cast(promises, caller, void 0);
						if (Promise.is(maybePromise)) return raceLater(maybePromise);
						if (!isArray(promises)) return apiRejection("expecting an array, a promise or a thenable");
						var ret = new Promise(INTERNAL);
						ret._setTrace(caller, parent);
						if (void 0 !== parent) {
							parent._isBound() && ret._setBoundTo(parent._boundTo);
							if (parent._cancellable()) {
								ret._setCancellable();
								ret._cancellationParent = parent
							}
						}
						for (var fulfill = ret._fulfill, reject = ret._reject, i = 0, len = promises.length; len > i; ++i) {
							var val = promises[i];
							(void 0 !== val || hasOwn.call(promises, i)) && Promise.cast(val)._then(fulfill, reject, void 0, ret, null, caller)
						}
						return ret
					}
					var apiRejection = require("./errors_api_rejection.js")(Promise),
						isArray = require("./util.js").isArray,
						raceLater = function (promise) {
							return promise.then(function Promise$_lateRacer(array) {
								return Promise$_Race(array, Promise$_lateRacer, promise)
							})
						},
						hasOwn = {}.hasOwnProperty;
					Promise.race = function (promises) {
						return Promise$_Race(promises, Promise.race, void 0)
					};
					Promise.prototype.race = function () {
						return Promise$_Race(this, this.race, void 0)
					}
				}
			}, {
				"./errors_api_rejection.js": 11,
				"./util.js": 39
			}
		],
		30: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, Promise$_CreatePromiseArray, PromiseArray, apiRejection, INTERNAL) {
					function Reduction(callback, index, accum, items, receiver) {
						this.promise = new Promise(INTERNAL);
						this.index = index;
						this.length = items.length;
						this.items = items;
						this.callback = callback;
						this.receiver = receiver;
						this.accum = accum
					}

					function Promise$_reducer(fulfilleds, initialValue) {
						var fn = this,
							receiver = void 0;
						if ("function" != typeof fn) {
							receiver = fn.receiver;
							fn = fn.fn
						}
						var len = fulfilleds.length,
							accum = void 0,
							startIndex = 0;
						if (void 0 !== initialValue) {
							accum = initialValue;
							startIndex = 0
						} else {
							startIndex = 1;
							len > 0 && (accum = fulfilleds[0])
						}
						var i = startIndex;
						if (i >= len) return accum;
						var reduction = new Reduction(fn, i, accum, fulfilleds, receiver);
						reduction.iterate();
						return reduction.promise
					}

					function Promise$_unpackReducer(fulfilleds) {
						var fn = this.fn,
							initialValue = this.initialValue;
						return Promise$_reducer.call(fn, fulfilleds, initialValue)
					}

					function Promise$_slowReduce(promises, fn, initialValue, useBound, caller) {
						return initialValue._then(function callee(initialValue) {
							return Promise$_Reduce(promises, fn, initialValue, useBound, callee)
						}, void 0, void 0, void 0, void 0, caller)
					}

					function Promise$_Reduce(promises, fn, initialValue, useBound, caller) {
						if ("function" != typeof fn) return apiRejection("fn must be a function");
						useBound === !0 && promises._isBound() && (fn = {
							fn: fn,
							receiver: promises._boundTo
						});
						if (void 0 !== initialValue) {
							if (Promise.is(initialValue)) {
								if (!initialValue.isFulfilled()) return Promise$_slowReduce(promises, fn, initialValue, useBound, caller);
								initialValue = initialValue._settledValue
							}
							return Promise$_CreatePromiseArray(promises, PromiseArray, caller, useBound === !0 && promises._isBound() ? promises._boundTo : void 0).promise()._then(Promise$_unpackReducer, void 0, void 0, {
								fn: fn,
								initialValue: initialValue
							}, void 0, Promise.reduce)
						}
						return Promise$_CreatePromiseArray(promises, PromiseArray, caller, useBound === !0 && promises._isBound() ? promises._boundTo : void 0).promise()._then(Promise$_reducer, void 0, void 0, fn, void 0, caller)
					}
					require("./assert.js");
					Reduction.prototype.reject = function (e) {
						this.promise._reject(e)
					};
					Reduction.prototype.fulfill = function (value, index) {
						this.accum = value;
						this.index = index + 1;
						this.iterate()
					};
					Reduction.prototype.iterate = function () {
						for (var i = this.index, len = this.length, items = this.items, result = this.accum, receiver = this.receiver, callback = this.callback, iterate = this.iterate; len > i; ++i) {
							result = Promise._cast(callback.call(receiver, result, items[i], i, len), iterate, void 0);
							if (result instanceof Promise) {
								result._then(this.fulfill, this.reject, void 0, this, i, iterate);
								return
							}
						}
						this.promise._fulfill(result)
					};
					Promise.reduce = function (promises, fn, initialValue) {
						return Promise$_Reduce(promises, fn, initialValue, !1, Promise.reduce)
					};
					Promise.prototype.reduce = function (fn, initialValue) {
						return Promise$_Reduce(this, fn, initialValue, !0, this.reduce)
					}
				}
			}, {
				"./assert.js": 2
			}
		],
		31: [
			function (require, module) {
				"use strict"; {
					var schedule, global = require("./global.js");
					require("./assert.js")
				}
				if ("undefined" != typeof process && null !== process && "function" == typeof process.cwd && "function" == typeof process.nextTick) schedule = process.nextTick;
				else if ("function" != typeof MutationObserver && "function" != typeof WebkitMutationObserver && "function" != typeof WebKitMutationObserver || "undefined" == typeof document || "function" != typeof document.createElement)
					if ("function" == typeof global.postMessage && "function" != typeof global.importScripts && "function" == typeof global.addEventListener && "function" == typeof global.removeEventListener) {
						var MESSAGE_KEY = "bluebird_message_key_" + Math.random();
						schedule = function () {
							function Promise$_Scheduler(e) {
								if (e.source === global && e.data === MESSAGE_KEY) {
									var fn = queuedFn;
									queuedFn = void 0;
									fn()
								}
							}
							var queuedFn = void 0;
							global.addEventListener("message", Promise$_Scheduler, !1);
							return function (fn) {
								queuedFn = fn;
								global.postMessage(MESSAGE_KEY, "*")
							}
						}()
					} else schedule = "function" == typeof MessageChannel ? function () {
						var queuedFn = void 0,
							channel = new MessageChannel;
						channel.port1.onmessage = function () {
							var fn = queuedFn;
							queuedFn = void 0;
							fn()
						};
						return function (fn) {
							queuedFn = fn;
							channel.port2.postMessage(null)
						}
					}() : global.setTimeout ? function (fn) {
						setTimeout(fn, 4)
					} : function (fn) {
						fn()
					};
				else schedule = function () {
					var MutationObserver = global.MutationObserver || global.WebkitMutationObserver || global.WebKitMutationObserver,
						div = document.createElement("div"),
						queuedFn = void 0,
						observer = new MutationObserver(function () {
							var fn = queuedFn;
							queuedFn = void 0;
							fn()
						});
					observer.observe(div, {
						attributes: !0
					});
					return function (fn) {
						queuedFn = fn;
						div.setAttribute("class", "foo")
					}
				}();
				module.exports = schedule
			}, {
				"./assert.js": 2,
				"./global.js": 16
			}
		],
		32: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, Promise$_CreatePromiseArray, PromiseArray) {
					function Promise$_Settle(promises, useBound, caller) {
						return Promise$_CreatePromiseArray(promises, SettledPromiseArray, caller, useBound === !0 && promises._isBound() ? promises._boundTo : void 0).promise()
					}
					var SettledPromiseArray = require("./settled_promise_array.js")(Promise, PromiseArray);
					Promise.settle = function (promises) {
						return Promise$_Settle(promises, !1, Promise.settle)
					};
					Promise.prototype.settle = function () {
						return Promise$_Settle(this, !0, this.settle)
					}
				}
			}, {
				"./settled_promise_array.js": 33
			}
		],
		33: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, PromiseArray) {
					function SettledPromiseArray(values, caller, boundTo) {
						this.constructor$(values, caller, boundTo)
					}
					var PromiseInspection = (require("./assert.js"), require("./promise_inspection.js")),
						util = require("./util.js"),
						inherits = util.inherits;
					inherits(SettledPromiseArray, PromiseArray);
					SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
						this._values[index] = inspection;
						var totalResolved = ++this._totalResolved;
						totalResolved >= this._length && this._resolve(this._values)
					};
					SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
						if (!this._isResolved()) {
							var ret = new PromiseInspection;
							ret._bitField = 268435456;
							ret._settledValue = value;
							this._promiseResolved(index, ret)
						}
					};
					SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
						if (!this._isResolved()) {
							var ret = new PromiseInspection;
							ret._bitField = 134217728;
							ret._settledValue = reason;
							this._promiseResolved(index, ret)
						}
					};
					return SettledPromiseArray
				}
			}, {
				"./assert.js": 2,
				"./promise_inspection.js": 22,
				"./util.js": 39
			}
		],
		34: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, Promise$_CreatePromiseArray, PromiseArray, apiRejection) {
					function Promise$_Some(promises, howMany, useBound, caller) {
						if ((0 | howMany) !== howMany || 0 > howMany) return apiRejection("expecting a positive integer");
						var ret = Promise$_CreatePromiseArray(promises, SomePromiseArray, caller, useBound === !0 && promises._isBound() ? promises._boundTo : void 0),
							promise = ret.promise();
						if (promise.isRejected()) return promise;
						ret.setHowMany(howMany);
						ret.init();
						return promise
					} {
						var SomePromiseArray = require("./some_promise_array.js")(PromiseArray);
						require("./assert.js")
					}
					Promise.some = function (promises, howMany) {
						return Promise$_Some(promises, howMany, !1, Promise.some)
					};
					Promise.prototype.some = function (count) {
						return Promise$_Some(this, count, !0, this.some)
					}
				}
			}, {
				"./assert.js": 2,
				"./some_promise_array.js": 35
			}
		],
		35: [
			function (require, module) {
				"use strict";
				module.exports = function (PromiseArray) {
					function SomePromiseArray(values, caller, boundTo) {
						this.constructor$(values, caller, boundTo);
						this._howMany = 0;
						this._unwrap = !1;
						this._initialized = !1
					}
					var util = require("./util.js"),
						RangeError = require("./errors.js").RangeError,
						inherits = util.inherits,
						isArray = util.isArray;
					inherits(SomePromiseArray, PromiseArray);
					SomePromiseArray.prototype._init = function () {
						if (this._initialized)
							if (0 !== this._howMany) {
								this._init$(void 0, -2);
								var isArrayResolved = isArray(this._values);
								this._holes = isArrayResolved ? this._values.length - this.length() : 0;
								if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
									var message = "(Promise.some) input array contains less than " + this._howMany + " promises";
									this._reject(new RangeError(message))
								}
							} else this._resolve([])
					};
					SomePromiseArray.prototype.init = function () {
						this._initialized = !0;
						this._init()
					};
					SomePromiseArray.prototype.setUnwrap = function () {
						this._unwrap = !0
					};
					SomePromiseArray.prototype.howMany = function () {
						return this._howMany
					};
					SomePromiseArray.prototype.setHowMany = function (count) {
						this._isResolved() || (this._howMany = count)
					};
					SomePromiseArray.prototype._promiseFulfilled = function (value) {
						if (!this._isResolved()) {
							this._addFulfilled(value);
							if (this._fulfilled() === this.howMany()) {
								this._values.length = this.howMany();
								this._resolve(1 === this.howMany() && this._unwrap ? this._values[0] : this._values)
							}
						}
					};
					SomePromiseArray.prototype._promiseRejected = function (reason) {
						if (!this._isResolved()) {
							this._addRejected(reason);
							this.howMany() > this._canPossiblyFulfill() && this._reject(this._values.length === this.length() ? [] : this._values.slice(this.length() + this._holes))
						}
					};
					SomePromiseArray.prototype._fulfilled = function () {
						return this._totalResolved
					};
					SomePromiseArray.prototype._rejected = function () {
						return this._values.length - this.length() - this._holes
					};
					SomePromiseArray.prototype._addRejected = function (reason) {
						this._values.push(reason)
					};
					SomePromiseArray.prototype._addFulfilled = function (value) {
						this._values[this._totalResolved++] = value
					};
					SomePromiseArray.prototype._canPossiblyFulfill = function () {
						return this.length() - this._rejected()
					};
					return SomePromiseArray
				}
			}, {
				"./errors.js": 10,
				"./util.js": 39
			}
		],
		36: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise) {
					var PromiseInspection = require("./promise_inspection.js");
					Promise.prototype.inspect = function () {
						return new PromiseInspection(this)
					}
				}
			}, {
				"./promise_inspection.js": 22
			}
		],
		37: [
			function (require, module) {
				"use strict";
				module.exports = function (Promise, INTERNAL) {
					function getThen(obj) {
						try {
							return obj.then
						} catch (e) {
							errorObj.e = e;
							return errorObj
						}
					}

					function Promise$_Cast(obj, caller, originalPromise) {
						if (isObject(obj)) {
							if (obj instanceof Promise) return obj;
							if (isAnyBluebirdPromise(obj)) {
								var ret = new Promise(INTERNAL);
								ret._setTrace(caller, void 0);
								obj._then(ret._fulfillUnchecked, ret._rejectUncheckedCheckError, ret._progressUnchecked, ret, null, void 0);
								ret._setFollowing();
								return ret
							}
							var then = getThen(obj);
							if (then === errorObj) {
								caller = "function" == typeof caller ? caller : Promise$_Cast;
								void 0 !== originalPromise && canAttach(then.e) && originalPromise._attachExtraTrace(then.e);
								return Promise.reject(then.e, caller)
							}
							if ("function" == typeof then) {
								caller = "function" == typeof caller ? caller : Promise$_Cast;
								return Promise$_doThenable(obj, then, caller, originalPromise)
							}
						}
						return obj
					}

					function isAnyBluebirdPromise(obj) {
						return hasProp.call(obj, "_promise0")
					}

					function Promise$_doThenable(x, then, caller, originalPromise) {
						function Promise$_resolveFromThenable(y) {
							if (!called) {
								called = !0;
								if (x !== y) resolver.resolve(y);
								else {
									var e = Promise._makeSelfResolutionError();
									void 0 !== originalPromise && originalPromise._attachExtraTrace(e);
									resolver.promise._reject(e, void 0)
								}
							}
						}

						function Promise$_rejectFromThenable(r) {
							if (!called) {
								called = !0;
								var trace = canAttach(r) ? r : new Error(r + "");
								void 0 !== originalPromise && originalPromise._attachExtraTrace(trace);
								resolver.promise._reject(r, trace)
							}
						}

						function Promise$_progressFromThenable(v) {
							if (!called) {
								var promise = resolver.promise;
								"function" == typeof promise._progress && promise._progress(v)
							}
						}
						var resolver = Promise.defer(caller),
							called = !1;
						try {
							then.call(x, Promise$_resolveFromThenable, Promise$_rejectFromThenable, Promise$_progressFromThenable)
						} catch (e) {
							if (!called) {
								called = !0;
								var trace = canAttach(e) ? e : new Error(e + "");
								void 0 !== originalPromise && originalPromise._attachExtraTrace(trace);
								resolver.promise._reject(e, trace)
							}
						}
						return resolver.promise
					}
					var util = (require("./assert.js"), require("./util.js")),
						canAttach = require("./errors.js").canAttach,
						errorObj = util.errorObj,
						isObject = util.isObject,
						hasProp = {}.hasOwnProperty;
					Promise._cast = Promise$_Cast
				}
			}, {
				"./assert.js": 2,
				"./errors.js": 10,
				"./util.js": 39
			}
		],
		38: [
			function (require, module) {
				"use strict";
				var global = require("./global.js"),
					setTimeout = function (fn, time) {
						for (var $_len = arguments.length, args = new Array($_len - 2), $_i = 2; $_len > $_i; ++$_i) args[$_i - 2] = arguments[$_i];
						global.setTimeout(function () {
							fn.apply(void 0, args)
						}, time)
					},
					pass = {};
				global.setTimeout(function (_) {
					_ === pass && (setTimeout = global.setTimeout)
				}, 1, pass);
				module.exports = function (Promise, INTERNAL) {
					var errors = (require("./util.js"), require("./assert.js"), require("./errors.js")),
						TimeoutError = (require("./errors_api_rejection")(Promise), Promise.TimeoutError),
						afterTimeout = function (promise, message, ms) {
							if (promise.isPending()) {
								"string" != typeof message && (message = "operation timed out after " + ms + " ms");
								var err = new TimeoutError(message);
								errors.markAsOriginatingFromRejection(err);
								promise._attachExtraTrace(err);
								promise._rejectUnchecked(err)
							}
						},
						afterDelay = function (value, promise) {
							promise._fulfill(value)
						};
					Promise.delay = function (value, ms, caller) {
						if (void 0 === ms) {
							ms = value;
							value = void 0
						}
						ms = +ms;
						"function" != typeof caller && (caller = Promise.delay);
						var maybePromise = Promise._cast(value, caller, void 0),
							promise = new Promise(INTERNAL);
						if (Promise.is(maybePromise)) {
							maybePromise._isBound() && promise._setBoundTo(maybePromise._boundTo);
							if (maybePromise._cancellable()) {
								promise._setCancellable();
								promise._cancellationParent = maybePromise
							}
							promise._setTrace(caller, maybePromise);
							promise._follow(maybePromise);
							return promise.then(function (value) {
								return Promise.delay(value, ms)
							})
						}
						promise._setTrace(caller, void 0);
						setTimeout(afterDelay, ms, value, promise);
						return promise
					};
					Promise.prototype.delay = function (ms) {
						return Promise.delay(this, ms, this.delay)
					};
					Promise.prototype.timeout = function (ms, message) {
						ms = +ms;
						var ret = new Promise(INTERNAL);
						ret._setTrace(this.timeout, this);
						this._isBound() && ret._setBoundTo(this._boundTo);
						if (this._cancellable()) {
							ret._setCancellable();
							ret._cancellationParent = this
						}
						ret._follow(this);
						setTimeout(afterTimeout, ms, ret, message, ms);
						return ret
					}
				}
			}, {
				"./assert.js": 2,
				"./errors.js": 10,
				"./errors_api_rejection": 11,
				"./global.js": 16,
				"./util.js": 39
			}
		],
		39: [
			function (require, module) {
				"use strict";

				function deprecated(msg) {
					"undefined" != typeof console && null !== console && "function" == typeof console.warn && console.warn("Bluebird: " + msg)
				}

				function tryCatch1(fn, receiver, arg) {
					try {
						return fn.call(receiver, arg)
					} catch (e) {
						errorObj.e = e;
						return errorObj
					}
				}

				function tryCatch2(fn, receiver, arg, arg2) {
					try {
						return fn.call(receiver, arg, arg2)
					} catch (e) {
						errorObj.e = e;
						return errorObj
					}
				}

				function tryCatchApply(fn, args, receiver) {
					try {
						return fn.apply(receiver, args)
					} catch (e) {
						errorObj.e = e;
						return errorObj
					}
				}

				function asString(val) {
					return "string" == typeof val ? val : "" + val
				}

				function isPrimitive(val) {
					return null == val || val === !0 || val === !1 || "string" == typeof val || "number" == typeof val
				}

				function isObject(value) {
					return !isPrimitive(value)
				}

				function maybeWrapAsError(maybeError) {
					return isPrimitive(maybeError) ? new Error(asString(maybeError)) : maybeError
				}

				function withAppended(target, appendee) {
					var i, len = target.length,
						ret = new Array(len + 1);
					for (i = 0; len > i; ++i) ret[i] = target[i];
					ret[i] = appendee;
					return ret
				}

				function notEnumerableProp(obj, name, value) {
					var descriptor = {
						value: value,
						configurable: !0,
						enumerable: !1,
						writable: !0
					};
					es5.defineProperty(obj, name, descriptor);
					return obj
				}

				function thrower(r) {
					throw r
				}
				var global = require("./global.js"),
					es5 = (require("./assert.js"), require("./es5.js")),
					haveGetters = function () {
						try {
							var o = {};
							es5.defineProperty(o, "f", {
								get: function () {
									return 3
								}
							});
							return 3 === o.f
						} catch (e) {
							return !1
						}
					}(),
					canEvaluate = function () {
						return "undefined" != typeof window && null !== window && "undefined" != typeof window.document && "undefined" != typeof navigator && null !== navigator && "string" == typeof navigator.appName && window === global ? !1 : !0
					}(),
					errorObj = {
						e: {}
					},
					inherits = function (Child, Parent) {
						function T() {
							this.constructor = Child;
							this.constructor$ = Parent;
							for (var propertyName in Parent.prototype) hasProp.call(Parent.prototype, propertyName) && "$" !== propertyName.charAt(propertyName.length - 1) && (this[propertyName + "$"] = Parent.prototype[propertyName])
						}
						var hasProp = {}.hasOwnProperty;
						T.prototype = Parent.prototype;
						Child.prototype = new T;
						return Child.prototype
					},
					wrapsPrimitiveReceiver = function () {
						return "string" !== this
					}.call("string"),
					ret = {
						thrower: thrower,
						isArray: es5.isArray,
						haveGetters: haveGetters,
						notEnumerableProp: notEnumerableProp,
						isPrimitive: isPrimitive,
						isObject: isObject,
						canEvaluate: canEvaluate,
						deprecated: deprecated,
						errorObj: errorObj,
						tryCatch1: tryCatch1,
						tryCatch2: tryCatch2,
						tryCatchApply: tryCatchApply,
						inherits: inherits,
						withAppended: withAppended,
						asString: asString,
						maybeWrapAsError: maybeWrapAsError,
						wrapsPrimitiveReceiver: wrapsPrimitiveReceiver
					};
				module.exports = ret
			}, {
				"./assert.js": 2,
				"./es5.js": 12,
				"./global.js": 16
			}
		]
	}, {}, [4])(4)
});
require = function e(t, n, r) {
	function s(o, u) {
		if (!n[o]) {
			if (!t[o]) {
				var a = "function" == typeof require && require;
				if (!u && a) return a(o, !0);
				if (i) return i(o, !0);
				throw new Error("Cannot find module '" + o + "'")
			}
			var f = n[o] = {
				exports: {}
			};
			t[o][0].call(f.exports, function (e) {
				var n = t[o][1][e];
				return s(n ? n : e)
			}, f, f.exports, e, t, n, r)
		}
		return n[o].exports
	}
	for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
	return s
}({
	1: [
		function (require, module, exports) {
			function Buffer(subject, encoding, noZero) {
				if (!(this instanceof Buffer)) return new Buffer(subject, encoding, noZero);
				var type = typeof subject;
				if ("base64" === encoding && "string" === type) {
					subject = stringtrim(subject);
					for (; subject.length % 4 !== 0;) subject += "="
				}
				var length;
				if ("number" === type) length = coerce(subject);
				else if ("string" === type) length = Buffer.byteLength(subject, encoding);
				else {
					if ("object" !== type) throw new Error("First argument needs to be a number, array or string.");
					length = coerce(subject.length)
				}
				var buf;
				if (Buffer._useTypedArrays) buf = Buffer._augment(new Uint8Array(length));
				else {
					buf = this;
					buf.length = length;
					buf._isBuffer = !0
				}
				var i;
				if (Buffer._useTypedArrays && "number" == typeof subject.byteLength) buf._set(subject);
				else if (isArrayish(subject))
					for (i = 0; length > i; i++) buf[i] = Buffer.isBuffer(subject) ? subject.readUInt8(i) : subject[i];
				else if ("string" === type) buf.write(subject, 0, encoding);
				else if ("number" === type && !Buffer._useTypedArrays && !noZero)
					for (i = 0; length > i; i++) buf[i] = 0;
				return buf
			}

			function _hexWrite(buf, string, offset, length) {
				offset = Number(offset) || 0;
				var remaining = buf.length - offset;
				if (length) {
					length = Number(length);
					length > remaining && (length = remaining)
				} else length = remaining;
				var strLen = string.length;
				assert(strLen % 2 === 0, "Invalid hex string");
				length > strLen / 2 && (length = strLen / 2);
				for (var i = 0; length > i; i++) {
					var byte = parseInt(string.substr(2 * i, 2), 16);
					assert(!isNaN(byte), "Invalid hex string");
					buf[offset + i] = byte
				}
				Buffer._charsWritten = 2 * i;
				return i
			}

			function _utf8Write(buf, string, offset, length) {
				var charsWritten = Buffer._charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length);
				return charsWritten
			}

			function _asciiWrite(buf, string, offset, length) {
				var charsWritten = Buffer._charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length);
				return charsWritten
			}

			function _binaryWrite(buf, string, offset, length) {
				return _asciiWrite(buf, string, offset, length)
			}

			function _base64Write(buf, string, offset, length) {
				var charsWritten = Buffer._charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length);
				return charsWritten
			}

			function _utf16leWrite(buf, string, offset, length) {
				var charsWritten = Buffer._charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length);
				return charsWritten
			}

			function _base64Slice(buf, start, end) {
				return base64.fromByteArray(0 === start && end === buf.length ? buf : buf.slice(start, end))
			}

			function _utf8Slice(buf, start, end) {
				var res = "",
					tmp = "";
				end = Math.min(buf.length, end);
				for (var i = start; end > i; i++)
					if (buf[i] <= 127) {
						res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
						tmp = ""
					} else tmp += "%" + buf[i].toString(16);
				return res + decodeUtf8Char(tmp)
			}

			function _asciiSlice(buf, start, end) {
				var ret = "";
				end = Math.min(buf.length, end);
				for (var i = start; end > i; i++) ret += String.fromCharCode(buf[i]);
				return ret
			}

			function _binarySlice(buf, start, end) {
				return _asciiSlice(buf, start, end)
			}

			function _hexSlice(buf, start, end) {
				var len = buf.length;
				(!start || 0 > start) && (start = 0);
				(!end || 0 > end || end > len) && (end = len);
				for (var out = "", i = start; end > i; i++) out += toHex(buf[i]);
				return out
			}

			function _utf16leSlice(buf, start, end) {
				for (var bytes = buf.slice(start, end), res = "", i = 0; i < bytes.length; i += 2) res += String.fromCharCode(bytes[i] + 256 * bytes[i + 1]);
				return res
			}

			function _readUInt16(buf, offset, littleEndian, noAssert) {
				if (!noAssert) {
					assert("boolean" == typeof littleEndian, "missing or invalid endian");
					assert(void 0 !== offset && null !== offset, "missing offset");
					assert(offset + 1 < buf.length, "Trying to read beyond buffer length")
				}
				var len = buf.length;
				if (!(offset >= len)) {
					var val;
					if (littleEndian) {
						val = buf[offset];
						len > offset + 1 && (val |= buf[offset + 1] << 8)
					} else {
						val = buf[offset] << 8;
						len > offset + 1 && (val |= buf[offset + 1])
					}
					return val
				}
			}

			function _readUInt32(buf, offset, littleEndian, noAssert) {
				if (!noAssert) {
					assert("boolean" == typeof littleEndian, "missing or invalid endian");
					assert(void 0 !== offset && null !== offset, "missing offset");
					assert(offset + 3 < buf.length, "Trying to read beyond buffer length")
				}
				var len = buf.length;
				if (!(offset >= len)) {
					var val;
					if (littleEndian) {
						len > offset + 2 && (val = buf[offset + 2] << 16);
						len > offset + 1 && (val |= buf[offset + 1] << 8);
						val |= buf[offset];
						len > offset + 3 && (val += buf[offset + 3] << 24 >>> 0)
					} else {
						len > offset + 1 && (val = buf[offset + 1] << 16);
						len > offset + 2 && (val |= buf[offset + 2] << 8);
						len > offset + 3 && (val |= buf[offset + 3]);
						val += buf[offset] << 24 >>> 0
					}
					return val
				}
			}

			function _readInt16(buf, offset, littleEndian, noAssert) {
				if (!noAssert) {
					assert("boolean" == typeof littleEndian, "missing or invalid endian");
					assert(void 0 !== offset && null !== offset, "missing offset");
					assert(offset + 1 < buf.length, "Trying to read beyond buffer length")
				}
				var len = buf.length;
				if (!(offset >= len)) {
					var val = _readUInt16(buf, offset, littleEndian, !0),
						neg = 32768 & val;
					return neg ? -1 * (65535 - val + 1) : val
				}
			}

			function _readInt32(buf, offset, littleEndian, noAssert) {
				if (!noAssert) {
					assert("boolean" == typeof littleEndian, "missing or invalid endian");
					assert(void 0 !== offset && null !== offset, "missing offset");
					assert(offset + 3 < buf.length, "Trying to read beyond buffer length")
				}
				var len = buf.length;
				if (!(offset >= len)) {
					var val = _readUInt32(buf, offset, littleEndian, !0),
						neg = 2147483648 & val;
					return neg ? -1 * (4294967295 - val + 1) : val
				}
			}

			function _readFloat(buf, offset, littleEndian, noAssert) {
				if (!noAssert) {
					assert("boolean" == typeof littleEndian, "missing or invalid endian");
					assert(offset + 3 < buf.length, "Trying to read beyond buffer length")
				}
				return ieee754.read(buf, offset, littleEndian, 23, 4)
			}

			function _readDouble(buf, offset, littleEndian, noAssert) {
				if (!noAssert) {
					assert("boolean" == typeof littleEndian, "missing or invalid endian");
					assert(offset + 7 < buf.length, "Trying to read beyond buffer length")
				}
				return ieee754.read(buf, offset, littleEndian, 52, 8)
			}

			function _writeUInt16(buf, value, offset, littleEndian, noAssert) {
				if (!noAssert) {
					assert(void 0 !== value && null !== value, "missing value");
					assert("boolean" == typeof littleEndian, "missing or invalid endian");
					assert(void 0 !== offset && null !== offset, "missing offset");
					assert(offset + 1 < buf.length, "trying to write beyond buffer length");
					verifuint(value, 65535)
				}
				var len = buf.length;
				if (!(offset >= len))
					for (var i = 0, j = Math.min(len - offset, 2); j > i; i++) buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> 8 * (littleEndian ? i : 1 - i)
			}

			function _writeUInt32(buf, value, offset, littleEndian, noAssert) {
				if (!noAssert) {
					assert(void 0 !== value && null !== value, "missing value");
					assert("boolean" == typeof littleEndian, "missing or invalid endian");
					assert(void 0 !== offset && null !== offset, "missing offset");
					assert(offset + 3 < buf.length, "trying to write beyond buffer length");
					verifuint(value, 4294967295)
				}
				var len = buf.length;
				if (!(offset >= len))
					for (var i = 0, j = Math.min(len - offset, 4); j > i; i++) buf[offset + i] = value >>> 8 * (littleEndian ? i : 3 - i) & 255
			}

			function _writeInt16(buf, value, offset, littleEndian, noAssert) {
				if (!noAssert) {
					assert(void 0 !== value && null !== value, "missing value");
					assert("boolean" == typeof littleEndian, "missing or invalid endian");
					assert(void 0 !== offset && null !== offset, "missing offset");
					assert(offset + 1 < buf.length, "Trying to write beyond buffer length");
					verifsint(value, 32767, -32768)
				}
				var len = buf.length;
				offset >= len || (value >= 0 ? _writeUInt16(buf, value, offset, littleEndian, noAssert) : _writeUInt16(buf, 65535 + value + 1, offset, littleEndian, noAssert))
			}

			function _writeInt32(buf, value, offset, littleEndian, noAssert) {
				if (!noAssert) {
					assert(void 0 !== value && null !== value, "missing value");
					assert("boolean" == typeof littleEndian, "missing or invalid endian");
					assert(void 0 !== offset && null !== offset, "missing offset");
					assert(offset + 3 < buf.length, "Trying to write beyond buffer length");
					verifsint(value, 2147483647, -2147483648)
				}
				var len = buf.length;
				offset >= len || (value >= 0 ? _writeUInt32(buf, value, offset, littleEndian, noAssert) : _writeUInt32(buf, 4294967295 + value + 1, offset, littleEndian, noAssert))
			}

			function _writeFloat(buf, value, offset, littleEndian, noAssert) {
				if (!noAssert) {
					assert(void 0 !== value && null !== value, "missing value");
					assert("boolean" == typeof littleEndian, "missing or invalid endian");
					assert(void 0 !== offset && null !== offset, "missing offset");
					assert(offset + 3 < buf.length, "Trying to write beyond buffer length");
					verifIEEE754(value, 3.4028234663852886e38, -3.4028234663852886e38)
				}
				var len = buf.length;
				offset >= len || ieee754.write(buf, value, offset, littleEndian, 23, 4)
			}

			function _writeDouble(buf, value, offset, littleEndian, noAssert) {
				if (!noAssert) {
					assert(void 0 !== value && null !== value, "missing value");
					assert("boolean" == typeof littleEndian, "missing or invalid endian");
					assert(void 0 !== offset && null !== offset, "missing offset");
					assert(offset + 7 < buf.length, "Trying to write beyond buffer length");
					verifIEEE754(value, 1.7976931348623157e308, -1.7976931348623157e308)
				}
				var len = buf.length;
				offset >= len || ieee754.write(buf, value, offset, littleEndian, 52, 8)
			}

			function stringtrim(str) {
				return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "")
			}

			function clamp(index, len, defaultValue) {
				if ("number" != typeof index) return defaultValue;
				index = ~~index;
				if (index >= len) return len;
				if (index >= 0) return index;
				index += len;
				return index >= 0 ? index : 0
			}

			function coerce(length) {
				length = ~~Math.ceil(+length);
				return 0 > length ? 0 : length
			}

			function isArray(subject) {
				return (Array.isArray || function (subject) {
					return "[object Array]" === Object.prototype.toString.call(subject)
				})(subject)
			}

			function isArrayish(subject) {
				return isArray(subject) || Buffer.isBuffer(subject) || subject && "object" == typeof subject && "number" == typeof subject.length
			}

			function toHex(n) {
				return 16 > n ? "0" + n.toString(16) : n.toString(16)
			}

			function utf8ToBytes(str) {
				for (var byteArray = [], i = 0; i < str.length; i++) {
					var b = str.charCodeAt(i);
					if (127 >= b) byteArray.push(str.charCodeAt(i));
					else {
						var start = i;
						b >= 55296 && 57343 >= b && i++;
						for (var h = encodeURIComponent(str.slice(start, i + 1)).substr(1).split("%"), j = 0; j < h.length; j++) byteArray.push(parseInt(h[j], 16))
					}
				}
				return byteArray
			}

			function asciiToBytes(str) {
				for (var byteArray = [], i = 0; i < str.length; i++) byteArray.push(255 & str.charCodeAt(i));
				return byteArray
			}

			function utf16leToBytes(str) {
				for (var c, hi, lo, byteArray = [], i = 0; i < str.length; i++) {
					c = str.charCodeAt(i);
					hi = c >> 8;
					lo = c % 256;
					byteArray.push(lo);
					byteArray.push(hi)
				}
				return byteArray
			}

			function base64ToBytes(str) {
				return base64.toByteArray(str)
			}

			function blitBuffer(src, dst, offset, length) {
				for (var i = 0; length > i && !(i + offset >= dst.length || i >= src.length); i++) dst[i + offset] = src[i];
				return i
			}

			function decodeUtf8Char(str) {
				try {
					return decodeURIComponent(str)
				} catch (err) {
					return String.fromCharCode(65533)
				}
			}

			function verifuint(value, max) {
				assert("number" == typeof value, "cannot write a non-number as a number");
				assert(value >= 0, "specified a negative value for writing an unsigned value");
				assert(max >= value, "value is larger than maximum value for type");
				assert(Math.floor(value) === value, "value has a fractional component")
			}

			function verifsint(value, max, min) {
				assert("number" == typeof value, "cannot write a non-number as a number");
				assert(max >= value, "value larger than maximum allowed value");
				assert(value >= min, "value smaller than minimum allowed value");
				assert(Math.floor(value) === value, "value has a fractional component")
			}

			function verifIEEE754(value, max, min) {
				assert("number" == typeof value, "cannot write a non-number as a number");
				assert(max >= value, "value larger than maximum allowed value");
				assert(value >= min, "value smaller than minimum allowed value")
			}

			function assert(test, message) {
				if (!test) throw new Error(message || "Failed assertion")
			}
			var base64 = require("base64-js"),
				ieee754 = require("ieee754");
			exports.Buffer = Buffer;
			exports.SlowBuffer = Buffer;
			exports.INSPECT_MAX_BYTES = 50;
			Buffer.poolSize = 8192;
			Buffer._useTypedArrays = function () {
				try {
					var buf = new ArrayBuffer(0),
						arr = new Uint8Array(buf);
					arr.foo = function () {
						return 42
					};
					return 42 === arr.foo() && "function" == typeof arr.subarray
				} catch (e) {
					return !1
				}
			}();
			Buffer.isEncoding = function (encoding) {
				switch (String(encoding).toLowerCase()) {
				case "hex":
				case "utf8":
				case "utf-8":
				case "ascii":
				case "binary":
				case "base64":
				case "raw":
				case "ucs2":
				case "ucs-2":
				case "utf16le":
				case "utf-16le":
					return !0;
				default:
					return !1
				}
			};
			Buffer.isBuffer = function (b) {
				return !(null === b || void 0 === b || !b._isBuffer)
			};
			Buffer.byteLength = function (str, encoding) {
				var ret;
				str += "";
				switch (encoding || "utf8") {
				case "hex":
					ret = str.length / 2;
					break;
				case "utf8":
				case "utf-8":
					ret = utf8ToBytes(str).length;
					break;
				case "ascii":
				case "binary":
				case "raw":
					ret = str.length;
					break;
				case "base64":
					ret = base64ToBytes(str).length;
					break;
				case "ucs2":
				case "ucs-2":
				case "utf16le":
				case "utf-16le":
					ret = 2 * str.length;
					break;
				default:
					throw new Error("Unknown encoding")
				}
				return ret
			};
			Buffer.concat = function (list, totalLength) {
				assert(isArray(list), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array.");
				if (0 === list.length) return new Buffer(0);
				if (1 === list.length) return list[0];
				var i;
				if ("number" != typeof totalLength) {
					totalLength = 0;
					for (i = 0; i < list.length; i++) totalLength += list[i].length
				}
				var buf = new Buffer(totalLength),
					pos = 0;
				for (i = 0; i < list.length; i++) {
					var item = list[i];
					item.copy(buf, pos);
					pos += item.length
				}
				return buf
			};
			Buffer.prototype.write = function (string, offset, length, encoding) {
				if (isFinite(offset)) {
					if (!isFinite(length)) {
						encoding = length;
						length = void 0
					}
				} else {
					var swap = encoding;
					encoding = offset;
					offset = length;
					length = swap
				}
				offset = Number(offset) || 0;
				var remaining = this.length - offset;
				if (length) {
					length = Number(length);
					length > remaining && (length = remaining)
				} else length = remaining;
				encoding = String(encoding || "utf8").toLowerCase();
				var ret;
				switch (encoding) {
				case "hex":
					ret = _hexWrite(this, string, offset, length);
					break;
				case "utf8":
				case "utf-8":
					ret = _utf8Write(this, string, offset, length);
					break;
				case "ascii":
					ret = _asciiWrite(this, string, offset, length);
					break;
				case "binary":
					ret = _binaryWrite(this, string, offset, length);
					break;
				case "base64":
					ret = _base64Write(this, string, offset, length);
					break;
				case "ucs2":
				case "ucs-2":
				case "utf16le":
				case "utf-16le":
					ret = _utf16leWrite(this, string, offset, length);
					break;
				default:
					throw new Error("Unknown encoding")
				}
				return ret
			};
			Buffer.prototype.toString = function (encoding, start, end) {
				var self = this;
				encoding = String(encoding || "utf8").toLowerCase();
				start = Number(start) || 0;
				end = void 0 !== end ? Number(end) : end = self.length;
				if (end === start) return "";
				var ret;
				switch (encoding) {
				case "hex":
					ret = _hexSlice(self, start, end);
					break;
				case "utf8":
				case "utf-8":
					ret = _utf8Slice(self, start, end);
					break;
				case "ascii":
					ret = _asciiSlice(self, start, end);
					break;
				case "binary":
					ret = _binarySlice(self, start, end);
					break;
				case "base64":
					ret = _base64Slice(self, start, end);
					break;
				case "ucs2":
				case "ucs-2":
				case "utf16le":
				case "utf-16le":
					ret = _utf16leSlice(self, start, end);
					break;
				default:
					throw new Error("Unknown encoding")
				}
				return ret
			};
			Buffer.prototype.toJSON = function () {
				return {
					type: "Buffer",
					data: Array.prototype.slice.call(this._arr || this, 0)
				}
			};
			Buffer.prototype.copy = function (target, target_start, start, end) {
				var source = this;
				start || (start = 0);
				end || 0 === end || (end = this.length);
				target_start || (target_start = 0);
				if (end !== start && 0 !== target.length && 0 !== source.length) {
					assert(end >= start, "sourceEnd < sourceStart");
					assert(target_start >= 0 && target_start < target.length, "targetStart out of bounds");
					assert(start >= 0 && start < source.length, "sourceStart out of bounds");
					assert(end >= 0 && end <= source.length, "sourceEnd out of bounds");
					end > this.length && (end = this.length);
					target.length - target_start < end - start && (end = target.length - target_start + start);
					var len = end - start;
					if (100 > len || !Buffer._useTypedArrays)
						for (var i = 0; len > i; i++) target[i + target_start] = this[i + start];
					else target._set(this.subarray(start, start + len), target_start)
				}
			};
			Buffer.prototype.slice = function (start, end) {
				var len = this.length;
				start = clamp(start, len, 0);
				end = clamp(end, len, len);
				if (Buffer._useTypedArrays) return Buffer._augment(this.subarray(start, end));
				for (var sliceLen = end - start, newBuf = new Buffer(sliceLen, void 0, !0), i = 0; sliceLen > i; i++) newBuf[i] = this[i + start];
				return newBuf
			};
			Buffer.prototype.get = function (offset) {
				console.log(".get() is deprecated. Access using array indexes instead.");
				return this.readUInt8(offset)
			};
			Buffer.prototype.set = function (v, offset) {
				console.log(".set() is deprecated. Access using array indexes instead.");
				return this.writeUInt8(v, offset)
			};
			Buffer.prototype.readUInt8 = function (offset, noAssert) {
				if (!noAssert) {
					assert(void 0 !== offset && null !== offset, "missing offset");
					assert(offset < this.length, "Trying to read beyond buffer length")
				}
				return offset >= this.length ? void 0 : this[offset]
			};
			Buffer.prototype.readUInt16LE = function (offset, noAssert) {
				return _readUInt16(this, offset, !0, noAssert)
			};
			Buffer.prototype.readUInt16BE = function (offset, noAssert) {
				return _readUInt16(this, offset, !1, noAssert)
			};
			Buffer.prototype.readUInt32LE = function (offset, noAssert) {
				return _readUInt32(this, offset, !0, noAssert)
			};
			Buffer.prototype.readUInt32BE = function (offset, noAssert) {
				return _readUInt32(this, offset, !1, noAssert)
			};
			Buffer.prototype.readInt8 = function (offset, noAssert) {
				if (!noAssert) {
					assert(void 0 !== offset && null !== offset, "missing offset");
					assert(offset < this.length, "Trying to read beyond buffer length")
				}
				if (!(offset >= this.length)) {
					var neg = 128 & this[offset];
					return neg ? -1 * (255 - this[offset] + 1) : this[offset]
				}
			};
			Buffer.prototype.readInt16LE = function (offset, noAssert) {
				return _readInt16(this, offset, !0, noAssert)
			};
			Buffer.prototype.readInt16BE = function (offset, noAssert) {
				return _readInt16(this, offset, !1, noAssert)
			};
			Buffer.prototype.readInt32LE = function (offset, noAssert) {
				return _readInt32(this, offset, !0, noAssert)
			};
			Buffer.prototype.readInt32BE = function (offset, noAssert) {
				return _readInt32(this, offset, !1, noAssert)
			};
			Buffer.prototype.readFloatLE = function (offset, noAssert) {
				return _readFloat(this, offset, !0, noAssert)
			};
			Buffer.prototype.readFloatBE = function (offset, noAssert) {
				return _readFloat(this, offset, !1, noAssert)
			};
			Buffer.prototype.readDoubleLE = function (offset, noAssert) {
				return _readDouble(this, offset, !0, noAssert)
			};
			Buffer.prototype.readDoubleBE = function (offset, noAssert) {
				return _readDouble(this, offset, !1, noAssert)
			};
			Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
				if (!noAssert) {
					assert(void 0 !== value && null !== value, "missing value");
					assert(void 0 !== offset && null !== offset, "missing offset");
					assert(offset < this.length, "trying to write beyond buffer length");
					verifuint(value, 255)
				}
				offset >= this.length || (this[offset] = value)
			};
			Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
				_writeUInt16(this, value, offset, !0, noAssert)
			};
			Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
				_writeUInt16(this, value, offset, !1, noAssert)
			};
			Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
				_writeUInt32(this, value, offset, !0, noAssert)
			};
			Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
				_writeUInt32(this, value, offset, !1, noAssert)
			};
			Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
				if (!noAssert) {
					assert(void 0 !== value && null !== value, "missing value");
					assert(void 0 !== offset && null !== offset, "missing offset");
					assert(offset < this.length, "Trying to write beyond buffer length");
					verifsint(value, 127, -128)
				}
				offset >= this.length || (value >= 0 ? this.writeUInt8(value, offset, noAssert) : this.writeUInt8(255 + value + 1, offset, noAssert))
			};
			Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
				_writeInt16(this, value, offset, !0, noAssert)
			};
			Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
				_writeInt16(this, value, offset, !1, noAssert)
			};
			Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
				_writeInt32(this, value, offset, !0, noAssert)
			};
			Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
				_writeInt32(this, value, offset, !1, noAssert)
			};
			Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
				_writeFloat(this, value, offset, !0, noAssert)
			};
			Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
				_writeFloat(this, value, offset, !1, noAssert)
			};
			Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
				_writeDouble(this, value, offset, !0, noAssert)
			};
			Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
				_writeDouble(this, value, offset, !1, noAssert)
			};
			Buffer.prototype.fill = function (value, start, end) {
				value || (value = 0);
				start || (start = 0);
				end || (end = this.length);
				"string" == typeof value && (value = value.charCodeAt(0));
				assert("number" == typeof value && !isNaN(value), "value is not a number");
				assert(end >= start, "end < start");
				if (end !== start && 0 !== this.length) {
					assert(start >= 0 && start < this.length, "start out of bounds");
					assert(end >= 0 && end <= this.length, "end out of bounds");
					for (var i = start; end > i; i++) this[i] = value
				}
			};
			Buffer.prototype.inspect = function () {
				for (var out = [], len = this.length, i = 0; len > i; i++) {
					out[i] = toHex(this[i]);
					if (i === exports.INSPECT_MAX_BYTES) {
						out[i + 1] = "...";
						break
					}
				}
				return "<Buffer " + out.join(" ") + ">"
			};
			Buffer.prototype.toArrayBuffer = function () {
				if ("undefined" != typeof Uint8Array) {
					if (Buffer._useTypedArrays) return new Buffer(this).buffer;
					for (var buf = new Uint8Array(this.length), i = 0, len = buf.length; len > i; i += 1) buf[i] = this[i];
					return buf.buffer
				}
				throw new Error("Buffer.toArrayBuffer not supported in this browser")
			};
			var BP = Buffer.prototype;
			Buffer._augment = function (arr) {
				arr._isBuffer = !0;
				arr._get = arr.get;
				arr._set = arr.set;
				arr.get = BP.get;
				arr.set = BP.set;
				arr.write = BP.write;
				arr.toString = BP.toString;
				arr.toLocaleString = BP.toString;
				arr.toJSON = BP.toJSON;
				arr.copy = BP.copy;
				arr.slice = BP.slice;
				arr.readUInt8 = BP.readUInt8;
				arr.readUInt16LE = BP.readUInt16LE;
				arr.readUInt16BE = BP.readUInt16BE;
				arr.readUInt32LE = BP.readUInt32LE;
				arr.readUInt32BE = BP.readUInt32BE;
				arr.readInt8 = BP.readInt8;
				arr.readInt16LE = BP.readInt16LE;
				arr.readInt16BE = BP.readInt16BE;
				arr.readInt32LE = BP.readInt32LE;
				arr.readInt32BE = BP.readInt32BE;
				arr.readFloatLE = BP.readFloatLE;
				arr.readFloatBE = BP.readFloatBE;
				arr.readDoubleLE = BP.readDoubleLE;
				arr.readDoubleBE = BP.readDoubleBE;
				arr.writeUInt8 = BP.writeUInt8;
				arr.writeUInt16LE = BP.writeUInt16LE;
				arr.writeUInt16BE = BP.writeUInt16BE;
				arr.writeUInt32LE = BP.writeUInt32LE;
				arr.writeUInt32BE = BP.writeUInt32BE;
				arr.writeInt8 = BP.writeInt8;
				arr.writeInt16LE = BP.writeInt16LE;
				arr.writeInt16BE = BP.writeInt16BE;
				arr.writeInt32LE = BP.writeInt32LE;
				arr.writeInt32BE = BP.writeInt32BE;
				arr.writeFloatLE = BP.writeFloatLE;
				arr.writeFloatBE = BP.writeFloatBE;
				arr.writeDoubleLE = BP.writeDoubleLE;
				arr.writeDoubleBE = BP.writeDoubleBE;
				arr.fill = BP.fill;
				arr.inspect = BP.inspect;
				arr.toArrayBuffer = BP.toArrayBuffer;
				return arr
			}
		}, {
			"base64-js": 2,
			ieee754: 3
		}
	],
	2: [
		function (require, module, exports) {
			var lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
			! function (exports) {
				"use strict";

				function decode(elt) {
					var code = elt.charCodeAt(0);
					return code === PLUS ? 62 : code === SLASH ? 63 : NUMBER > code ? -1 : NUMBER + 10 > code ? code - NUMBER + 26 + 26 : UPPER + 26 > code ? code - UPPER : LOWER + 26 > code ? code - LOWER + 26 : void 0
				}

				function b64ToByteArray(b64) {
					function push(v) {
						arr[L++] = v
					}
					var i, j, l, tmp, placeHolders, arr;
					if (b64.length % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
					var len = b64.length;
					placeHolders = "=" === b64.charAt(len - 2) ? 2 : "=" === b64.charAt(len - 1) ? 1 : 0;
					arr = new Arr(3 * b64.length / 4 - placeHolders);
					l = placeHolders > 0 ? b64.length - 4 : b64.length;
					var L = 0;
					for (i = 0, j = 0; l > i; i += 4, j += 3) {
						tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
						push((16711680 & tmp) >> 16);
						push((65280 & tmp) >> 8);
						push(255 & tmp)
					}
					if (2 === placeHolders) {
						tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
						push(255 & tmp)
					} else if (1 === placeHolders) {
						tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
						push(tmp >> 8 & 255);
						push(255 & tmp)
					}
					return arr
				}

				function uint8ToBase64(uint8) {
					function encode(num) {
						return lookup.charAt(num)
					}

					function tripletToBase64(num) {
						return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(63 & num)
					}
					var i, temp, length, extraBytes = uint8.length % 3,
						output = "";
					for (i = 0, length = uint8.length - extraBytes; length > i; i += 3) {
						temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
						output += tripletToBase64(temp)
					}
					switch (extraBytes) {
					case 1:
						temp = uint8[uint8.length - 1];
						output += encode(temp >> 2);
						output += encode(temp << 4 & 63);
						output += "==";
						break;
					case 2:
						temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
						output += encode(temp >> 10);
						output += encode(temp >> 4 & 63);
						output += encode(temp << 2 & 63);
						output += "="
					}
					return output
				}
				var Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array,
					PLUS = "+".charCodeAt(0),
					SLASH = "/".charCodeAt(0),
					NUMBER = "0".charCodeAt(0),
					LOWER = "a".charCodeAt(0),
					UPPER = "A".charCodeAt(0);
				exports.toByteArray = b64ToByteArray;
				exports.fromByteArray = uint8ToBase64
			}("undefined" == typeof exports ? this.base64js = {} : exports)
		}, {}
	],
	3: [
		function (require, module, exports) {
			exports.read = function (buffer, offset, isLE, mLen, nBytes) {
				var e, m, eLen = 8 * nBytes - mLen - 1,
					eMax = (1 << eLen) - 1,
					eBias = eMax >> 1,
					nBits = -7,
					i = isLE ? nBytes - 1 : 0,
					d = isLE ? -1 : 1,
					s = buffer[offset + i];
				i += d;
				e = s & (1 << -nBits) - 1;
				s >>= -nBits;
				nBits += eLen;
				for (; nBits > 0; e = 256 * e + buffer[offset + i], i += d, nBits -= 8);
				m = e & (1 << -nBits) - 1;
				e >>= -nBits;
				nBits += mLen;
				for (; nBits > 0; m = 256 * m + buffer[offset + i], i += d, nBits -= 8);
				if (0 === e) e = 1 - eBias;
				else {
					if (e === eMax) return m ? 0 / 0 : 1 / 0 * (s ? -1 : 1);
					m += Math.pow(2, mLen);
					e -= eBias
				}
				return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
			};
			exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
				var e, m, c, eLen = 8 * nBytes - mLen - 1,
					eMax = (1 << eLen) - 1,
					eBias = eMax >> 1,
					rt = 23 === mLen ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
					i = isLE ? 0 : nBytes - 1,
					d = isLE ? 1 : -1,
					s = 0 > value || 0 === value && 0 > 1 / value ? 1 : 0;
				value = Math.abs(value);
				if (isNaN(value) || 1 / 0 === value) {
					m = isNaN(value) ? 1 : 0;
					e = eMax
				} else {
					e = Math.floor(Math.log(value) / Math.LN2);
					if (value * (c = Math.pow(2, -e)) < 1) {
						e--;
						c *= 2
					}
					value += e + eBias >= 1 ? rt / c : rt * Math.pow(2, 1 - eBias);
					if (value * c >= 2) {
						e++;
						c /= 2
					}
					if (e + eBias >= eMax) {
						m = 0;
						e = eMax
					} else if (e + eBias >= 1) {
						m = (value * c - 1) * Math.pow(2, mLen);
						e += eBias
					} else {
						m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
						e = 0
					}
				}
				for (; mLen >= 8; buffer[offset + i] = 255 & m, i += d, m /= 256, mLen -= 8);
				e = e << mLen | m;
				eLen += mLen;
				for (; eLen > 0; buffer[offset + i] = 255 & e, i += d, e /= 256, eLen -= 8);
				buffer[offset + i - d] |= 128 * s
			}
		}, {}
	],
	4: [
		function (require, module) {
			function toArray(buf, bigEndian) {
				if (buf.length % intSize !== 0) {
					var len = buf.length + (intSize - buf.length % intSize);
					buf = Buffer.concat([buf, zeroBuffer], len)
				}
				for (var arr = [], fn = bigEndian ? buf.readInt32BE : buf.readInt32LE, i = 0; i < buf.length; i += intSize) arr.push(fn.call(buf, i));
				return arr
			}

			function toBuffer(arr, size, bigEndian) {
				for (var buf = new Buffer(size), fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE, i = 0; i < arr.length; i++) fn.call(buf, arr[i], 4 * i, !0);
				return buf
			}

			function hash(buf, fn, hashSize, bigEndian) {
				Buffer.isBuffer(buf) || (buf = new Buffer(buf));
				var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
				return toBuffer(arr, hashSize, bigEndian)
			}
			var Buffer = require("buffer").Buffer,
				intSize = 4,
				zeroBuffer = new Buffer(intSize);
			zeroBuffer.fill(0);
			var chrsz = 8;
			module.exports = {
				hash: hash
			}
		}, {
			buffer: 1
		}
	],
	5: [
		function (require, module, exports) {
			function hmac(fn, key, data) {
				Buffer.isBuffer(key) || (key = new Buffer(key));
				Buffer.isBuffer(data) || (data = new Buffer(data));
				key.length > blocksize ? key = fn(key) : key.length < blocksize && (key = Buffer.concat([key, zeroBuffer], blocksize));
				for (var ipad = new Buffer(blocksize), opad = new Buffer(blocksize), i = 0; blocksize > i; i++) {
					ipad[i] = 54 ^ key[i];
					opad[i] = 92 ^ key[i]
				}
				var hash = fn(Buffer.concat([ipad, data]));
				return fn(Buffer.concat([opad, hash]))
			}

			function hash(alg, key) {
				alg = alg || "sha1";
				var fn = algorithms[alg],
					bufs = [],
					length = 0;
				fn || error("algorithm:", alg, "is not yet supported");
				return {
					update: function (data) {
						Buffer.isBuffer(data) || (data = new Buffer(data));
						bufs.push(data);
						length += data.length;
						return this
					},
					digest: function (enc) {
						var buf = Buffer.concat(bufs),
							r = key ? hmac(fn, key, buf) : fn(buf);
						bufs = null;
						return enc ? r.toString(enc) : r
					}
				}
			}

			function error() {
				var m = [].slice.call(arguments).join(" ");
				throw new Error([m, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"))
			}

			function each(a, f) {
				for (var i in a) f(a[i], i)
			}
			var Buffer = require("buffer").Buffer,
				sha = require("./sha"),
				sha256 = require("./sha256"),
				rng = require("./rng"),
				md5 = require("./md5"),
				algorithms = {
					sha1: sha,
					sha256: sha256,
					md5: md5
				},
				blocksize = 64,
				zeroBuffer = new Buffer(blocksize);
			zeroBuffer.fill(0);
			exports.createHash = function (alg) {
				return hash(alg)
			};
			exports.createHmac = function (alg, key) {
				return hash(alg, key)
			};
			exports.randomBytes = function (size, callback) {
				if (!callback || !callback.call) return new Buffer(rng(size));
				try {
					callback.call(this, void 0, new Buffer(rng(size)))
				} catch (err) {
					callback(err)
				}
			};
			each(["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], function (name) {
				exports[name] = function () {
					error("sorry,", name, "is not implemented yet")
				}
			})
		}, {
			"./md5": 6,
			"./rng": 7,
			"./sha": 8,
			"./sha256": 9,
			buffer: 1
		}
	],
	6: [
		function (require, module) {
			function core_md5(x, len) {
				x[len >> 5] |= 128 << len % 32;
				x[(len + 64 >>> 9 << 4) + 14] = len;
				for (var a = 1732584193, b = -271733879, c = -1732584194, d = 271733878, i = 0; i < x.length; i += 16) {
					var olda = a,
						oldb = b,
						oldc = c,
						oldd = d;
					a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
					d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
					c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
					b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
					a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
					d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
					c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
					b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
					a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
					d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
					c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
					b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
					a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
					d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
					c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
					b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
					a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
					d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
					c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
					b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
					a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
					d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
					c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
					b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
					a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
					d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
					c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
					b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
					a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
					d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
					c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
					b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
					a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
					d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
					c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
					b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
					a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
					d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
					c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
					b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
					a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
					d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
					c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
					b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
					a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
					d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
					c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
					b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
					a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
					d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
					c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
					b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
					a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
					d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
					c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
					b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
					a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
					d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
					c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
					b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
					a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
					d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
					c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
					b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
					a = safe_add(a, olda);
					b = safe_add(b, oldb);
					c = safe_add(c, oldc);
					d = safe_add(d, oldd)
				}
				return Array(a, b, c, d)
			}

			function md5_cmn(q, a, b, x, s, t) {
				return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b)
			}

			function md5_ff(a, b, c, d, x, s, t) {
				return md5_cmn(b & c | ~b & d, a, b, x, s, t)
			}

			function md5_gg(a, b, c, d, x, s, t) {
				return md5_cmn(b & d | c & ~d, a, b, x, s, t)
			}

			function md5_hh(a, b, c, d, x, s, t) {
				return md5_cmn(b ^ c ^ d, a, b, x, s, t)
			}

			function md5_ii(a, b, c, d, x, s, t) {
				return md5_cmn(c ^ (b | ~d), a, b, x, s, t)
			}

			function safe_add(x, y) {
				var lsw = (65535 & x) + (65535 & y),
					msw = (x >> 16) + (y >> 16) + (lsw >> 16);
				return msw << 16 | 65535 & lsw
			}

			function bit_rol(num, cnt) {
				return num << cnt | num >>> 32 - cnt
			}
			var helpers = require("./helpers");
			module.exports = function (buf) {
				return helpers.hash(buf, core_md5, 16)
			}
		}, {
			"./helpers": 4
		}
	],
	7: [
		function (require, module) {
			! function () {
				var mathRNG, whatwgRNG, _global = this;
				mathRNG = function (size) {
					for (var r, r, bytes = new Array(size), i = 0; size > i; i++) {
						0 == (3 & i) && (r = 4294967296 * Math.random());
						bytes[i] = r >>> ((3 & i) << 3) & 255
					}
					return bytes
				};
				_global.crypto && crypto.getRandomValues && (whatwgRNG = function (size) {
					var bytes = new Uint8Array(size);
					crypto.getRandomValues(bytes);
					return bytes
				});
				module.exports = whatwgRNG || mathRNG
			}()
		}, {}
	],
	8: [
		function (require, module) {
			function core_sha1(x, len) {
				x[len >> 5] |= 128 << 24 - len % 32;
				x[(len + 64 >> 9 << 4) + 15] = len;
				for (var w = Array(80), a = 1732584193, b = -271733879, c = -1732584194, d = 271733878, e = -1009589776, i = 0; i < x.length; i += 16) {
					for (var olda = a, oldb = b, oldc = c, oldd = d, olde = e, j = 0; 80 > j; j++) {
						w[j] = 16 > j ? x[i + j] : rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
						var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
						e = d;
						d = c;
						c = rol(b, 30);
						b = a;
						a = t
					}
					a = safe_add(a, olda);
					b = safe_add(b, oldb);
					c = safe_add(c, oldc);
					d = safe_add(d, oldd);
					e = safe_add(e, olde)
				}
				return Array(a, b, c, d, e)
			}

			function sha1_ft(t, b, c, d) {
				return 20 > t ? b & c | ~b & d : 40 > t ? b ^ c ^ d : 60 > t ? b & c | b & d | c & d : b ^ c ^ d
			}

			function sha1_kt(t) {
				return 20 > t ? 1518500249 : 40 > t ? 1859775393 : 60 > t ? -1894007588 : -899497514
			}

			function safe_add(x, y) {
				var lsw = (65535 & x) + (65535 & y),
					msw = (x >> 16) + (y >> 16) + (lsw >> 16);
				return msw << 16 | 65535 & lsw
			}

			function rol(num, cnt) {
				return num << cnt | num >>> 32 - cnt
			}
			var helpers = require("./helpers");
			module.exports = function (buf) {
				return helpers.hash(buf, core_sha1, 20, !0)
			}
		}, {
			"./helpers": 4
		}
	],
	9: [
		function (require, module) {
			var helpers = require("./helpers"),
				safe_add = function (x, y) {
					var lsw = (65535 & x) + (65535 & y),
						msw = (x >> 16) + (y >> 16) + (lsw >> 16);
					return msw << 16 | 65535 & lsw
				},
				S = function (X, n) {
					return X >>> n | X << 32 - n
				},
				R = function (X, n) {
					return X >>> n
				},
				Ch = function (x, y, z) {
					return x & y ^ ~x & z
				},
				Maj = function (x, y, z) {
					return x & y ^ x & z ^ y & z
				},
				Sigma0256 = function (x) {
					return S(x, 2) ^ S(x, 13) ^ S(x, 22)
				},
				Sigma1256 = function (x) {
					return S(x, 6) ^ S(x, 11) ^ S(x, 25)
				},
				Gamma0256 = function (x) {
					return S(x, 7) ^ S(x, 18) ^ R(x, 3)
				},
				Gamma1256 = function (x) {
					return S(x, 17) ^ S(x, 19) ^ R(x, 10)
				},
				core_sha256 = function (m, l) {
					var a, b, c, d, e, f, g, h, i, j, T1, T2, K = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298),
						HASH = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225),
						W = new Array(64);
					m[l >> 5] |= 128 << 24 - l % 32;
					m[(l + 64 >> 9 << 4) + 15] = l;
					for (var i = 0; i < m.length; i += 16) {
						a = HASH[0];
						b = HASH[1];
						c = HASH[2];
						d = HASH[3];
						e = HASH[4];
						f = HASH[5];
						g = HASH[6];
						h = HASH[7];
						for (var j = 0; 64 > j; j++) {
							W[j] = 16 > j ? m[j + i] : safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
							T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
							T2 = safe_add(Sigma0256(a), Maj(a, b, c));
							h = g;
							g = f;
							f = e;
							e = safe_add(d, T1);
							d = c;
							c = b;
							b = a;
							a = safe_add(T1, T2)
						}
						HASH[0] = safe_add(a, HASH[0]);
						HASH[1] = safe_add(b, HASH[1]);
						HASH[2] = safe_add(c, HASH[2]);
						HASH[3] = safe_add(d, HASH[3]);
						HASH[4] = safe_add(e, HASH[4]);
						HASH[5] = safe_add(f, HASH[5]);
						HASH[6] = safe_add(g, HASH[6]);
						HASH[7] = safe_add(h, HASH[7])
					}
					return HASH
				};
			module.exports = function (buf) {
				return helpers.hash(buf, core_sha256, 32, !0)
			}
		}, {
			"./helpers": 4
		}
	],
	events: [
		function (require, module) {
			module.exports = require("T9Wsc/")
		}, {}
	],
	"T9Wsc/": [
		function (require, module) {
			function EventEmitter() {
				this._events = this._events || {};
				this._maxListeners = this._maxListeners || void 0
			}

			function isFunction(arg) {
				return "function" == typeof arg
			}

			function isNumber(arg) {
				return "number" == typeof arg
			}

			function isObject(arg) {
				return "object" == typeof arg && null !== arg
			}

			function isUndefined(arg) {
				return void 0 === arg
			}
			module.exports = EventEmitter;
			EventEmitter.EventEmitter = EventEmitter;
			EventEmitter.prototype._events = void 0;
			EventEmitter.prototype._maxListeners = void 0;
			EventEmitter.defaultMaxListeners = 10;
			EventEmitter.prototype.setMaxListeners = function (n) {
				if (!isNumber(n) || 0 > n || isNaN(n)) throw TypeError("n must be a positive number");
				this._maxListeners = n;
				return this
			};
			EventEmitter.prototype.emit = function (type) {
				var er, handler, len, args, i, listeners;
				this._events || (this._events = {});
				if ("error" === type && (!this._events.error || isObject(this._events.error) && !this._events.error.length)) {
					er = arguments[1];
					throw er instanceof Error ? er : TypeError('Uncaught, unspecified "error" event.')
				}
				handler = this._events[type];
				if (isUndefined(handler)) return !1;
				if (isFunction(handler)) switch (arguments.length) {
				case 1:
					handler.call(this);
					break;
				case 2:
					handler.call(this, arguments[1]);
					break;
				case 3:
					handler.call(this, arguments[1], arguments[2]);
					break;
				default:
					len = arguments.length;
					args = new Array(len - 1);
					for (i = 1; len > i; i++) args[i - 1] = arguments[i];
					handler.apply(this, args)
				} else if (isObject(handler)) {
					len = arguments.length;
					args = new Array(len - 1);
					for (i = 1; len > i; i++) args[i - 1] = arguments[i];
					listeners = handler.slice();
					len = listeners.length;
					for (i = 0; len > i; i++) listeners[i].apply(this, args)
				}
				return !0
			};
			EventEmitter.prototype.addListener = function (type, listener) {
				var m;
				if (!isFunction(listener)) throw TypeError("listener must be a function");
				this._events || (this._events = {});
				this._events.newListener && this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener);
				this._events[type] ? isObject(this._events[type]) ? this._events[type].push(listener) : this._events[type] = [this._events[type], listener] : this._events[type] = listener;
				if (isObject(this._events[type]) && !this._events[type].warned) {
					var m;
					m = isUndefined(this._maxListeners) ? EventEmitter.defaultMaxListeners : this._maxListeners;
					if (m && m > 0 && this._events[type].length > m) {
						this._events[type].warned = !0;
						console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[type].length);
						"function" == typeof console.trace && console.trace()
					}
				}
				return this
			};
			EventEmitter.prototype.on = EventEmitter.prototype.addListener;
			EventEmitter.prototype.once = function (type, listener) {
				function g() {
					this.removeListener(type, g);
					if (!fired) {
						fired = !0;
						listener.apply(this, arguments)
					}
				}
				if (!isFunction(listener)) throw TypeError("listener must be a function");
				var fired = !1;
				g.listener = listener;
				this.on(type, g);
				return this
			};
			EventEmitter.prototype.removeListener = function (type, listener) {
				var list, position, length, i;
				if (!isFunction(listener)) throw TypeError("listener must be a function");
				if (!this._events || !this._events[type]) return this;
				list = this._events[type];
				length = list.length;
				position = -1;
				if (list === listener || isFunction(list.listener) && list.listener === listener) {
					delete this._events[type];
					this._events.removeListener && this.emit("removeListener", type, listener)
				} else if (isObject(list)) {
					for (i = length; i-- > 0;)
						if (list[i] === listener || list[i].listener && list[i].listener === listener) {
							position = i;
							break
						}
					if (0 > position) return this;
					if (1 === list.length) {
						list.length = 0;
						delete this._events[type]
					} else list.splice(position, 1);
					this._events.removeListener && this.emit("removeListener", type, listener)
				}
				return this
			};
			EventEmitter.prototype.removeAllListeners = function (type) {
				var key, listeners;
				if (!this._events) return this;
				if (!this._events.removeListener) {
					0 === arguments.length ? this._events = {} : this._events[type] && delete this._events[type];
					return this
				}
				if (0 === arguments.length) {
					for (key in this._events) "removeListener" !== key && this.removeAllListeners(key);
					this.removeAllListeners("removeListener");
					this._events = {};
					return this
				}
				listeners = this._events[type];
				if (isFunction(listeners)) this.removeListener(type, listeners);
				else
					for (; listeners.length;) this.removeListener(type, listeners[listeners.length - 1]);
				delete this._events[type];
				return this
			};
			EventEmitter.prototype.listeners = function (type) {
				var ret;
				ret = this._events && this._events[type] ? isFunction(this._events[type]) ? [this._events[type]] : this._events[type].slice() : [];
				return ret
			};
			EventEmitter.listenerCount = function (emitter, type) {
				var ret;
				ret = emitter._events && emitter._events[type] ? isFunction(emitter._events[type]) ? 1 : emitter._events[type].length : 0;
				return ret
			}
		}, {}
	],
	12: [
		function (require, module) {
			var process = module.exports = {};
			process.nextTick = function () {
				var canSetImmediate = "undefined" != typeof window && window.setImmediate,
					canPost = "undefined" != typeof window && window.postMessage && window.addEventListener;
				if (canSetImmediate) return function (f) {
					return window.setImmediate(f)
				};
				if (canPost) {
					var queue = [];
					window.addEventListener("message", function (ev) {
						var source = ev.source;
						if ((source === window || null === source) && "process-tick" === ev.data) {
							ev.stopPropagation();
							if (queue.length > 0) {
								var fn = queue.shift();
								fn()
							}
						}
					}, !0);
					return function (fn) {
						queue.push(fn);
						window.postMessage("process-tick", "*")
					}
				}
				return function (fn) {
					setTimeout(fn, 0)
				}
			}();
			process.title = "browser";
			process.browser = !0;
			process.env = {};
			process.argv = [];
			process.binding = function () {
				throw new Error("process.binding is not supported")
			};
			process.cwd = function () {
				return "/"
			};
			process.chdir = function () {
				throw new Error("process.chdir is not supported")
			}
		}, {}
	],
	13: [
		function (require, module) {
			function Proto(cons, opts) {
				var self = this;
				EventEmitter.call(self);
				opts || (opts = {});
				self.remote = {};
				self.callbacks = {
					local: [],
					remote: []
				};
				self.wrap = opts.wrap;
				self.unwrap = opts.unwrap;
				self.scrubber = scrubber(self.callbacks.local);
				self.instance = "function" == typeof cons ? new cons(self.remote, self) : cons || {}
			}
			var EventEmitter = require("events").EventEmitter,
				scrubber = require("./lib/scrub"),
				objectKeys = require("./lib/keys"),
				forEach = require("./lib/foreach"),
				isEnumerable = require("./lib/is_enum");
			module.exports = function (cons, opts) {
				return new Proto(cons, opts)
			};
			! function () {
				for (var key in EventEmitter.prototype) Proto.prototype[key] = EventEmitter.prototype[key]
			}();
			Proto.prototype.start = function () {
				this.request("methods", [this.instance])
			};
			Proto.prototype.cull = function (id) {
				delete this.callbacks.remote[id];
				this.emit("request", {
					method: "cull",
					arguments: [id]
				})
			};
			Proto.prototype.request = function (method, args) {
				var scrub = this.scrubber.scrub(args);
				this.emit("request", {
					method: method,
					arguments: scrub.arguments,
					callbacks: scrub.callbacks,
					links: scrub.links
				})
			};
			Proto.prototype.handle = function (req) {
				var self = this,
					args = self.scrubber.unscrub(req, function (id) {
						if (void 0 === self.callbacks.remote[id]) {
							var cb = function () {
								self.request(id, [].slice.apply(arguments))
							};
							self.callbacks.remote[id] = self.wrap ? self.wrap(cb, id) : cb;
							return cb
						}
						return self.unwrap ? self.unwrap(self.callbacks.remote[id], id) : self.callbacks.remote[id]
					});
				if ("methods" === req.method) self.handleMethods(args[0]);
				else if ("cull" === req.method) forEach(args, function (id) {
					delete self.callbacks.local[id]
				});
				else if ("string" == typeof req.method) isEnumerable(self.instance, req.method) ? self.apply(self.instance[req.method], args) : self.emit("fail", new Error("request for non-enumerable method: " + req.method));
				else if ("number" == typeof req.method) {
					var fn = self.callbacks.local[req.method];
					fn ? self.apply(fn, args) : self.emit("fail", new Error("no such method"))
				}
			};
			Proto.prototype.handleMethods = function (methods) {
				var self = this;
				"object" != typeof methods && (methods = {});
				forEach(objectKeys(self.remote), function (key) {
					delete self.remote[key]
				});
				forEach(objectKeys(methods), function (key) {
					self.remote[key] = methods[key]
				});
				self.emit("remote", self.remote);
				self.emit("ready")
			};
			Proto.prototype.apply = function (f, args) {
				try {
					f.apply(void 0, args)
				} catch (err) {
					this.emit("error", err)
				}
			}
		}, {
			"./lib/foreach": 14,
			"./lib/is_enum": 15,
			"./lib/keys": 16,
			"./lib/scrub": 17,
			events: "T9Wsc/"
		}
	],
	14: [
		function (require, module) {
			module.exports = function (xs, f) {
				if (xs.forEach) return xs.forEach(f);
				for (var i = 0; i < xs.length; i++) f.call(xs, xs[i], i)
			}
		}, {}
	],
	15: [
		function (require, module) {
			var objectKeys = require("./keys");
			module.exports = function (obj, key) {
				if (Object.prototype.propertyIsEnumerable) return Object.prototype.propertyIsEnumerable.call(obj, key);
				for (var keys = objectKeys(obj), i = 0; i < keys.length; i++)
					if (key === keys[i]) return !0;
				return !1
			}
		}, {
			"./keys": 16
		}
	],
	16: [
		function (require, module) {
			module.exports = Object.keys || function (obj) {
				var keys = [];
				for (var key in obj) keys.push(key);
				return keys
			}
		}, {}
	],
	17: [
		function (require, module) {
			function indexOf(xs, x) {
				if (xs.indexOf) return xs.indexOf(x);
				for (var i = 0; i < xs.length; i++)
					if (xs[i] === x) return i;
				return -1
			}

			function Scrubber(callbacks) {
				this.callbacks = callbacks
			}
			var traverse = require("traverse"),
				objectKeys = require("./keys"),
				forEach = require("./foreach");
			module.exports = function (callbacks) {
				return new Scrubber(callbacks)
			};
			Scrubber.prototype.scrub = function (obj) {
				var self = this,
					paths = {},
					links = [],
					args = traverse(obj).map(function (node) {
						if ("function" == typeof node) {
							var i = indexOf(self.callbacks, node);
							if (i >= 0 && !(i in paths)) paths[i] = this.path;
							else {
								var id = self.callbacks.length;
								self.callbacks.push(node);
								paths[id] = this.path
							}
							this.update("[Function]")
						} else if (this.circular) {
							links.push({
								from: this.circular.path,
								to: this.path
							});
							this.update("[Circular]")
						}
					});
				return {
					arguments: args,
					callbacks: paths,
					links: links
				}
			};
			Scrubber.prototype.unscrub = function (msg, f) {
				var args = msg.arguments || [];
				forEach(objectKeys(msg.callbacks || {}), function (sid) {
					var id = parseInt(sid, 10),
						path = msg.callbacks[id];
					traverse.set(args, path, f(id))
				});
				forEach(msg.links || [], function (link) {
					var value = traverse.get(args, link.from);
					traverse.set(args, link.to, value)
				});
				return args
			}
		}, {
			"./foreach": 14,
			"./keys": 16,
			traverse: 18
		}
	],
	18: [
		function (require, module) {
			function Traverse(obj) {
				this.value = obj
			}

			function walk(root, cb, immutable) {
				var path = [],
					parents = [],
					alive = !0;
				return function walker(node_) {
					function updateState() {
						if ("object" == typeof state.node && null !== state.node) {
							state.keys && state.node_ === state.node || (state.keys = objectKeys(state.node));
							state.isLeaf = 0 == state.keys.length;
							for (var i = 0; i < parents.length; i++)
								if (parents[i].node_ === node_) {
									state.circular = parents[i];
									break
								}
						} else {
							state.isLeaf = !0;
							state.keys = null
						}
						state.notLeaf = !state.isLeaf;
						state.notRoot = !state.isRoot
					}
					var node = immutable ? copy(node_) : node_,
						modifiers = {},
						keepGoing = !0,
						state = {
							node: node,
							node_: node_,
							path: [].concat(path),
							parent: parents[parents.length - 1],
							parents: parents,
							key: path.slice(-1)[0],
							isRoot: 0 === path.length,
							level: path.length,
							circular: null,
							update: function (x, stopHere) {
								state.isRoot || (state.parent.node[state.key] = x);
								state.node = x;
								stopHere && (keepGoing = !1)
							},
							"delete": function (stopHere) {
								delete state.parent.node[state.key];
								stopHere && (keepGoing = !1)
							},
							remove: function (stopHere) {
								isArray(state.parent.node) ? state.parent.node.splice(state.key, 1) : delete state.parent.node[state.key];
								stopHere && (keepGoing = !1)
							},
							keys: null,
							before: function (f) {
								modifiers.before = f
							},
							after: function (f) {
								modifiers.after = f
							},
							pre: function (f) {
								modifiers.pre = f
							},
							post: function (f) {
								modifiers.post = f
							},
							stop: function () {
								alive = !1
							},
							block: function () {
								keepGoing = !1
							}
						};
					if (!alive) return state;
					updateState();
					var ret = cb.call(state, state.node);
					void 0 !== ret && state.update && state.update(ret);
					modifiers.before && modifiers.before.call(state, state.node);
					if (!keepGoing) return state;
					if ("object" == typeof state.node && null !== state.node && !state.circular) {
						parents.push(state);
						updateState();
						forEach(state.keys, function (key, i) {
							path.push(key);
							modifiers.pre && modifiers.pre.call(state, state.node[key], key);
							var child = walker(state.node[key]);
							immutable && hasOwnProperty.call(state.node, key) && (state.node[key] = child.node);
							child.isLast = i == state.keys.length - 1;
							child.isFirst = 0 == i;
							modifiers.post && modifiers.post.call(state, child);
							path.pop()
						});
						parents.pop()
					}
					modifiers.after && modifiers.after.call(state, state.node);
					return state
				}(root).node
			}

			function copy(src) {
				if ("object" == typeof src && null !== src) {
					var dst;
					if (isArray(src)) dst = [];
					else if (isDate(src)) dst = new Date(src.getTime ? src.getTime() : src);
					else if (isRegExp(src)) dst = new RegExp(src);
					else if (isError(src)) dst = {
						message: src.message
					};
					else if (isBoolean(src)) dst = new Boolean(src);
					else if (isNumber(src)) dst = new Number(src);
					else if (isString(src)) dst = new String(src);
					else if (Object.create && Object.getPrototypeOf) dst = Object.create(Object.getPrototypeOf(src));
					else if (src.constructor === Object) dst = {};
					else {
						var proto = src.constructor && src.constructor.prototype || src.__proto__ || {},
							T = function () {};
						T.prototype = proto;
						dst = new T
					}
					forEach(objectKeys(src), function (key) {
						dst[key] = src[key]
					});
					return dst
				}
				return src
			}

			function toS(obj) {
				return Object.prototype.toString.call(obj)
			}

			function isDate(obj) {
				return "[object Date]" === toS(obj)
			}

			function isRegExp(obj) {
				return "[object RegExp]" === toS(obj)
			}

			function isError(obj) {
				return "[object Error]" === toS(obj)
			}

			function isBoolean(obj) {
				return "[object Boolean]" === toS(obj)
			}

			function isNumber(obj) {
				return "[object Number]" === toS(obj)
			}

			function isString(obj) {
				return "[object String]" === toS(obj)
			}
			var traverse = module.exports = function (obj) {
				return new Traverse(obj)
			};
			Traverse.prototype.get = function (ps) {
				for (var node = this.value, i = 0; i < ps.length; i++) {
					var key = ps[i];
					if (!node || !hasOwnProperty.call(node, key)) {
						node = void 0;
						break
					}
					node = node[key]
				}
				return node
			};
			Traverse.prototype.has = function (ps) {
				for (var node = this.value, i = 0; i < ps.length; i++) {
					var key = ps[i];
					if (!node || !hasOwnProperty.call(node, key)) return !1;
					node = node[key]
				}
				return !0
			};
			Traverse.prototype.set = function (ps, value) {
				for (var node = this.value, i = 0; i < ps.length - 1; i++) {
					var key = ps[i];
					hasOwnProperty.call(node, key) || (node[key] = {});
					node = node[key]
				}
				node[ps[i]] = value;
				return value
			};
			Traverse.prototype.map = function (cb) {
				return walk(this.value, cb, !0)
			};
			Traverse.prototype.forEach = function (cb) {
				this.value = walk(this.value, cb, !1);
				return this.value
			};
			Traverse.prototype.reduce = function (cb, init) {
				var skip = 1 === arguments.length,
					acc = skip ? this.value : init;
				this.forEach(function (x) {
					this.isRoot && skip || (acc = cb.call(this, acc, x))
				});
				return acc
			};
			Traverse.prototype.paths = function () {
				var acc = [];
				this.forEach(function () {
					acc.push(this.path)
				});
				return acc
			};
			Traverse.prototype.nodes = function () {
				var acc = [];
				this.forEach(function () {
					acc.push(this.node)
				});
				return acc
			};
			Traverse.prototype.clone = function () {
				var parents = [],
					nodes = [];
				return function clone(src) {
					for (var i = 0; i < parents.length; i++)
						if (parents[i] === src) return nodes[i];
					if ("object" == typeof src && null !== src) {
						var dst = copy(src);
						parents.push(src);
						nodes.push(dst);
						forEach(objectKeys(src), function (key) {
							dst[key] = clone(src[key])
						});
						parents.pop();
						nodes.pop();
						return dst
					}
					return src
				}(this.value)
			};
			var objectKeys = Object.keys || function (obj) {
					var res = [];
					for (var key in obj) res.push(key);
					return res
				},
				isArray = Array.isArray || function (xs) {
					return "[object Array]" === Object.prototype.toString.call(xs)
				},
				forEach = function (xs, fn) {
					if (xs.forEach) return xs.forEach(fn);
					for (var i = 0; i < xs.length; i++) fn(xs[i], i, xs)
				};
			forEach(objectKeys(Traverse.prototype), function (key) {
				traverse[key] = function (obj) {
					var args = [].slice.call(arguments, 1),
						t = new Traverse(obj);
					return t[key].apply(t, args)
				}
			});
			var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
				return key in obj
			}
		}, {}
	],
	19: [
		function (require, module) {
			module.exports = require("./lib/jwt")
		}, {
			"./lib/jwt": 20
		}
	],
	20: [
		function (require, module) {
			(function (Buffer) {
				function verify(input, key, method, type, signature) {
					if ("hmac" === type) return signature === sign(input, key, method, type);
					if ("sign" == type) return crypto.createVerify(method).update(input).verify(key, base64urlUnescape(signature), "base64");
					throw new Error("Algorithm type not recognized")
				}

				function sign(input, key, method, type) {
					var base64str;
					if ("hmac" === type) base64str = crypto.createHmac(method, key).update(input).digest("base64");
					else {
						if ("sign" != type) throw new Error("Algorithm type not recognized");
						base64str = crypto.createSign(method).update(input).sign(key, "base64")
					}
					return base64urlEscape(base64str)
				}

				function base64urlDecode(str) {
					return new Buffer(base64urlUnescape(str), "base64").toString()
				}

				function base64urlUnescape(str) {
					str += Array(5 - str.length % 4).join("=");
					return str.replace(/\-/g, "+").replace(/_/g, "/")
				}

				function base64urlEncode(str) {
					return base64urlEscape(new Buffer(str).toString("base64"))
				}

				function base64urlEscape(str) {
					return str.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "")
				}
				var crypto = require("crypto"),
					algorithmMap = {
						HS256: "sha256",
						HS384: "sha384",
						HS512: "sha512",
						RS256: "RSA-SHA256"
					},
					typeMap = {
						HS256: "hmac",
						HS384: "hmac",
						HS512: "hmac",
						RS256: "sign"
					},
					jwt = module.exports;
				jwt.version = "0.2.0";
				jwt.decode = function (token, key, noVerify) {
					var segments = token.split(".");
					if (3 !== segments.length) throw new Error("Not enough or too many segments");
					var headerSeg = segments[0],
						payloadSeg = segments[1],
						signatureSeg = segments[2],
						header = JSON.parse(base64urlDecode(headerSeg)),
						payload = JSON.parse(base64urlDecode(payloadSeg));
					if (!noVerify) {
						var signingMethod = algorithmMap[header.alg],
							signingType = typeMap[header.alg];
						if (!signingMethod || !signingType) throw new Error("Algorithm not supported");
						var signingInput = [headerSeg, payloadSeg].join(".");
						if (!verify(signingInput, key, signingMethod, signingType, signatureSeg)) throw new Error("Signature verification failed")
					}
					return payload
				};
				jwt.encode = function (payload, key, algorithm) {
					if (!key) throw new Error("Require key");
					algorithm || (algorithm = "HS256");
					var signingMethod = algorithmMap[algorithm],
						signingType = typeMap[algorithm];
					if (!signingMethod || !signingType) throw new Error("Algorithm not supported");
					var header = {
							typ: "JWT",
							alg: algorithm
						},
						segments = [];
					segments.push(base64urlEncode(JSON.stringify(header)));
					segments.push(base64urlEncode(JSON.stringify(payload)));
					segments.push(sign(segments.join("."), key, signingMethod, signingType));
					return segments.join(".")
				}
			}).call(this, require("buffer").Buffer)
		}, {
			buffer: 1,
			crypto: 5
		}
	],
	21: [
		function (require, module) {
			"use strict";

			function tryToParseJson(string, reviver) {
				var result;
				try {
					result = JSON.parse(string, reviver)
				} catch (error) {
					result = void 0
				}
				return result
			}
			module.exports = tryToParseJson
		}, {}
	],
	22: [
		function (require, module) {
			module.exports = {
				name: "kite.js",
				description: "Kite client library",
				main: "index.js",
				version: "0.3.3",
				scripts: {
					test: "KITE_HOME=. KITE_KEY=$(cat ./kontrol_client.key) node ./test/index.js",
					prepublish: "gulp"
				},
				author: {
					name: "Koding Team",
					email: "team@koding.com",
					website: "https://koding.com"
				},
				contributors: [{
					name: "Fatih Arslan",
					email: "fatih@koding.com"
				}, {
					name: "Cenk Alti",
					email: "cenk@koding.com"
				}, {
					name: "Christopher Thorn",
					email: "chris@koding.com"
				}],
				repository: "https://github.com/koding/kite.js.git",
				license: "MIT",
				dependencies: {
					bluebird: "1.1.0",
					"dnode-protocol": "~0.2.2",
					ws: "~0.4.31",
					"node-uuid": "^1.4.1",
					"jwt-simple": "^0.2.0",
					gulp: "^3.6.1",
					"stream-to-array": "^1.0.0",
					request: "^2.34.0",
					atob: "^1.1.0",
					"cli-color": "^0.3.2",
					minimist: "0.0.8",
					sockjs: "^0.3.9",
					"node-sockjs-client": "1.0.7",
					"try-json-parse": "^0.1.0"
				},
				devDependencies: {
					browserify: "~3.32.0",
					"coffee-script": "~1.7.1",
					coffeeify: "~0.6.0",
					gulp: "^3.5.6",
					"gulp-coffee": "^1.4.1",
					"gulp-uglify": "^0.2.1",
					"gulp-if": "0.0.5",
					"gulp-rename": "^1.2.0",
					"browserify-shim": "^3.3.1",
					"gulp-util": "^2.2.14",
					"gulp-replace": "^0.2.0",
					"vinyl-source-stream": "^0.1.1",
					ecstatic: "^0.5.3",
					"gulp-concat": "^2.2.0",
					tap: "^0.4.11",
					tape: "^2.13.3"
				},
				browser: {
					"./src/logging/logging.coffee": "./src/logging/browser.coffee"
				},
				browserify: {
					transform: ["browserify-shim"]
				},
				"browserify-shim": {
					bluebird: "global:Promise",
					sockjs: "global:SockJS",
					ws: "global:WebSocket",
					"node-uuid": "global:uuid",
					atob: "global:atob"
				}
			}
		}, {}
	],
	23: [
		function (require, module) {
			(function (global) {
				var Promise, atob, handleToken, whitelist, __indexOf = [].indexOf || function (item) {
					for (var i = 0, l = this.length; l > i; i++)
						if (i in this && this[i] === item) return i;
					return -1
				};
				Promise = "undefined" != typeof window ? window.Promise : "undefined" != typeof global ? global.Promise : null;
				atob = "undefined" != typeof window ? window.atob : "undefined" != typeof global ? global.atob : null;
				handleToken = require("./token.coffee");
				whitelist = require("./whitelist.coffee");
				module.exports = Promise.method(function (method, auth, kiteKey) {
					var key, type, _ref;
					if (null == auth) {
						if (__indexOf.call(whitelist, method) >= 0 || !(null != (_ref = this.api) ? _ref[method].mustAuth : void 0)) return;
						throw new Error("Access denied!")
					}
					type = auth.type, key = auth.key;
					switch (type) {
					case "token":
						return handleToken(key, kiteKey);
					default:
						throw new Error("Unknown auth type: " + type)
					}
				})
			}).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
		}, {
			"./token.coffee": 24,
			"./whitelist.coffee": 25
		}
	],
	24: [
		function (require, module) {
			(function (global) {
				var atob, getKontrolClaims, jwt, parse;
				jwt = require("jwt-simple");
				atob = "undefined" != typeof window ? window.atob : "undefined" != typeof global ? global.atob : null;
				parse = require("try-json-parse");
				getKontrolClaims = require("../util.coffee").getKontrolClaims;
				module.exports = function (tokenString, kiteKey) {
					var claims, headers, headersA, kontrolClaims, publicClaimsA, _ref;
					_ref = tokenString.split("."), headersA = _ref[0], publicClaimsA = _ref[1];
					kontrolClaims = getKontrolClaims(kiteKey);
					headers = parse(atob(headersA));
					claims = jwt.decode(tokenString, kontrolClaims.kontrolKey);
					return {
						headers: headers,
						claims: claims
					}
				}
			}).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
		}, {
			"../util.coffee": 39,
			"jwt-simple": 19,
			"try-json-parse": 21
		}
	],
	25: [
		function (require, module) {
			module.exports = ["kite.heartbeat", "kite.ping"]
		}, {}
	],
	26: [
		function (require, module) {
			"use strict";
			var define;
			define = require("./util.coffee").define;
			module.exports = function (method, ctx) {
				var boundMethod;
				null == ctx && (ctx = this);
				if (null == ctx[method]) throw new Error("Could not bind method: " + method);
				boundMethod = "__bound__" + method;
				boundMethod in ctx || define(ctx, boundMethod, {
					value: ctx[method].bind(ctx)
				});
				return ctx[boundMethod]
			}
		}, {
			"./util.coffee": 39
		}
	],
	27: [
		function (require, module) {
			var Delayed, __slice = [].slice;
			module.exports = Delayed = function () {
				function Delayed() {
					var fn, ms, params;
					fn = arguments[0], ms = arguments[1], params = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
					this.fn = fn;
					this.ms = ms;
					this.params = params;
					Delayed.handles.push(this);
					this.begin()
				}
				var mustOverride;
				mustOverride = function () {
					throw new Error("not implemented")
				};
				Delayed.handles = [];
				Delayed.prototype.begin = mustOverride;
				Delayed.prototype.clear = mustOverride;
				Delayed.clearAll = function () {
					this.handles.forEach(function (h) {
						return h.clear()
					});
					return this.handles.length = 0
				};
				return Delayed
			}()
		}, {}
	],
	28: [
		function (require, module) {
			var Delayed, Interval, __hasProp = {}.hasOwnProperty,
				__extends = function (child, parent) {
					function ctor() {
						this.constructor = child
					}
					for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				},
				__slice = [].slice;
			Delayed = require("./delayed.coffee");
			module.exports = Interval = function (_super) {
				function Interval() {
					return Interval.__super__.constructor.apply(this, arguments)
				}
				__extends(Interval, _super);
				Interval.prototype.begin = function () {
					return this.handle = setInterval.apply(null, [this.fn, this.ms].concat(__slice.call(this.params)))
				};
				Interval.prototype.clear = function () {
					return clearInterval(this.handle)
				};
				return Interval
			}(Delayed)
		}, {
			"./delayed.coffee": 27
		}
	],
	29: [
		function (require, module) {
			var Delayed, Timeout, __hasProp = {}.hasOwnProperty,
				__extends = function (child, parent) {
					function ctor() {
						this.constructor = child
					}
					for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				},
				__slice = [].slice;
			Delayed = require("./delayed.coffee");
			module.exports = Timeout = function (_super) {
				function Timeout() {
					return Timeout.__super__.constructor.apply(this, arguments)
				}
				__extends(Timeout, _super);
				Timeout.prototype.begin = function () {
					return this.handle = setTimeout.apply(null, [this.fn, this.ms].concat(__slice.call(this.params)))
				};
				Timeout.prototype.clear = function () {
					return clearTimeout(this.handle)
				};
				return Timeout
			}(Delayed)
		}, {
			"./delayed.coffee": 27
		}
	],
	30: [
		function (require, module) {
			var KiteError, __hasProp = {}.hasOwnProperty,
				__extends = function (child, parent) {
					function ctor() {
						this.constructor = child
					}
					for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				};
			module.exports = KiteError = function (_super) {
				function KiteError(message) {
					Error.call(this);
					this.message = message;
					this.name = "KiteError"
				}
				__extends(KiteError, _super);
				KiteError.codeIs = function (code) {
					return function (err) {
						return code === err.code
					}
				};
				KiteError.codeIsnt = function (code) {
					return function (err) {
						return code !== err.code
					}
				};
				return KiteError
			}(Error)
		}, {}
	],
	31: [
		function (require, module) {
			var handleAuth, mungeCallbacks, parse, __hasProp = {}.hasOwnProperty,
				__slice = [].slice;
			parse = require("try-json-parse");
			handleAuth = require("./auth/auth.coffee");
			mungeCallbacks = function (callbacks, n) {
				var c, k;
				for (k in callbacks)
					if (__hasProp.call(callbacks, k)) {
						c = callbacks[k];
						"0.responseCallback" === c.join(".") && (callbacks[k] = [n]);
						"withArgs" === c[1] && (callbacks[k] = c.slice(2))
					}
				return callbacks
			};
			module.exports = function (proto, message) {
				var args, auth, callbacks, kite, links, method, req, responseCallback, withArgs, _ref;
				this.emit("debug", "Receiving: " + message);
				req = parse(message);
				if (null != req) {
					args = req.arguments, links = req.links, callbacks = req.callbacks, method = req.method, auth = req.authentication;
					args.length > 0 && (_ref = args[0], withArgs = _ref.withArgs, responseCallback = _ref.responseCallback, kite = _ref.kite, auth = _ref.authentication);
					if (null == withArgs && null == responseCallback) {
						this.emit("debug", "Handling a normal dnode message");
						return proto.handle(req)
					}
					this.emit("debug", "Authenticating request");
					return handleAuth.call(this, method, auth, this.key).then(function (_this) {
						return function (token) {
							_this.emit("debug", "Authentication passed");
							null == withArgs && (withArgs = []);
							Array.isArray(withArgs) || (withArgs = [withArgs]);
							mungeCallbacks(callbacks, withArgs.length);
							_this.currentToken = token;
							proto.handle({
								method: method,
								arguments: __slice.call(withArgs).concat([responseCallback]),
								links: links,
								callbacks: callbacks
							});
							return _this.currentToken = null
						}
					}(this))["catch"](function (_this) {
						return function (err) {
							_this.emit("debug", "Authentication failed");
							mungeCallbacks(callbacks, 1);
							return proto.handle({
								method: "kite.echo",
								arguments: [err, responseCallback],
								links: links,
								callbacks: callbacks
							})
						}
					}(this))
				}
				this.emit("warning", new KiteError("Invalid payload! (" + message + ")"))
			}
		}, {
			"./auth/auth.coffee": 23,
			"try-json-parse": 21
		}
	],
	kite: [
		function (require, module) {
			module.exports = require("JL8Kc6")
		}, {}
	],
	JL8Kc6: [
		function (require, module) {
			(function (global) {
				"use strict";
				var BasicKite, Kite, __hasProp = {}.hasOwnProperty,
					__extends = function (child, parent) {
						function ctor() {
							this.constructor = child
						}
						for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
						ctor.prototype = parent.prototype;
						child.prototype = new ctor;
						child.__super__ = parent.prototype;
						return child
					};
				BasicKite = require("../kite/kite.coffee");
				module.exports = Kite = function (_super) {
					function Kite(options) {
						if (!(this instanceof Kite)) return new Kite(options);
						Kite.__super__.constructor.call(this, options);
						return void 0
					}
					var Promise;
					__extends(Kite, _super);
					Promise = "undefined" != typeof window ? window.Promise : "undefined" != typeof global ? global.Promise : null;
					Kite.prototype.tell = function (method, params, callback) {
						return new Promise(function (_this) {
							return function (resolve, reject) {
								return Kite.__super__.tell.call(_this, method, params, function (err, result) {
									return err ? reject(err) : resolve(result)
								})
							}
						}(this)).nodeify(callback)
					};
					Kite.prototype.ready = function (callback) {
						return new Promise(function (_this) {
							return function (resolve) {
								return Kite.__super__.ready.call(_this, resolve)
							}
						}(this)).nodeify(callback)
					};
					Kite.prototype.expireToken = Promise.promisify(Kite.prototype.expireToken);
					return Kite
				}(BasicKite)
			}).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
		}, {
			"../kite/kite.coffee": "03yxz7"
		}
	],
	34: [
		function (require, module) {
			"use strict";
			module.exports = function (options) {
				var backoff, initalDelayMs, maxDelayMs, maxReconnectAttempts, multiplyFactor, totalReconnectAttempts, _ref, _ref1, _ref2, _ref3, _ref4;
				null == options && (options = {});
				backoff = null != (_ref = options.backoff) ? _ref : {};
				totalReconnectAttempts = 0;
				initalDelayMs = null != (_ref1 = backoff.initialDelayMs) ? _ref1 : 700;
				multiplyFactor = null != (_ref2 = backoff.multiplyFactor) ? _ref2 : 1.4;
				maxDelayMs = null != (_ref3 = backoff.maxDelayMs) ? _ref3 : 15e3;
				maxReconnectAttempts = null != (_ref4 = backoff.maxReconnectAttempts) ? _ref4 : 50;
				this.clearBackoffTimeout = function () {
					return totalReconnectAttempts = 0
				};
				return this.setBackoffTimeout = function (_this) {
					return function (fn) {
						var timeout;
						if (maxReconnectAttempts > totalReconnectAttempts) {
							timeout = Math.min(initalDelayMs * Math.pow(multiplyFactor, totalReconnectAttempts), maxDelayMs);
							setTimeout(fn, timeout);
							return totalReconnectAttempts++
						}
						return _this.emit("backoffFailed")
					}
				}(this)
			}
		}, {}
	],
	"./src/kite/kite.coffee": [
		function (require, module) {
			module.exports = require("03yxz7")
		}, {}
	],
	"03yxz7": [
		function (require, module) {
			(function (process, global) {
				"use strict";
				var EventEmitter, Kite, __hasProp = {}.hasOwnProperty,
					__extends = function (child, parent) {
						function ctor() {
							this.constructor = child
						}
						for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
						ctor.prototype = parent.prototype;
						child.prototype = new ctor;
						child.__super__ = parent.prototype;
						return child
					},
					__slice = [].slice;
				EventEmitter = require("events").EventEmitter;
				module.exports = Kite = function (_super) {
					function Kite(options) {
						var _base, _base1;
						if (!(this instanceof Kite)) return new Kite(options);
						this.id = uniqueId();
						this.options = "string" == typeof options ? {
							url: options
						} : options;
						null == (_base = this.options).autoConnect && (_base.autoConnect = !0);
						null == (_base1 = this.options).autoReconnect && (_base1.autoReconnect = !0);
						this.options.prefix && (this.options.url += this.options.prefix);
						enableLogging(this.options.name, this, this.options.logLevel);
						this.expireTokenOnExpiry();
						this.readyState = NOTREADY;
						this.options.autoReconnect && this.initBackoff();
						this.proto = dnodeProtocol(wrapApi.call(this, this.options.api));
						this.proto.on("request", function (_this) {
							return function (req) {
								_this.ready(function () {
									return _this.ws.send(JSON.stringify(req))
								});
								_this.emit("debug", "Sending: ", JSON.stringify(req))
							}
						}(this));
						this.options.autoConnect && this.connect()
					}
					var CLOSED, ERROR, KiteError, NOTREADY, OKAY, READY, Timeout, WebSocket, atob, dnodeProtocol, enableLogging, handleIncomingMessage, makeProperError, now, uniqueId, wrapApi, _ref, _ref1;
					__extends(Kite, _super);
					Kite.version = require("../../package.json").version;
					dnodeProtocol = require("dnode-protocol");
					WebSocket = "undefined" != typeof window ? window.WebSocket : "undefined" != typeof global ? global.WebSocket : null;
					atob = "undefined" != typeof window ? window.atob : "undefined" != typeof global ? global.atob : null;
					wrapApi = require("./wrap-api.coffee");
					handleIncomingMessage = require("../incoming-message-handler.coffee");
					enableLogging = require("../logging/logging.coffee");
					Timeout = require("../delayed/timeout.coffee");
					KiteError = require("../error.coffee");
					Kite.Error = KiteError;
					now = require("../util.coffee").now;
					_ref = [0, 1, 3], NOTREADY = _ref[0], READY = _ref[1], CLOSED = _ref[2];
					_ref1 = [0, 1], OKAY = _ref1[0], ERROR = _ref1[1];
					uniqueId = ("undefined" != typeof window ? window.uuid : "undefined" != typeof global ? global.uuid : null).v4;
					Kite.transportClass = "undefined" != typeof window ? window.WebSocket : "undefined" != typeof global ? global.WebSocket : null;
					Kite.prototype.getToken = function () {
						return this.options.auth.key
					};
					Kite.prototype.setToken = function (token) {
						var _ref2;
						if ("token" !== (null != (_ref2 = this.options.auth) ? _ref2.type : void 0)) throw new Error("Invalid auth type!");
						this.options.auth.key = token;
						return this.emit("tokenSet", token)
					};
					Kite.prototype.connect = function () {
						var konstructor, options, transportClass, transportOptions, url, _ref2;
						if (this.readyState !== READY) {
							_ref2 = this.options, url = _ref2.url, transportClass = _ref2.transportClass, transportOptions = _ref2.transportOptions;
							konstructor = null != transportClass ? transportClass : this.constructor.transportClass;
							options = null != transportOptions ? transportOptions : this.constructor.transportOptions;
							this.ws = new konstructor(url, null, options);
							this.ws.addEventListener("open", this.bound("onOpen"));
							this.ws.addEventListener("close", this.bound("onClose"));
							this.ws.addEventListener("message", this.bound("onMessage"));
							this.ws.addEventListener("error", this.bound("onError"));
							this.ws.addEventListener("info", function (_this) {
								return function (info) {
									return _this.emit("info", info)
								}
							}(this));
							this.emit("info", "Trying to connect to " + url)
						}
					};
					Kite.prototype.disconnect = function (reconnect) {
						var handle, _i, _len, _ref2;
						null == reconnect && (reconnect = !1);
						_ref2 = ["heartbeatHandle", "expiryHandle"];
						for (_i = 0, _len = _ref2.length; _len > _i; _i++) {
							handle = _ref2[_i];
							if (null != this[handle]) {
								this[handle].clear();
								this[handle] = null
							}
						}
						this.options.autoReconnect = !!reconnect;
						this.ws.close();
						this.emit("notice", "Disconnecting from " + this.options.url)
					};
					Kite.prototype.onOpen = function () {
						this.readyState = READY;
						this.emit("connected");
						this.emit("ready");
						this.emit("notice", "Connected to Kite: " + this.options.url);
						this.clearBackoffTimeout()
					};
					Kite.prototype.onClose = function () {
						var dcInfo;
						this.readyState = CLOSED;
						this.emit("disconnected");
						dcInfo = "" + this.options.url + ": disconnected";
						if (this.options.autoReconnect) {
							process.nextTick(function (_this) {
								return function () {
									return _this.setBackoffTimeout(_this.bound("connect"))
								}
							}(this));
							dcInfo += ", trying to reconnect..."
						}
						this.emit("info", dcInfo)
					};
					Kite.prototype.onMessage = function (_arg) {
						var data;
						data = _arg.data;
						handleIncomingMessage.call(this, this.proto, data)
					};
					Kite.prototype.onError = function (err) {
						console.log(err);
						this.emit("error", "Websocket error!")
					};
					Kite.prototype.getKiteInfo = function (params) {
						var _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
						return {
							username: "" + (null != (_ref2 = this.options.username) ? _ref2 : "anonymous"),
							environment: "" + (null != (_ref3 = this.options.environment) ? _ref3 : "browser-environment"),
							name: "" + (null != (_ref4 = null != (_ref5 = null != params && null != (_ref6 = params[0]) ? _ref6.kiteName : void 0) ? _ref5 : this.options.name) ? _ref4 : "browser-kite"),
							version: "" + (null != (_ref7 = this.options.version) ? _ref7 : "1.0.0"),
							region: "" + (null != (_ref8 = this.options.region) ? _ref8 : "browser-region"),
							hostname: "" + (null != (_ref9 = this.options.hostname) ? _ref9 : "browser-hostname"),
							id: this.id
						}
					};
					Kite.prototype.wrapMessage = function (method, params, callback) {
						return {
							kite: this.getKiteInfo(params),
							authentication: this.options.auth,
							withArgs: params,
							responseCallback: function () {
								return function (response) {
									var err, rawErr, result;
									rawErr = response.error, result = response.result;
									err = null != rawErr ? makeProperError(rawErr) : null;
									return callback(err, result)
								}
							}(this)
						}
					};
					Kite.prototype.tell = function (method, params, callback) {
						var scrubbed;
						null == callback.times && (callback.times = 1);
						scrubbed = this.proto.scrubber.scrub([this.wrapMessage(method, params, callback)]);
						scrubbed.method = method;
						this.proto.emit("request", scrubbed)
					};
					Kite.prototype.expireTokenOnExpiry = function () {
						var claims, claimsA, earlyMs, expMs, nowMs, renewMs, token, _, _ref2, _ref3;
						if ("token" === (null != (_ref2 = this.options.auth) ? _ref2.type : void 0)) {
							token = this.options.auth.key;
							_ref3 = token.split("."), _ = _ref3[0], claimsA = _ref3[1];
							claims = function () {
								try {
									return JSON.parse(atob(claimsA))
								} catch (_error) {}
							}();
							if (null != claims ? claims.exp : void 0) {
								expMs = 1e3 * claims.exp;
								nowMs = +now();
								earlyMs = 3e5;
								renewMs = expMs - nowMs - earlyMs;
								this.expiryHandle = new Timeout(this.bound("expireToken"), renewMs)
							}
						}
					};
					Kite.prototype.expireToken = function (callback) {
						null != callback && this.once("tokenSet", function (newToken) {
							return callback(null, newToken)
						});
						this.emit("tokenExpired");
						if (this.expiryHandle) {
							this.expiryHandle.clear();
							this.expiryHandle = null
						}
					};
					makeProperError = function (_arg) {
						var code, err, message, type;
						type = _arg.type, message = _arg.message, code = _arg.code;
						err = new KiteError(message);
						err.type = type;
						err.code = code;
						return err
					};
					Kite.prototype.bound = require("../bound.coffee");
					Kite.prototype.initBackoff = require("./backoff.coffee");
					Kite.prototype.ready = function (callback) {
						this.readyState === READY ? process.nextTick(callback) : this.once("ready", callback)
					};
					Kite.prototype.ping = function (callback) {
						return this.tell("kite.ping", callback)
					};
					Kite.disconnect = function () {
						var kite, kites, _i, _len;
						kites = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
						for (_i = 0, _len = kites.length; _len > _i; _i++) {
							kite = kites[_i];
							kite.disconnect()
						}
					};
					Kite.random = function (kites) {
						return kites[Math.floor(Math.random() * kites.length)]
					};
					return Kite
				}(EventEmitter)
			}).call(this, require("/Users/thorn/Desktop/kite.js/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
		}, {
			"../../package.json": 22,
			"../bound.coffee": 26,
			"../delayed/timeout.coffee": 29,
			"../error.coffee": 30,
			"../incoming-message-handler.coffee": 31,
			"../logging/logging.coffee": 38,
			"../util.coffee": 39,
			"./backoff.coffee": 34,
			"./wrap-api.coffee": 37,
			"/Users/thorn/Desktop/kite.js/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js": 12,
			"dnode-protocol": 13,
			events: "T9Wsc/"
		}
	],
	37: [
		function (require, module) {
			"use strict";
			var Interval, __hasProp = {}.hasOwnProperty;
			Interval = require("../delayed/interval.coffee");
			module.exports = function (userlandApi) {
				var api, fn, method;
				null == userlandApi && (userlandApi = {});
				api = ["error", "info", "log", "warn"].reduce(function (api, method) {
					api[method] = console[method].bind(console);
					return api
				}, {});
				api["kite.heartbeat"] = function (_this) {
					return function (duration, ping, callback) {
						_this.heartbeatHandle = new Interval(ping, 1e3 * duration);
						return callback({
							error: null
						})
					}
				}(this);
				for (method in userlandApi)
					if (__hasProp.call(userlandApi, method)) {
						fn = userlandApi[method];
						api[method] = fn
					}
				return api
			}
		}, {
			"../delayed/interval.coffee": 28
		}
	],
	38: [
		function (require, module) {
			var CRITICAL, DEBUG, ERROR, INFO, NOTICE, WARNING, enableLogging, error, info, warn, _ref, __slice = [].slice;
			_ref = [0, 1, 2, 3, 4, 5], CRITICAL = _ref[0], ERROR = _ref[1], WARNING = _ref[2], NOTICE = _ref[3], INFO = _ref[4], DEBUG = _ref[5];
			error = console.error.bind(console);
			warn = console.warn.bind(console);
			info = console.info.bind(console);
			enableLogging = function (name, emitter, logLevel) {
				var createLogger;
				null == name && (name = "kite");
				null == logLevel && (logLevel = INFO);
				createLogger = function (category, fn) {
					return function () {
						var messages;
						messages = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
						return fn("[" + name + "] " + category + "	" + messages.join(" "))
					}
				};
				logLevel >= CRITICAL && emitter.on("critical", createLogger("CRITICAL", error));
				logLevel >= ERROR && emitter.on("error", createLogger("ERROR", error));
				logLevel >= WARNING && emitter.on("warn", createLogger("WARN", warn));
				logLevel >= NOTICE && emitter.on("notice", createLogger("NOTICE", info));
				logLevel >= INFO && emitter.on("info", createLogger("INFO", info));
				return logLevel >= DEBUG ? emitter.on("debug", createLogger("DEBUG", info)) : void 0
			};
			module.exports = enableLogging
		}, {}
	],
	39: [
		function (require, module, exports) {
			(function (global) {
				var atob, parse;
				atob = "undefined" != typeof window ? window.atob : "undefined" != typeof global ? global.atob : null;
				parse = require("try-json-parse");
				exports.define = Object.defineProperty || function (ctx, name, _arg) {
					var value;
					value = _arg.value;
					if (null == value) throw new Error("Unsupported options!");
					return ctx[name] = value
				};
				exports.now = function () {
					var now;
					now = new Date;
					return new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds())
				};
				exports.getKontrolClaims = function (kiteKey) {
					var kontrolClaimsA, _, _ref;
					_ref = kiteKey.split("."), _ = _ref[0], kontrolClaimsA = _ref[1];
					return parse(atob(kontrolClaimsA))
				}
			}).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
		}, {
			"try-json-parse": 21
		}
	]
}, {}, ["JL8Kc6"]);
require = function e(t, n, r) {
	function s(o, u) {
		if (!n[o]) {
			if (!t[o]) {
				var a = "function" == typeof require && require;
				if (!u && a) return a(o, !0);
				if (i) return i(o, !0);
				throw new Error("Cannot find module '" + o + "'")
			}
			var f = n[o] = {
				exports: {}
			};
			t[o][0].call(f.exports, function (e) {
				var n = t[o][1][e];
				return s(n ? n : e)
			}, f, f.exports, e, t, n, r)
		}
		return n[o].exports
	}
	for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
	return s
}({
	1: [
		function (require, module) {
			module.exports = {
				name: "kite.js",
				description: "Kite client library",
				main: "index.js",
				version: "0.3.3",
				scripts: {
					test: "KITE_HOME=. KITE_KEY=$(cat ./kontrol_client.key) node ./test/index.js",
					prepublish: "gulp"
				},
				author: {
					name: "Koding Team",
					email: "team@koding.com",
					website: "https://koding.com"
				},
				contributors: [{
					name: "Fatih Arslan",
					email: "fatih@koding.com"
				}, {
					name: "Cenk Alti",
					email: "cenk@koding.com"
				}, {
					name: "Christopher Thorn",
					email: "chris@koding.com"
				}],
				repository: "https://github.com/koding/kite.js.git",
				license: "MIT",
				dependencies: {
					bluebird: "1.1.0",
					"dnode-protocol": "~0.2.2",
					ws: "~0.4.31",
					"node-uuid": "^1.4.1",
					"jwt-simple": "^0.2.0",
					gulp: "^3.6.1",
					"stream-to-array": "^1.0.0",
					request: "^2.34.0",
					atob: "^1.1.0",
					"cli-color": "^0.3.2",
					minimist: "0.0.8",
					sockjs: "^0.3.9",
					"node-sockjs-client": "1.0.7",
					"try-json-parse": "^0.1.0"
				},
				devDependencies: {
					browserify: "~3.32.0",
					"coffee-script": "~1.7.1",
					coffeeify: "~0.6.0",
					gulp: "^3.5.6",
					"gulp-coffee": "^1.4.1",
					"gulp-uglify": "^0.2.1",
					"gulp-if": "0.0.5",
					"gulp-rename": "^1.2.0",
					"browserify-shim": "^3.3.1",
					"gulp-util": "^2.2.14",
					"gulp-replace": "^0.2.0",
					"vinyl-source-stream": "^0.1.1",
					ecstatic: "^0.5.3",
					"gulp-concat": "^2.2.0",
					tap: "^0.4.11",
					tape: "^2.13.3"
				},
				browser: {
					"./src/logging/logging.coffee": "./src/logging/browser.coffee"
				},
				browserify: {
					transform: ["browserify-shim"]
				},
				"browserify-shim": {
					bluebird: "global:Promise",
					sockjs: "global:SockJS",
					ws: "global:WebSocket",
					"node-uuid": "global:uuid",
					atob: "global:atob"
				}
			}
		}, {}
	],
	2: [
		function (require, module) {
			var KiteError, __hasProp = {}.hasOwnProperty,
				__extends = function (child, parent) {
					function ctor() {
						this.constructor = child
					}
					for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				};
			module.exports = KiteError = function (_super) {
				function KiteError(message) {
					Error.call(this);
					this.message = message;
					this.name = "KiteError"
				}
				__extends(KiteError, _super);
				KiteError.codeIs = function (code) {
					return function (err) {
						return code === err.code
					}
				};
				KiteError.codeIsnt = function (code) {
					return function (err) {
						return code !== err.code
					}
				};
				return KiteError
			}(Error)
		}, {}
	],
	kontrol: [
		function (require, module) {
			module.exports = require("nY3EF+")
		}, {}
	],
	"nY3EF+": [
		function (require, module) {
			(function (global) {
				"use strict";
				var BasicKontrol, Kontrol, __hasProp = {}.hasOwnProperty,
					__extends = function (child, parent) {
						function ctor() {
							this.constructor = child
						}
						for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
						ctor.prototype = parent.prototype;
						child.prototype = new ctor;
						child.__super__ = parent.prototype;
						return child
					};
				BasicKontrol = require("../kontrol/kontrol.coffee");
				module.exports = Kontrol = function (_super) {
					function Kontrol(options) {
						if (!(this instanceof Kontrol)) return new Kontrol(options);
						Kontrol.__super__.constructor.call(this, options);
						return void 0
					}
					var Promise;
					__extends(Kontrol, _super);
					Kontrol.Kite = require("../kite-as-promised/kite.coffee");
					Promise = "undefined" != typeof window ? window.Promise : "undefined" != typeof global ? global.Promise : null;
					["fetchKites", "fetchKite", "watchKites", "cancelWatcher", "register"].forEach(function (method) {
						return Kontrol.prototype[method] = Promise.promisify(BasicKontrol.prototype[method])
					});
					return Kontrol
				}(BasicKontrol)
			}).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
		}, {
			"../kite-as-promised/kite.coffee": "JL8Kc6",
			"../kontrol/kontrol.coffee": 5
		}
	],
	5: [
		function (require, module) {
			"use strict";
			var EventEmitter, Kontrol, __hasProp = {}.hasOwnProperty,
				__extends = function (child, parent) {
					function ctor() {
						this.constructor = child
					}
					for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
					ctor.prototype = parent.prototype;
					child.prototype = new ctor;
					child.__super__ = parent.prototype;
					return child
				};
			EventEmitter = require("events").EventEmitter;
			module.exports = Kontrol = function (_super) {
				function Kontrol(options) {
					var _base, _base1;
					if (!(this instanceof Kontrol)) return new Kontrol(options);
					this.options = options;
					null == (_base = this.options).autoConnect && (_base.autoConnect = !0);
					null == (_base1 = this.options).autoReconnect && (_base1.autoReconnect = !0);
					this.options.autoConnect && this.authenticate()
				}
				var KiteError;
				__extends(Kontrol, _super);
				Kontrol.version = require("../../package.json").version;
				Kontrol.Kite = require("../kite/kite.coffee");
				KiteError = require("../error.coffee");
				Kontrol.prototype.authenticate = function (options) {
					var auth, environment, hostname, logLevel, name, prefix, region, transportClass, transportOptions, url, username, version, _ref;
					this.options = null != options ? options : this.options;
					_ref = this.options, url = _ref.url, auth = _ref.auth, username = _ref.username, environment = _ref.environment, version = _ref.version, region = _ref.region, hostname = _ref.hostname, name = _ref.name, logLevel = _ref.logLevel, transportClass = _ref.transportClass, transportOptions = _ref.transportOptions, prefix = _ref.prefix;
					this.kite = new this.constructor.Kite({
						username: username,
						environment: environment,
						version: version,
						region: region,
						hostname: hostname,
						name: null != name ? name : "kontrol",
						url: url,
						auth: auth,
						logLevel: logLevel,
						transportClass: transportClass,
						transportOptions: transportOptions,
						prefix: prefix
					});
					this.kite.on("error", this.emit.bind(this, "error"));
					return this.kite.on("connected", this.emit.bind(this, "connected"))
				};
				Kontrol.prototype.createKite = function (_arg) {
					var kite, kiteDescriptor, token, url;
					kiteDescriptor = _arg.kite, token = _arg.token, url = _arg.url;
					kite = new this.constructor.Kite({
						username: kiteDescriptor.username,
						environment: kiteDescriptor.environment,
						version: kiteDescriptor.version,
						region: kiteDescriptor.region,
						hostname: kiteDescriptor.hostname,
						autoConnect: !1,
						name: kiteDescriptor.name,
						url: url,
						auth: {
							type: "token",
							key: token
						},
						transportClass: this.options.transportClass,
						transportOptions: this.options.transportOptions
					}).on("tokenExpired", function (_this) {
						return function () {
							return _this.renewToken(kite, kiteDescriptor)
						}
					}(this));
					return kite
				};
				Kontrol.prototype.renewToken = function (kite, query) {
					return this.kite.tell("getToken", [query], function (err, token) {
						if (!err) return kite.setToken(token);
						console.error(err);
						return void 0
					})
				};
				Kontrol.prototype.createKites = function (kiteDescriptors) {
					var k, _i, _len, _results;
					_results = [];
					for (_i = 0, _len = kiteDescriptors.length; _len > _i; _i++) {
						k = kiteDescriptors[_i];
						_results.push(this.createKite(k))
					}
					return _results
				};
				Kontrol.prototype.fetchKites = function (args, callback) {
					null == args && (args = {});
					this.kite.tell("getKites", [args], function (_this) {
						return function (err, result) {
							null == err ? null != result ? callback(null, _this.createKites(result.kites)) : callback(_this.createKiteNotFoundError(args.query)) : callback(err)
						}
					}(this))
				};
				Kontrol.prototype.fetchKite = function (args, callback) {
					null == args && (args = {});
					this.fetchKites(args, function (_this) {
						return function (err, kites) {
							null == err ? null != (null != kites ? kites[0] : void 0) ? callback(null, kites[0]) : callback(_this.createKiteNotFoundError(args.query)) : callback(err)
						}
					}(this))
				};
				Kontrol.prototype.watchKites = function (args, callback) {
					var changes;
					null == args && (args = {});
					changes = new EventEmitter;
					args.watchHandler = this.createUpdateHandler(changes);
					this.kite.tell("getKites", [args], function (_this) {
						return function (err, result) {
							var kite, kiteDescriptors, watcherID, _i, _len, _ref;
							if (null == err) {
								kiteDescriptors = result.kites, watcherID = result.watcherID;
								callback(null, {
									changes: changes,
									watcherID: watcherID
								});
								_ref = _this.createKites(kiteDescriptors);
								for (_i = 0, _len = _ref.length; _len > _i; _i++) {
									kite = _ref[_i];
									changes.emit("register", kite)
								}
							} else callback(err)
						}
					}(this))
				};
				Kontrol.prototype.cancelWatcher = function (id, callback) {
					return this.kite.tell("cancelWatcher", [id], callback)
				};
				Kontrol.prototype.createUpdateHandler = function (changes) {
					return function (_this) {
						return function (response) {
							var action, err, eventName, kite, result, token, url;
							err = response.err, result = response.result;
							if (null == err) {
								action = result.action, kite = result.kite, token = result.token, url = result.url;
								kite = _this.createKite({
									kite: kite,
									token: token,
									url: url
								});
								eventName = _this.constructor.actions[action];
								changes.emit(eventName, kite)
							} else changes.emit("error", err)
						}
					}(this)
				};
				Kontrol.prototype.createKiteNotFoundError = function (query) {
					var environment, hostname, id, name, region, username, version;
					username = query.username, environment = query.environment, name = query.name, version = query.version, region = query.region, hostname = query.hostname, id = query.id;
					return new KiteError("No kite found! query: " + (null != username ? username : "") + "/" + (null != environment ? environment : "") + "/" + (null != name ? name : "") + "/" + (null != version ? version : "") + "/" + (null != region ? region : "") + "/" + (null != hostname ? hostname : "") + "/" + (null != id ? id : ""))
				};
				Kontrol.prototype.connect = function () {
					return this.kite.connect()
				};
				Kontrol.prototype.disconnect = function () {
					return this.kite.disconnect()
				};
				Kontrol.prototype.register = function (url, callback) {
					var _ref;
					return null != (_ref = this.kite) ? _ref.tell("register", [url], callback) : void 0
				};
				Kontrol.actions = {
					REGISTER: "register",
					DEREGISTER: "deregister"
				};
				return Kontrol
			}(EventEmitter)
		}, {
			"../../package.json": 1,
			"../error.coffee": 2,
			"../kite/kite.coffee": "03yxz7",
			events: "T9Wsc/"
		}
	]
}, {}, ["nY3EF+"]);
var _ref;
utils.extend(utils, {
	getPaymentMethodTitle: function (billing) {
		var cardFirstName, cardLastName, cardNumber, cardType;
		null != billing.billing && (billing = billing.billing);
		cardFirstName = billing.cardFirstName, cardLastName = billing.cardLastName, cardType = billing.cardType, cardNumber = billing.cardNumber;
		return "" + cardFirstName + " " + cardLastName + " (" + cardType + " " + cardNumber + ")"
	},
	botchedUrlRegExp: /(([a-zA-Z]+\:)?\/\/)+(\w+:\w+@)?([a-zA-Z\d.-]+\.[A-Za-z]{2,4})(:\d+)?(\/\S*)?/g,
	webProtocolRegExp: /^((http(s)?\:)?\/\/)/,
	domainWithTLDPattern: /^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}$/i,
	subdomainPattern: /^(?:[a-z0-9](?:[_\-](?![_\-])|[a-z0-9]){0,60}[a-z0-9]|[a-z0-9])$/i,
	proxifyUrl: function (url, options) {
		var endpoint, fullurl;
		null == url && (url = "");
		null == options && (options = {});
		options.width || (options.width = -1);
		options.height || (options.height = -1);
		options.grow || (options.grow = !0);
		if ("" === url) return "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
		(options.width || options.height) && (endpoint = "resize");
		options.crop && (endpoint = "crop");
		fullurl = "" + KD.config.mainUri + "/-/image/cache?" + ("endpoint=" + (endpoint || "") + "&") + ("grow=" + options.grow + "&") + ("width=" + options.width + "&") + ("height=" + options.height + "&") + ("url=" + encodeURIComponent(url));
		return fullurl
	},
	setPreferredDomain: function (account) {
		var preferredDomainCookieName, preferredKDProxyDomain;
		preferredDomainCookieName = "kdproxy-preferred-domain";
		preferredKDProxyDomain = account.preferredKDProxyDomain;
		if (preferredKDProxyDomain && "" !== preferredKDProxyDomain) {
			if (Cookies.get(preferredDomainCookieName) === preferredKDProxyDomain) return;
			Cookies.set(preferredDomainCookieName, preferredKDProxyDomain);
			return location.reload(!0)
		}
	},
	showMoreClickHandler: function (event) {
		var $trg, less, more;
		$trg = $(event.target);
		$trg.is(".more-link, .less-link") && utils.stopDOMEvent(event);
		more = "span.collapsedtext a.more-link";
		less = "span.collapsedtext a.less-link";
		$trg.is(more) && $trg.parent().addClass("show").removeClass("hide");
		return $trg.is(less) ? $trg.parent().removeClass("show").addClass("hide") : void 0
	},
	applyTextExpansions: function (text, shorten) {
		var i, link, links, _i, _len, _ref;
		if (!text) return "";
		text = text.replace(/&#10;/g, " ");
		_ref = this.expandUrls(text, !0), links = _ref.links, text = _ref.text;
		shorten && (text = utils.putShowMore(text));
		if (null != links)
			for (i = _i = 0, _len = links.length; _len > _i; i = ++_i) {
				link = links[i];
				text = text.replace("[tempLink" + i + "]", link)
			}
		text = this.expandUsernames(text);
		return text
	},
	expandWwwDotDomains: function (text) {
		return text ? text.replace(/(^|\s)(www\.[A-Za-z0-9-_]+.[A-Za-z0-9-_:%&\?\/.=]+)/g, function (_, whitespace, www) {
			return "" + whitespace + "<a href='http://" + www + "' target='_blank'>" + www + "</a>"
		}) : null
	},
	expandUsernames: function (text, excludeSelector) {
		var result;
		if (!text) return null;
		if (excludeSelector) {
			result = "";
			$(text).each(function (i, element) {
				var $element, childrenCheck, elementCheck, parentCheck, replacedText;
				$element = $(element);
				elementCheck = $element.not(excludeSelector);
				parentCheck = 0 === $element.parents(excludeSelector).length;
				childrenCheck = 0 === $element.find(excludeSelector).length;
				if (elementCheck && parentCheck && childrenCheck && null != $element.html()) {
					replacedText = $element.html().replace(/\B\@([\w\-]+)/gim, function (u) {
						var username;
						username = u.replace("@", "");
						return u.link("/" + username)
					});
					$element.html(replacedText)
				}
				return result += $element.get(0).outerHTML || ""
			});
			return result
		}
		return text.replace(/\B\@([\w\-]+)/gim, function (u) {
			var username;
			username = u.replace("@", "");
			return u.link("/" + username)
		})
	},
	expandUrls: function (text, replaceAndYieldLinks) {
		var linkCount, links, urlGrabber;
		null == replaceAndYieldLinks && (replaceAndYieldLinks = !1);
		if (!text) return null;
		links = [];
		linkCount = 0;
		urlGrabber = /(?!\s)([a-zA-Z]+:\/\/)(\w+:\w+@|[\w|\d]+@|)((?:[a-zA-Z\d]+(?:-[a-zA-Z\d]+)*\.)*)([a-zA-Z\d]+(?:[a-zA-Z\d]|-(?=[a-zA-Z\d]))*[a-zA-Z\d]?)\.([a-zA-Z]{2,4})(:\d+|)(\/\S*|)(?!\S)/g;
		text = text.replace(urlGrabber, function (url) {
			var checkForPostSlash, originalUrl, visibleUrl;
			url = url.trim();
			originalUrl = url;
			visibleUrl = url.replace(/(ht|f)tp(s)?\:\/\//, "").replace(/\/.*/, "");
			checkForPostSlash = /.*(\/\/)+.*\/.+/.test(originalUrl);
			/[A-Za-z]+:\/\//.test(url) || (url = "//" + url);
			if (replaceAndYieldLinks) {
				links.push("<a href='" + url + "' data-original-url='" + originalUrl + "' target='_blank' >" + visibleUrl + (checkForPostSlash ? "/\u2026" : "") + "<span class='expanded-link'></span></a>");
				return "[tempLink" + linkCount+++"]"
			}
			return "<a href='" + url + "' data-original-url='" + originalUrl + "' target='_blank' >" + visibleUrl + (checkForPostSlash ? "/\u2026" : "") + "<span class='expanded-link'></span></a>"
		});
		return replaceAndYieldLinks ? {
			links: links,
			text: text
		} : text
	},
	putShowMore: function (text, l) {
		var morePart, shortenedText;
		null == l && (l = 500);
		shortenedText = utils.shortenText(text, {
			minLength: l,
			maxLength: l + Math.floor(l / 10),
			suffix: ""
		});
		return text = Encoder.htmlEncode(text).length > Encoder.htmlEncode(shortenedText).length ? (morePart = "<span class='collapsedtext hide'>", morePart += "<a href='#' class='more-link' title='Show more...'>Show more...</a>", morePart += Encoder.htmlEncode(text).substr(Encoder.htmlEncode(shortenedText).length), morePart += "<a href='#' class='less-link' title='Show less...'>...show less</a>", morePart += "</span>", Encoder.htmlEncode(shortenedText) + morePart) : Encoder.htmlEncode(shortenedText)
	},
	shortenText: function () {
		var tryToShorten;
		tryToShorten = function (longText, optimalBreak, suffix) {
			null == optimalBreak && (optimalBreak = " ");
			return ~longText.indexOf(optimalBreak) ? "" + longText.split(optimalBreak).slice(0, -1).join(optimalBreak) + (null != suffix ? suffix : optimalBreak) : !1
		};
		return function (longText, options) {
			var candidate, finalMaxLength, lastClosingTag, lastOpeningTag, longTextLength, maxLength, minLength, suffix, tempText, _ref;
			null == options && (options = {});
			if (!longText) return "";
			minLength = options.minLength || 450;
			maxLength = options.maxLength || 600;
			suffix = null != (_ref = options.suffix) ? _ref : "...";
			longTextLength = longText.length;
			tempText = longText.slice(0, maxLength);
			lastClosingTag = tempText.lastIndexOf("]");
			lastOpeningTag = tempText.lastIndexOf("[");
			finalMaxLength = lastClosingTag >= lastOpeningTag ? maxLength : lastOpeningTag;
			if (longText.length < minLength || longText.length < maxLength) return longText;
			longText = longText.substr(0, finalMaxLength);
			candidate = tryToShorten(longText, ". ", suffix) || tryToShorten(longText, " ", suffix);
			return (null != candidate ? candidate.length : void 0) > minLength ? candidate : longText
		}
	}(),
	expandTokens: function (str, data) {
		var constructorName, domId, id, itemClass, match, prefix, tagMap, title, token, tokenMatches, tokenString, tokenView, viewParams, _i, _len, _ref, _ref1;
		null == str && (str = "");
		if (!(tokenMatches = str.match(/\|.+?\|/g))) return str;
		tagMap = {};
		null != (_ref = data.tags) && _ref.forEach(function (tag) {
			return null == tag.lazyNode ? tagMap[tag.getId()] = tag : void 0
		});
		viewParams = [];
		for (_i = 0, _len = tokenMatches.length; _len > _i; _i++) {
			tokenString = tokenMatches[_i];
			(match = tokenString.match(/^\|(.+)\|$/)) && (_ref1 = match[1].split(/:/), prefix = _ref1[0], constructorName = _ref1[1], id = _ref1[2], title = _ref1[3]);
			switch (prefix) {
			case "#":
				token = null != tagMap ? tagMap[id] : void 0;
				break;
			default:
				continue
			}
			if (token) {
				domId = utils.getUniqueId();
				itemClass = utils.getTokenClass(prefix);
				tokenView = new TokenView({
					domId: domId,
					itemClass: itemClass
				}, token);
				tokenView.emit("viewAppended");
				str = str.replace(tokenString, tokenView.getElement().outerHTML);
				tokenView.destroy();
				viewParams.push({
					options: {
						domId: domId,
						itemClass: itemClass
					},
					data: token
				})
			} else str = str.replace(tokenString, "" + prefix + title)
		}
		utils.defer(function () {
			var options, _j, _len1, _ref2, _results;
			_results = [];
			for (_j = 0, _len1 = viewParams.length; _len1 > _j; _j++) {
				_ref2 = viewParams[_j], options = _ref2.options, data = _ref2.data;
				_results.push(new TokenView(options, data))
			}
			return _results
		});
		return str
	},
	getTokenClass: function (prefix) {
		switch (prefix) {
		case "#":
			return TagLinkView
		}
	},
	getPlainActivityBody: function (activity) {
		var body, tagMap, _ref;
		body = activity.body;
		tagMap = {};
		null != (_ref = activity.tags) && _ref.forEach(function (tag) {
			return tagMap[tag.getId()] = tag
		});
		return body.replace(/\|(.+?)\|/g, function (match, tokenString) {
			var constructorName, id, prefix, title, token, _ref1;
			_ref1 = tokenString.split(/:/), prefix = _ref1[0], constructorName = _ref1[1], id = _ref1[2], title = _ref1[3];
			switch (prefix) {
			case "#":
				token = null != tagMap ? tagMap[id] : void 0
			}
			return "" + prefix + (token ? token.title : title || "")
		})
	},
	getMonthOptions: function () {
		var i, _i, _results;
		_results = [];
		for (i = _i = 1; 12 >= _i; i = ++_i) _results.push(i > 9 ? {
			title: "" + i,
			value: i
		} : {
			title: "0" + i,
			value: i
		});
		return _results
	},
	getYearOptions: function (min, max) {
		var i, _i, _results;
		null == min && (min = 1900);
		null == max && (max = Date.prototype.getFullYear());
		_results = [];
		for (i = _i = min; max >= min ? max >= _i : _i >= max; i = max >= min ? ++_i : --_i) _results.push({
			title: "" + i,
			value: i
		});
		return _results
	},
	getFullnameFromAccount: function (account, justName) {
		var name;
		null == justName && (justName = !1);
		account || (account = KD.whoami());
		name = "unregistered" === account.type ? "a guest" : justName ? account.profile.firstName : "" + account.profile.firstName + " " + account.profile.lastName;
		return Encoder.htmlEncode(name.trim() || "a Koding user")
	},
	getNameFromFullname: function (fullname) {
		return fullname.split(" ")[0]
	},
	warnAndLog: function (msg, params) {
		warn(msg, params);
		return ErrorLog.create(msg, params)
	},
	generatePassword: function () {
		var consonant, letter, vowel;
		letter = /[a-zA-Z]$/;
		vowel = /[aeiouAEIOU]$/;
		consonant = /[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]$/;
		return function (length, memorable, pattern, prefix) {
			var chr, n;
			null == length && (length = 10);
			null == memorable && (memorable = !0);
			null == pattern && (pattern = /\w/);
			null == prefix && (prefix = "");
			if (prefix.length >= length) return prefix;
			memorable && (pattern = consonant.test(prefix) ? vowel : consonant);
			n = Math.floor(100 * Math.random()) % 94 + 33;
			chr = String.fromCharCode(n);
			memorable && (chr = chr.toLowerCase());
			return pattern.test(chr) ? utils.generatePassword(length, memorable, pattern, "" + prefix + chr) : utils.generatePassword(length, memorable, pattern, prefix)
		}
	}(),
	versionCompare: function (v1, operator, v2) {
		var compare, i, numVersion, prepVersion, vm, x, _i;
		i = x = compare = 0;
		vm = {
			dev: -6,
			alpha: -5,
			a: -5,
			beta: -4,
			b: -4,
			RC: -3,
			rc: -3,
			"#": -2,
			p: -1,
			pl: -1
		};
		prepVersion = function (v) {
			v = ("" + v).replace(/[_\-+]/g, ".");
			v = v.replace(/([^.\d]+)/g, ".$1.").replace(/\.{2,}/g, ".");
			return v.length ? v.split(".") : [-8]
		};
		numVersion = function (v) {
			return v ? isNaN(v) ? vm[v] || -7 : parseInt(v, 10) : 0
		};
		v1 = prepVersion(v1);
		v2 = prepVersion(v2);
		x = Math.max(v1.length, v2.length);
		for (i = _i = 0; x >= 0 ? x >= _i : _i >= x; i = x >= 0 ? ++_i : --_i)
			if (v1[i] !== v2[i]) {
				v1[i] = numVersion(v1[i]);
				v2[i] = numVersion(v2[i]);
				if (v1[i] < v2[i]) {
					compare = -1;
					break
				}
				if (v1[i] > v2[i]) {
					compare = 1;
					break
				}
			}
		if (!operator) return compare;
		switch (operator) {
		case ">":
		case "gt":
			return compare > 0;
		case ">=":
		case "ge":
			return compare >= 0;
		case "<=":
		case "le":
			return 0 >= compare;
		case "==":
		case "=":
		case "eq":
		case "is":
			return 0 === compare;
		case "<>":
		case "!=":
		case "ne":
		case "isnt":
			return 0 !== compare;
		case "":
		case "<":
		case "lt":
			return 0 > compare;
		default:
			return null
		}
	},
	getDummyName: function () {
		var gp, gr, u;
		u = KD.utils;
		gr = u.getRandomNumber;
		gp = u.generatePassword;
		return gp(gr(10), !0)
	},
	generateDummyUserData: function () {
		var formData, u, uniqueness;
		u = KD.utils;
		uniqueness = (Date.now() + "").slice(6);
		return formData = {
			agree: "on",
			email: "sinanyasar+" + uniqueness + "@gmail.com",
			firstName: u.getDummyName(),
			lastName: u.getDummyName(),
			password: "123123123",
			passwordConfirm: "123123123",
			username: uniqueness
		}
	},
	registerDummyUser: function () {
		var u;
		if ("koding.com" !== location.hostname) {
			u = KD.utils;
			return KD.remote.api.JUser.register(u.generateDummyUserData(), function () {
				return function () {
					return location.reload(!0)
				}
			}(this))
		}
	},
	startRollbar: function () {
		return this.replaceFromTempStorage("_rollbar")
	},
	stopRollbar: function () {
		this.storeToTempStorage("_rollbar", window._rollbar);
		return window._rollbar = {
			push: function () {}
		}
	},
	startMixpanel: function () {
		return this.replaceFromTempStorage("mixpanel")
	},
	stopMixpanel: function () {
		this.storeToTempStorage("mixpanel", window.mixpanel);
		return window.mixpanel = {
			track: function () {}
		}
	},
	replaceFromTempStorage: function (name) {
		var item;
		return (item = this.tempStorage[name]) ? window[item] = item : log("no " + name + " in mainController temp storage")
	},
	storeToTempStorage: function (name, item) {
		return this.tempStorage[name] = item
	},
	tempStorage: function () {
		return KD.getSingleton("mainController").tempStorage
	},
	applyGradient: function (view, color1, color2) {
		var rule, rules, _i, _len, _results;
		rules = ["-moz-linear-gradient(100% 100% 90deg, " + color2 + ", " + color1 + ")", "-webkit-gradient(linear, 0% 0%, 0% 100%, from(" + color1 + "), to(" + color2 + "))"];
		_results = [];
		for (_i = 0, _len = rules.length; _len > _i; _i++) {
			rule = rules[_i];
			_results.push(view.setCss("backgroundImage", rule))
		}
		return _results
	},
	getAppIcon: function (name) {
		var image, img, thumb;
		image = "Ace" === name ? "icn-ace" : "default.app.thumb";
		thumb = "" + KD.apiUri + "/a/images/" + image + ".png";
		img = new KDCustomHTMLView({
			tagName: "img",
			bind: "error",
			error: function () {
				return this.getElement().setAttribute("src", "/a/images/default.app.thumb.png")
			},
			attributes: {
				src: thumb
			}
		});
		return img
	},
	compileCoffeeOnClient: function (coffeeCode, callback) {
		null == callback && (callback = noop);
		return require(["//cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js"], function (coffeeCompiler) {
			return callback(coffeeCompiler.eval(coffeeCode))
		})
	},
	showSaveDialog: function (container, callback, options) {
		var dialog, finder, finderController, finderWrapper, form, input, label, labelFinder, wrapper;
		null == callback && (callback = noop);
		null == options && (options = {});
		container.addSubView(dialog = new KDDialogView({
			cssClass: KD.utils.curry("save-as-dialog", options.cssClass),
			overlay: !0,
			container: container,
			height: "auto",
			buttons: {
				Save: {
					style: "solid green medium",
					callback: function () {
						return function () {
							return callback(input, finderController, dialog)
						}
					}(this)
				},
				Cancel: {
					style: "solid medium",
					callback: function () {
						return function () {
							finderController.stopAllWatchers();
							finderController.destroy();
							return dialog.hide()
						}
					}(this)
				}
			}
		}));
		dialog.on("KDObjectWillBeDestroyed", function () {
			var _ref;
			return null != (_ref = container.ace) ? _ref.focus() : void 0
		});
		dialog.addSubView(wrapper = new KDView({
			cssClass: "kddialog-wrapper"
		}));
		wrapper.addSubView(form = new KDFormView);
		form.addSubView(label = new KDLabelView({
			title: options.inputLabelTitle || "Filename:"
		}));
		form.addSubView(input = new KDInputView({
			label: label,
			defaultValue: options.inputDefaultValue || ""
		}));
		form.addSubView(labelFinder = new KDLabelView({
			title: options.finderLabel || "Select a folder:"
		}));
		dialog.show();
		input.setFocus();
		finderController = new NFinderController({
			nodeIdPath: "path",
			nodeParentIdPath: "parentPath",
			foldersOnly: !0,
			contextMenu: !1,
			loadFilesOnInit: !0
		});
		finder = finderController.getView();
		finderController.reset();
		form.addSubView(finderWrapper = new KDView({
			cssClass: "save-as-dialog save-file-container"
		}, null));
		finderWrapper.addSubView(finder);
		return finderWrapper.setHeight(200)
	},
	getEmbedType: function (type) {
		switch (type) {
		case "audio":
		case "xml":
		case "json":
		case "ppt":
		case "rss":
		case "atom":
			return "object";
		case "photo":
		case "image":
			return "image";
		case "link":
		case "html":
			return "link";
		case "error":
			log("Embedding error ");
			return "error";
		default:
			log("Unhandled content type '" + type + "'");
			return "error"
		}
	},
	getColorFromString: function (str) {
		return ["#37B298", "#BA4B3A", "#F1C42C", "#DB4B00", "#009BCB", "#37B298", "#35485F", "#D35219", "#FDAB2E", "#19A2C4", "#37B298", "#BA4B3A", "#F1C42C", "#DB4B00", "#009BCB", "#B82F68"][parseInt(md5.digest(str)[0], 16)]
	},
	formatMoney: accounting.formatMoney,
	stringToColor: function (str) {
		var color, hash, i, value, _i, _j, _ref;
		hash = 0;
		for (i = _i = 0, _ref = str.length; _ref >= 0 ? _ref > _i : _i > _ref; i = _ref >= 0 ? ++_i : --_i) hash = str.charCodeAt(i) + ((hash << 5) - hash);
		color = "#";
		for (i = _j = 0; 3 > _j; i = ++_j) {
			value = hash >> 8 * i & 255;
			color += ("00" + value.toString(16)).substr(-2)
		}
		return color
	},
	postDummyStatusUpdate: function () {
		var body, group, _ref, _ref1;
		if ("localhost" === location.hostname) {
			body = KD.utils.generatePassword(KD.utils.getRandomNumber(50), !0) + " " + dateFormat(Date.now(), "dddd, mmmm dS, yyyy, h:MM:ss TT");
			group = "group" === (null != (_ref = KD.config.entryPoint) ? _ref.type : void 0) && (null != (_ref1 = KD.config.entryPoint) ? _ref1.slug : void 0) ? KD.config.entryPoint.slug : "koding";
			return KD.remote.api.JNewStatusUpdate.create({
				body: body,
				group: group
			}, function () {
				return function (err, reply) {
					return err ? new KDNotificationView({
						type: "mini",
						title: "There was an error, try again later!"
					}) : KD.getSingleton("appManager").tell("Activity", "ownActivityArrived", reply)
				}
			}(this))
		}
	},
	logToExternalWithTime: function (name, timeout) {
		return KD.troubleshoot(function (times) {
			return KD.logToExternal({
				msg: "" + name + " timed out in " + timeout,
				pings: times
			})
		})
	},
	tokenizeTag: function (tag) {
		return "|#:JTag:" + tag.getId() + "|"
	},
	sortFiles: function (a, b) {
		var la, lb, na, nb;
		na = a.name;
		nb = b.name;
		la = na.toLowerCase();
		lb = nb.toLowerCase();
		switch (!1) {
		case la !== lb:
			switch (!1) {
			case na !== nb:
				return 0;
			case !(na > nb):
				return 1;
			case !(nb > na):
				return -1
			}
			break;
		case !(la > lb):
			return 1;
		case !(lb > la):
			return -1
		}
	},
	doesEmailValid: function (email) {
		return /@/.test(email)
	},
	setPrototypeOf: null != (_ref = Object.setPrototypeOf) ? _ref : function (obj, proto) {
		return obj.__proto__ = proto
	},
	nicetime: function () {
		var niceify;
		niceify = function (duration) {
			var day, durstr, hour, minute, past, second;
			past = !1;
			if (0 > duration) {
				past = !0;
				duration = Math.abs(duration)
			}
			duration = new Number(duration).toFixed(2);
			durstr = "";
			second = 1;
			minute = 60 * second;
			hour = 60 * minute;
			day = 24 * hour;
			durstr = minute > duration ? "less than a minute" : 2 * minute > duration ? "about a minute" : hour > duration ? Math.floor(duration / minute) + " minutes" : 2 * hour > duration ? "about an hour" : day > duration ? "about " + Math.floor(duration / hour) + " hours" : 2 * day > duration ? "1 day" : 365 * day > duration ? Math.floor(duration / day) + " days" : "over a year";
			past && (durstr += " ago");
			return durstr
		};
		return function (duration, to) {
			var from;
			if (!to) return niceify(duration);
			if (duration && to) {
				from = duration;
				to = to;
				return niceify(to - from)
			}
			if (!duration && to) {
				from = (new Date).getTime() / 1e3;
				to = to;
				return niceify(to - from)
			}
		}
	}(),
	oauthEnabled: function () {
		return "chromeapp" !== window.name
	}
});
var WebSocket, _ref, __hasProp = {}.hasOwnProperty,
	__slice = [].slice,
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
null != localStorage.disableWebSocket ? "true" === localStorage.disableWebSocket && (window.WebSocket = null) : KD.config.kites.disableWebSocketByDefault && (window.WebSocket = null);
KD.extend({
	apiUri: KD.config.apiUri,
	appsUri: KD.config.appsUri,
	singleton: KD.getSingleton.bind(KD),
	useNewKites: function () {
		var useNewKites;
		useNewKites = function () {
			switch (!1) {
			case !KD.config.kites.stack.force:
				return Boolean(KD.config.kites.stack.newKites);
			case null == localStorage.useNewKites:
				return Boolean(Number(localStorage.useNewKites))
			}
		}();
		localStorage.useNewKites = useNewKites ? "1" : "";
		return useNewKites
	}(),
	useWebSockets: "true" === localStorage.disableWebSocket ? (WebSocket = null, !1) : !0,
	appClasses: {},
	appScripts: {},
	appLabels: {},
	navItems: [],
	navItemIndex: {},
	toggleKiteStack: function () {
		localStorage.useNewKites = this.useNewKites ? "" : "1";
		return location.reload()
	},
	socketConnected: function () {
		return this.backendIsConnected = !0
	},
	registerAppClass: function (fn, options) {
		var name, route, routes, _ref;
		null == options && (options = {});
		if (!options.name) return error("AppClass is missing a name!");
		if (KD.appClasses[options.name]) {
			if (KD.config.apps[options.name]) return warn("AppClass " + options.name + " cannot be used, since its conflicting with an internal Koding App.");
			warn("AppClass " + options.name + " is already registered or the name is already taken!");
			warn("Removing the old one. It was ", KD.appClasses[options.name]);
			this.unregisterAppClass(options.name)
		}
		null == options.multiple && (options.multiple = !1);
		null == options.background && (options.background = !1);
		null == options.hiddenHandle && (options.hiddenHandle = !1);
		options.openWith || (options.openWith = "lastActive");
		options.behavior || (options.behavior = "");
		null == options.thirdParty && (options.thirdParty = !1);
		options.menu || (options.menu = null);
		options.navItem || (options.navItem = {});
		options.labels || (options.labels = []);
		null == options.version && (options.version = "1.0");
		options.route || (options.route = null);
		options.routes || (options.routes = null);
		options.styles || (options.styles = []);
		routes = options.routes, route = options.route, name = options.name;
		route ? this.registerRoute(name, route) : routes && this.registerRoutes(name, routes);
		(null != (_ref = options.navItem) ? _ref.order : void 0) && this.registerNavItem(options.navItem);
		return Object.defineProperty(KD.appClasses, name, {
			configurable: !0,
			enumerable: !0,
			writable: !1,
			value: {
				fn: fn,
				options: options
			}
		})
	},
	registerRoutes: function (appName, routes) {
		var handler, route, _results;
		_results = [];
		for (route in routes)
			if (__hasProp.call(routes, route)) {
				handler = routes[route];
				_results.push(this.registerRoute(appName, route, handler))
			}
		return _results
	},
	showEnforceLoginModal: function () {
		var appManager;
		if (!KD.isLoggedIn()) {
			if (!(Cookies.get("doNotForceRegistration") || location.search.indexOf("sr=1") > -1)) {
				appManager = KD.singletons.appManager;
				return appManager.tell("Account", "showRegistrationNeededModal")
			}
			Cookies.set("doNotForceRegistration", "true")
		}
	},
	registerRoute: function (appName, route, handler) {
		var cb, router, slug;
		slug = "string" == typeof route ? route : route.slug;
		route = {
			slug: null != slug ? slug : "/",
			handler: handler || route.handler || null
		};
		if ("/" !== route.slug || "KDMainApp" === appName) {
			slug = route.slug, handler = route.handler;
			cb = function () {
				var router;
				router = KD.getSingleton("router");
				null == handler && (handler = function (_arg) {
					var name, query, _ref;
					_ref = _arg.params, name = _ref.name, query = _arg.query;
					return router.openSection(appName, name, query)
				});
				return router.addRoute(slug, handler)
			};
			return (router = KD.singletons.router) ? cb() : KDRouter.on("RouterIsReady", cb)
		}
	},
	resetNavItems: function (items) {
		this.navItems = items;
		return this.navItemIndex = KD.utils.arrayToObject(items, "title")
	},
	registerNavItem: function (itemData) {
		if (!this.navItemIndex[itemData.title]) {
			this.navItemIndex[itemData.title] = itemData;
			this.navItems.push(itemData);
			return !0
		}
		return !1
	},
	getNavItems: function () {
		return this.navItems.sort(function (a, b) {
			return a.order - b.order
		})
	},
	setNavItems: function (navItems) {
		var item, _i, _len, _ref, _results;
		_ref = navItems.sort(function (a, b) {
			return a.order - b.order
		});
		_results = [];
		for (_i = 0, _len = _ref.length; _len > _i; _i++) {
			item = _ref[_i];
			_results.push(this.registerNavItem(item))
		}
		return _results
	},
	unregisterAppClass: function (name) {
		return delete KD.appClasses[name]
	},
	getAppClass: function (name) {
		var _ref;
		return (null != (_ref = KD.appClasses[name]) ? _ref.fn : void 0) || null
	},
	getAppOptions: function (name) {
		var _ref;
		return (null != (_ref = KD.appClasses[name]) ? _ref.options : void 0) || null
	},
	getAppVersion: function (name) {
		var _ref, _ref1;
		return (null != (_ref = KD.appClasses[name]) && null != (_ref1 = _ref.options) ? _ref1.version : void 0) || null
	},
	getAppScript: function (name) {
		return this.appScripts[name] || null
	},
	registerAppScript: function (name, script) {
		return this.appScripts[name] = script
	},
	unregisterAppScript: function (name) {
		return delete this.appScripts[name]
	},
	resetAppScripts: function () {
		return this.appScripts = {}
	},
	disableLogs: function () {
		var method, _i, _len, _ref;
		_ref = ["log", "warn", "error", "trace", "time", "timeEnd"];
		for (_i = 0, _len = _ref.length; _len > _i; _i++) {
			method = _ref[_i];
			window[method] = noop;
			KD[method] = noop
		}
		delete KD.logsEnabled;
		return "Logs are disabled now."
	},
	enableLogs: function (state) {
		null == state && (state = !0);
		if (!state) return KD.disableLogs();
		KD.log = window.log = console.log.bind(console);
		KD.warn = window.warn = console.warn.bind(console);
		KD.error = window.error = console.error.bind(console);
		KD.time = window.time = console.time.bind(console);
		KD.timeEnd = window.timeEnd = console.timeEnd.bind(console);
		KD.logsEnabled = !0;
		return "Logs are enabled now."
	},
	enabledBackendLogger: function (backendLoggerClass) {
		var frontloggerConsoleLog, oldConsoleLog;
		oldConsoleLog = console.log;
		frontloggerConsoleLog = function () {
			var args;
			args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			if (KD.logsEnabled) {
				oldConsoleLog.apply(this, arguments);
				return backendLoggerClass.info.apply(backendLoggerClass, arguments)
			}
		};
		console.log = frontloggerConsoleLog;
		return "Logs are logged to backend too."
	},
	impersonate: function (username) {
		return KD.remote.api.JAccount.impersonate(username, function (err) {
			return err ? new KDNotificationView({
				title: err.message
			}) : location.reload()
		})
	},
	notify_: function (message, type, duration) {
		null == type && (type = "");
		null == duration && (duration = 3500);
		return new KDNotificationView({
			cssClass: type,
			title: message,
			duration: duration
		})
	},
	requireMembership: function (options) {
		var callback, groupName, mainController, onFail, onFailMsg, silence, tryAgain;
		null == options && (options = {});
		callback = options.callback, onFailMsg = options.onFailMsg, onFail = options.onFail, silence = options.silence, tryAgain = options.tryAgain, groupName = options.groupName;
		if (KD.isLoggedIn()) return groupName ? this.joinGroup_(groupName, function (_this) {
			return function (err) {
				return err ? _this.notify_("Joining " + groupName + " group failed", "error") : "function" == typeof callback ? callback() : void 0
			}
		}(this)) : "function" == typeof callback ? callback() : void 0;
		onFailMsg && this.notify_(onFailMsg, "error");
		"function" == typeof onFail && onFail();
		silence || KD.getSingleton("router").handleRoute("/Login", {
			entryPoint: KD.config.entryPoint
		});
		if (null != callback && tryAgain && !KD.lastFuncCall) {
			KD.lastFuncCall = callback;
			mainController = KD.getSingleton("mainController");
			return mainController.once("accountChanged.to.loggedIn", function (_this) {
				return function () {
					if (KD.isLoggedIn()) {
						"function" == typeof KD.lastFuncCall && KD.lastFuncCall();
						KD.lastFuncCall = null;
						if (groupName) return _this.joinGroup_(groupName, function (err) {
							return err ? _this.notify_("Joining " + groupName + " group failed", "error") : void 0
						})
					}
				}
			}(this))
		}
	},
	joinGroup_: function (groupName, callback) {
		var user;
		if (!groupName) return callback(null);
		user = this.whoami();
		return user.checkGroupMembership(groupName, function (_this) {
			return function (err, isMember) {
				return err ? callback(err) : isMember ? callback(null) : _this.remote.api.JGroup.one({
					slug: groupName
				}, function (err, currentGroup) {
					return err ? callback(err) : currentGroup ? currentGroup.join(function (err) {
						if (err) return callback(err);
						_this.notify_("You have joined to " + groupName + " group!", "success");
						return callback(null)
					}) : callback(null)
				})
			}
		}(this))
	},
	nick: function () {
		var _ref, _ref1;
		return null != (_ref = KD.whoami()) && null != (_ref1 = _ref.profile) ? _ref1.nickname : void 0
	},
	whoami: function () {
		return KD.userAccount
	},
	logout: function () {
		var mainController;
		mainController = KD.getSingleton("mainController");
		mainController.isLoggingIn(!0);
		return delete KD.userAccount
	},
	isGuest: function () {
		return !KD.isLoggedIn()
	},
	isLoggedIn: function () {
		var _ref;
		return "registered" === (null != (_ref = KD.whoami()) ? _ref.type : void 0)
	},
	isMine: function (account) {
		return KD.whoami().profile.nickname === account.profile.nickname
	},
	checkFlag: function (flagToCheck, account) {
		var flag, _i, _len;
		null == account && (account = KD.whoami());
		if (account.globalFlags) {
			if ("string" == typeof flagToCheck) return __indexOf.call(account.globalFlags, flagToCheck) >= 0;
			for (_i = 0, _len = flagToCheck.length; _len > _i; _i++) {
				flag = flagToCheck[_i];
				if (__indexOf.call(account.globalFlags, flag) >= 0) return !0
			}
		}
		return !1
	},
	showError: function (err, messages) {
		var content, defaultMessages, duration, er, errMessage, message, title, _i, _len;
		if (!err) return !1;
		if (Array.isArray(err)) {
			for (_i = 0, _len = err.length; _len > _i; _i++) {
				er = err[_i];
				this.showError(er)
			}
			return err.length
		}
		if ("string" == typeof err) {
			message = err;
			err = {
				message: message
			}
		}
		defaultMessages = {
			AccessDenied: "Permission denied",
			KodingError: "Something went wrong"
		};
		err.name || (err.name = "KodingError");
		content = "";
		messages && (errMessage = messages[err.name] || messages.KodingError || defaultMessages.KodingError);
		messages || (messages = defaultMessages);
		errMessage || (errMessage = err.message || messages[err.name] || messages.KodingError);
		null != errMessage && ("string" == typeof errMessage ? title = errMessage : null != errMessage.title && null != errMessage.content && (title = errMessage.title, content = errMessage.content));
		duration = errMessage.duration || 2500;
		title || (title = err.message);
		new KDNotificationView({
			title: title,
			content: content,
			duration: duration
		});
		if ("AccessDenied" !== err.name) {
			warn("KodingError:", err.message);
			error(err)
		}
		return null != err
	},
	getPathInfo: function (fullPath) {
		var basename, isPublic, parent, path, vmName;
		if (!fullPath) return !1;
		path = FSHelper.plainPath(fullPath);
		basename = FSHelper.getFileNameFromPath(fullPath);
		parent = FSHelper.getParentPath(path);
		vmName = FSHelper.getVMNameFromPath(fullPath);
		isPublic = FSHelper.isPublicPath(fullPath);
		return {
			path: path,
			basename: basename,
			parent: parent,
			vmName: vmName,
			isPublic: isPublic
		}
	},
	getPublicURLOfPath: function (fullPath, secure) {
		var isPublic, path, pathPartials, publicPath, subdomain, user, vmName, _, _ref;
		null == secure && (secure = !1);
		_ref = KD.getPathInfo(fullPath), vmName = _ref.vmName, isPublic = _ref.isPublic, path = _ref.path;
		if (isPublic) {
			pathPartials = path.match(/^\/home\/(\w+)\/Web\/(.*)/);
			if (pathPartials) {
				_ = pathPartials[0], user = pathPartials[1], publicPath = pathPartials[2];
				publicPath || (publicPath = "");
				subdomain = /^shared\-/.test(vmName) && user === KD.nick() ? "" + user + "." : "";
				return "" + (secure ? "https" : "http") + "://" + subdomain + vmName + "/" + publicPath
			}
		}
	},
	runningInFrame: function () {
		return window.top !== window.self
	},
	getGroup: function () {
		return KD.currentGroup
	},
	getReferralUrl: function (username) {
		return "" + location.origin + "/R/" + username
	},
	tell: function () {
		var _ref;
		return (_ref = KD.getSingleton("appManager")).tell.apply(_ref, arguments)
	},
	hasAccess: function (permission) {
		return __indexOf.call(KD.config.roles, "admin") >= 0 ? !0 : __indexOf.call(KD.config.permissions, permission) >= 0
	}
});
Object.defineProperty(KD, "defaultSlug", {
	get: function () {
		return KD.isGuest() ? "guests" : "koding"
	}
});
KD.enableLogs(Cookies.get("enableLogs") || !(null != (_ref = KD.config) ? _ref.suppressLogs : void 0));
var KodingRouter, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
KodingRouter = function (_super) {
	function KodingRouter(defaultRoute) {
		this.defaultRoute = defaultRoute;
		this.breadcrumb = [];
		this.defaultRoute || (this.defaultRoute = location.pathname + location.search);
		this.openRoutes = {};
		this.openRoutesById = {};
		KD.singleton("display").on("DisplayIsDestroyed", this.bound("cleanupRoute"));
		KodingRouter.__super__.constructor.call(this);
		this.on("AlreadyHere", function () {
			return log("You're already here!")
		})
	}
	var getSectionName, nicenames;
	__extends(KodingRouter, _super);
	nicenames = {
		StartTab: "Develop"
	};
	getSectionName = function (model) {
		var sectionName;
		sectionName = nicenames[model.bongo_.constructorName];
		return null != sectionName ? " - " + sectionName : ""
	};
	KodingRouter.prototype.listen = function () {
		KodingRouter.__super__.listen.apply(this, arguments);
		return this.userRoute ? void 0 : KD.utils.defer(function (_this) {
			return function () {
				return _this.handleRoute(_this.defaultRoute, {
					shouldPushState: !0,
					replaceState: !0,
					entryPoint: KD.config.entryPoint
				})
			}
		}(this))
	};
	KodingRouter.prototype.handleRoute = function (route, options) {
		var appManager, entryPoint, entrySlug, frags, name, _content, _extra, _root, _slug;
		null == options && (options = {});
		this.breadcrumb.push(route);
		entryPoint = options.entryPoint || KD.config.entryPoint;
		frags = route.split("?")[0].split("/");
		_root = frags[0], _slug = frags[1], _content = frags[2], _extra = frags[3];
		name = _slug === (null != entryPoint ? entryPoint.slug : void 0) ? "Apps" === _content && null != _extra ? _extra : _content : _slug;
		appManager = KD.getSingleton("appManager");
		if (appManager.isAppInternal(name)) return KodingAppsController.loadInternalApp(name, function (_this) {
			return function (err) {
				return err ? warn(err) : KD.utils.defer(function () {
					return _this.handleRoute(route, options)
				})
			}
		}(this));
		if ((null != entryPoint ? entryPoint.slug : void 0) && "group" === entryPoint.type) {
			entrySlug = "/" + entryPoint.slug;
			RegExp("^" + entrySlug).test(route) || "/koding" === entrySlug || (route = entrySlug + route)
		}
		return KodingRouter.__super__.handleRoute.call(this, route, options)
	};
	KodingRouter.prototype.cleanupRoute = function (contentDisplay) {
		return delete this.openRoutes[this.openRoutesById[contentDisplay.id]]
	};
	KodingRouter.prototype.openSection = function (app, group, query) {
		var appManager, appWasOpen, handleQuery;
		appManager = KD.singletons.appManager;
		handleQuery = appManager.tell.bind(appManager, app, "handleQuery", query);
		(appWasOpen = appManager.get(app)) || appManager.once("AppCreated", handleQuery);
		appManager.open(app);
		return appWasOpen ? handleQuery() : void 0
	};
	KodingRouter.prototype.handleNotFound = function (route) {
		var status_301, status_404;
		status_404 = KDRouter.prototype.handleNotFound.bind(this, route);
		status_301 = function (_this) {
			return function (redirectTarget) {
				return _this.handleRoute("/" + redirectTarget, {
					replaceState: !0
				})
			}
		}(this);
		return KD.remote.api.JUrlAlias.resolve(route, function (err, target) {
			return err || null == target ? status_404() : status_301(target)
		})
	};
	KodingRouter.prototype.getDefaultRoute = function () {
		return KD.isLoggedIn() ? "/Activity" : "/Home"
	};
	KodingRouter.prototype.setPageTitle = function (title) {
		null == title && (title = "Koding");
		return document.title = Encoder.htmlDecode(title)
	};
	KodingRouter.prototype.openContent = function (name, section, models, route, query, passOptions) {
		var callback, currentGroup, groupName, groupsController, method, options;
		null == passOptions && (passOptions = !1);
		method = "createContentDisplay";
		Array.isArray(models) && (models = models[0]);
		if (passOptions) {
			method += "WithOptions";
			options = {
				model: models,
				route: route,
				query: query
			}
		}
		callback = function (_this) {
			return function () {
				return KD.getSingleton("appManager").tell(section, method, null != options ? options : models, function (contentDisplay) {
					var routeWithoutParams;
					if (contentDisplay) {
						routeWithoutParams = route.split("?")[0];
						_this.openRoutes[routeWithoutParams] = contentDisplay;
						_this.openRoutesById[contentDisplay.id] = routeWithoutParams;
						return contentDisplay.emit("handleQuery", query)
					}
					console.warn("no content display")
				})
			}
		}(this);
		groupsController = KD.getSingleton("groupsController");
		currentGroup = groupsController.getCurrentGroup();
		if (currentGroup) return callback();
		groupName = "Groups" === section ? name : "koding";
		return groupsController.changeGroup(groupName, function () {
			return function (err) {
				err && KD.showError(err);
				return callback()
			}
		}(this))
	};
	KodingRouter.prototype.loadContent = function (name, section, slug, route, query, passOptions) {
		var groupName, routeWithoutParams;
		routeWithoutParams = route.split("?")[0];
		groupName = "Groups" === section ? name : "koding";
		return KD.getSingleton("groupsController").changeGroup(groupName, function (_this) {
			return function (err) {
				var onError, onSuccess, slashlessSlug;
				err && KD.showError(err);
				onSuccess = function (models) {
					return _this.openContent(name, section, models, route, query, passOptions)
				};
				onError = function (err) {
					KD.showError(err);
					return _this.handleNotFound(route)
				};
				if (name && !slug) return KD.remote.cacheable(name, function (err, models) {
					return null != models ? onSuccess(models) : onError(err)
				});
				slashlessSlug = routeWithoutParams.slice(1);
				return KD.remote.api.JName.one({
					name: slashlessSlug
				}, function (err, jName) {
					var models;
					if (err) return onError(err);
					if (null != jName) {
						models = [];
						return jName.slugs.forEach(function (aSlug, i) {
							var constructorName, konstructor, selector, usedAsPath;
							constructorName = aSlug.constructorName, usedAsPath = aSlug.usedAsPath;
							selector = {};
							konstructor = KD.remote.api[constructorName];
							selector[usedAsPath] = aSlug.slug;
							aSlug.group && (selector.group = aSlug.group);
							return null != konstructor ? konstructor.one(selector, function (err, model) {
								if (null != err || !model) return onError(err);
								models[i] = model;
								return models.length === jName.slugs.length ? onSuccess(models) : onError()
							}) : void 0
						})
					}
					return onError()
				})
			}
		}(this))
	};
	KodingRouter.prototype.clear = function (route, replaceState) {
		var entryPoint, _ref;
		null == replaceState && (replaceState = !0);
		if (!route) {
			entryPoint = KD.config.entryPoint;
			route = KD.isLoggedIn() && "group" === (null != entryPoint ? entryPoint.type : void 0) && null != (null != entryPoint ? entryPoint.slug : void 0) ? "/" + (null != (_ref = KD.config.entryPoint) ? _ref.slug : void 0) : "/"
		}
		return KodingRouter.__super__.clear.call(this, route, replaceState)
	};
	return KodingRouter
}(KDRouter);
var apiEndpoint, getSessionToken, _ref;
getSessionToken = function () {
	return Cookies.get("clientId")
};
apiEndpoint = KD.config.socialApiUri;
KD.remote = new Bongo({
	apiEndpoint: apiEndpoint,
	resourceName: null != (_ref = KD.config.resourceName) ? _ref : "koding-social",
	getUserArea: function () {
		return KD.getSingleton("groupsController").getUserArea()
	},
	getSessionToken: getSessionToken,
	apiDescriptor: REMOTE_API,
	fetchName: function () {
		var cache, dash;
		cache = {};
		dash = Bongo.dash;
		return function (nameStr, callback) {
			var model, name, _ref1;
			if (null != cache[nameStr]) {
				_ref1 = cache[nameStr], model = _ref1.model, name = _ref1.name;
				return callback(null, model, name)
			}
			return this.api.JName.one({
				name: nameStr
			}, function (_this) {
				return function (err, name) {
					var models, queue;
					if (err) return callback(err);
					if (null == name) return callback(new Error("Unknown name: " + nameStr));
					"JUser" === name.slugs[0].constructorName && (name = new _this.api.JName({
						name: name.name,
						slugs: [{
							constructorName: "JAccount",
							collectionName: "jAccounts",
							slug: name.name,
							usedAsPath: "profile.nickname"
						}]
					}));
					models = [];
					err = null;
					queue = name.slugs.map(function (slug) {
						return function () {
							var selector, _base;
							selector = {};
							selector[slug.usedAsPath] = slug.slug;
							return "function" == typeof (_base = _this.api[slug.constructorName]).one ? _base.one(selector, function (err, model) {
								if (err) return callback(err);
								null == model ? err = new Error("Unable to find model: " + nameStr + " of type " + name.constructorName) : models.push(model);
								return queue.fin()
							}) : void 0
						}
					});
					return dash(queue, function () {
						_this.emit("modelsReady");
						return callback(err, models, name)
					})
				}
			}(this))
		}
	}(),
	mq: function () {
		var authExchange, broker, options, servicesEndpoint;
		authExchange = KD.config.authExchange;
		servicesEndpoint = KD.config.usePremiumBroker ? KD.config.premiumBroker.servicesEndpoint : KD.config.broker.servicesEndpoint;
		options = {
			servicesEndpoint: servicesEndpoint,
			authExchange: authExchange,
			autoReconnect: !0,
			getSessionToken: getSessionToken
		};
		return broker = new KDBroker.Broker(null, options)
	}()
});
KD.kite = {
	mq: function () {
		var authExchange, broker, brokerExchange, options, servicesEndpoint, _ref1, _ref2;
		authExchange = KD.config.authExchange;
		KD.config.usePremiumBroker ? (_ref1 = KD.config.premiumBrokerKite, servicesEndpoint = _ref1.servicesEndpoint, brokerExchange = _ref1.brokerExchange) : (_ref2 = KD.config.brokerKite, servicesEndpoint = _ref2.servicesEndpoint, brokerExchange = _ref2.brokerExchange);
		options = {
			servicesEndpoint: servicesEndpoint,
			authExchange: authExchange,
			autoReconnect: !0,
			getSessionToken: getSessionToken,
			brokerExchange: brokerExchange,
			tryResubscribing: !1
		};
		return broker = new KDBroker.Broker(null, options)
	}()
};
var apiEndpoint, getSessionToken;
getSessionToken = function () {
	return Cookies.get("clientId")
};
apiEndpoint = KD.config.logApiUri;
KD.remoteLog = new Bongo({
	apiEndpoint: apiEndpoint,
	resourceName: KD.config.logResourceName,
	getUserArea: function () {
		return KD.getSingleton("groupsController").getUserArea()
	},
	getSessionToken: getSessionToken,
	apiDescriptor: REMOTE_LOGGING_API
});
var JView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
JView = function (_super) {
	function JView() {
		return JView.__super__.constructor.apply(this, arguments)
	}
	__extends(JView, _super);
	JView.mixin = function (target) {
		target.viewAppended = this.prototype.viewAppended;
		return target.setTemplate = this.prototype.setTemplate
	};
	JView.prototype.viewAppended = function () {
		var template;
		template = this.getOptions().pistachio || this.pistachio;
		"function" == typeof template && (template = template.call(this));
		if (null != template) {
			this.setTemplate(template);
			return this.template.update()
		}
	};
	JView.prototype.setTemplate = function (tmpl, params) {
		var options, _ref;
		null == params && (params = null != (_ref = this.getOptions()) ? _ref.pistachioParams : void 0);
		options = null != params ? {
			params: params
		} : void 0;
		this.template = new Pistachio(this, tmpl, options);
		this.updatePartial(this.template.html);
		return this.template.embedSubViews()
	};
	JView.prototype.pistachio = function (tmpl) {
		return tmpl ? "" + this.options.prefix + tmpl + this.options.suffix : void 0
	};
	return JView
}(KDView);
var JCustomHTMLView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
JCustomHTMLView = function (_super) {
	function JCustomHTMLView() {
		return JCustomHTMLView.__super__.constructor.apply(this, arguments)
	}
	__extends(JCustomHTMLView, _super);
	JView.mixin(JCustomHTMLView.prototype);
	return JCustomHTMLView
}(KDCustomHTMLView);
var ActivityController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ActivityController = function (_super) {
	function ActivityController(options, data) {
		var appManager, groupChannel, groupsController, _ref;
		null == options && (options = {});
		ActivityController.__super__.constructor.call(this, options, data);
		this.newItemsCount = 0;
		this.flags = {};
		groupChannel = null;
		_ref = KD.singletons, groupsController = _ref.groupsController, appManager = _ref.appManager;
		groupsController.ready(function (_this) {
			return function () {
				null != groupChannel && groupChannel.close().off();
				groupChannel = groupsController.groupChannel;
				return groupChannel.on("feed-new", function (activities) {
					var activity, isOnActivityPage, revivedActivities;
					revivedActivities = function () {
						var _i, _len, _results;
						_results = [];
						for (_i = 0, _len = activities.length; _len > _i; _i++) {
							activity = activities[_i];
							_results.push(KD.remote.revive(activity))
						}
						return _results
					}();
					isOnActivityPage = "/Activity" === KD.getSingleton("router").getCurrentPath();
					return isOnActivityPage ? void 0 : ++_this.newItemsCount
				})
			}
		}(this));
		this.on("ActivityItemBlockUserClicked", this.bound("openBlockUserModal"));
		this.on("ActivityItemMarkUserAsTrollClicked", this.bound("markUserAsTroll"));
		this.on("ActivityItemUnMarkUserAsTrollClicked", this.bound("unmarkUserAsTroll"));
		this.setPageTitleForActivities();
		appManager.on("AppIsBeingShown", function (_this) {
			return function (appController, appView, appOptions) {
				return "Activity" === appOptions.name ? _this.clearNewItemsCount() : void 0
			}
		}(this))
	}
	__extends(ActivityController, _super);
	ActivityController.prototype.blockUser = function (accountId, duration, callback) {
		return KD.whoami().blockUser(accountId, duration, callback)
	};
	ActivityController.prototype.openBlockUserModal = function (nicknameOrAccountId) {
		var calculateBlockingTime, changeButtonTitle, form, modal;
		this.modal = modal = new KDModalViewWithForms({
			title: "Block User For a Time Period",
			content: "<div class='modalformline'>\nThis will block user from logging in to Koding(with all sub-groups).<br><br>\nYou can specify a duration to block user.\nEntry format: [number][S|H|D|T|M|Y] eg. 1M\n</div>",
			overlay: !0,
			cssClass: "modalformline",
			width: 600,
			height: "auto",
			tabs: {
				forms: {
					BlockUser: {
						callback: function (_this) {
							return function () {
								var blockingTime;
								blockingTime = calculateBlockingTime(modal.modalTabs.forms.BlockUser.inputs.duration.getValue());
								return _this.blockUser(nicknameOrAccountId, blockingTime, function (err) {
									if (err) {
										warn(err);
										return modal.modalTabs.forms.BlockUser.buttons.blockUser.hideLoader()
									}
									modal.destroy();
									return new KDNotificationView({
										title: "User is blocked!"
									})
								})
							}
						}(this),
						buttons: {
							blockUser: {
								title: "Block User",
								style: "modal-clean-gray",
								type: "submit",
								loader: {
									color: "#444444",
									diameter: 12
								},
								callback: function () {
									return this.hideLoader()
								}
							},
							cancel: {
								title: "Cancel",
								style: "modal-cancel"
							}
						},
						fields: {
							duration: {
								label: "Block User For",
								itemClass: KDInputView,
								name: "duration",
								placeholder: "e.g. 1Y 1W 3D 2H...",
								keyup: function () {
									return changeButtonTitle(this.getValue())
								},
								change: function () {
									return changeButtonTitle(this.getValue())
								},
								validate: {
									rules: {
										required: !0,
										minLength: 2,
										regExp: /\d[SHDTMY]+/i
									},
									messages: {
										required: "Please enter a time period",
										minLength: "You must enter one pair",
										regExp: "Entry should be in following format [number][S|H|D|T|M|Y] eg. 1M"
									}
								},
								iconOptions: {
									tooltip: {
										placement: "right",
										offset: 2,
										title: "You can enter {#}H/D/W/M/Y,\nOrder is not sensitive."
									}
								}
							}
						}
					}
				}
			}
		});
		form = modal.modalTabs.forms.BlockUser;
		form.on("FormValidationFailed", function () {});
		form.buttons.blockUser.hideLoader();
		changeButtonTitle = function (value) {
			var blockingTime, button, date;
			blockingTime = calculateBlockingTime(value);
			button = modal.modalTabs.forms.BlockUser.buttons.blockUser;
			if (blockingTime > 0) {
				date = new Date(Date.now() + blockingTime);
				return button.setTitle("Block until: " + date.toUTCString())
			}
			return button.setTitle("Block")
		};
		return calculateBlockingTime = function (value) {
			var hour, numericalValue, timeCase, totalTimestamp, val, _i, _len, _ref;
			totalTimestamp = 0;
			if (!value) return totalTimestamp;
			_ref = value.split(" ");
			for (_i = 0, _len = _ref.length; _len > _i; _i++) {
				val = _ref[_i];
				numericalValue = parseInt(val.slice(0, -1), 10) || 0;
				if (0 !== numericalValue) {
					hour = 60 * numericalValue * 60 * 1e3;
					timeCase = val.charAt(val.length - 1);
					switch (timeCase.toUpperCase()) {
					case "S":
						totalTimestamp = 1e3;
						break;
					case "H":
						totalTimestamp = hour;
						break;
					case "D":
						totalTimestamp = 24 * hour;
						break;
					case "W":
						totalTimestamp = 24 * hour * 7;
						break;
					case "M":
						totalTimestamp = 24 * hour * 30;
						break;
					case "Y":
						totalTimestamp = 24 * hour * 365
					}
				}
			}
			return totalTimestamp
		}
	};
	ActivityController.prototype.unmarkUserAsTroll = function (data) {
		var kallback;
		kallback = function () {
			return function (acc) {
				return acc.markUserAsExempt(!1, function (err) {
					return err ? warn(err) : new KDNotificationView({
						title: "@" + acc.profile.nickname + " won't be treated as a troll anymore!"
					})
				})
			}
		}(this);
		return data.originId ? KD.remote.cacheable("JAccount", data.originId, function (err, account) {
			return account ? kallback(account) : void 0
		}) : "JAccount" === data.bongo_.constructorName ? kallback(data) : void 0
	};
	ActivityController.prototype.markUserAsTroll = function (data) {
		var modal;
		return modal = new KDModalView({
			title: "MARK USER AS TROLL",
			content: "<div class='modalformline'>\nThis is what we call \"Trolling the troll\" mode.<br><br>\nAll of the troll's activity will disappear from the feeds, but the troll\nhimself will think that people still gets his posts/comments.<br><br>\nAre you sure you want to mark him as a troll?\n</div>",
			height: "auto",
			overlay: !0,
			width: 475,
			buttons: {
				"YES, THIS USER IS DEFINITELY A TROLL": {
					style: "modal-clean-red",
					loader: {
						color: "#ffffff",
						diameter: 16
					},
					callback: function () {
						return function () {
							var kallback;
							kallback = function (acc) {
								return acc.markUserAsExempt(!0, function (err) {
									if (err) return warn(err);
									modal.destroy();
									return new KDNotificationView({
										title: "@" + acc.profile.nickname + " marked as a troll!"
									})
								})
							};
							return data.originId ? KD.remote.cacheable("JAccount", data.originId, function (err, account) {
								return account ? kallback(account) : void 0
							}) : "JAccount" === data.bongo_.constructorName ? kallback(data) : void 0
						}
					}(this)
				}
			}
		})
	};
	ActivityController.prototype.setPageTitleForActivities = function () {
		this.oldTitle = document.title;
		KD.getSingleton("windowController").addFocusListener(function (_this) {
			return function (focused) {
				return focused ? document.title = _this.oldTitle : _this.updateDocTitle()
			}
		}(this));
		return KD.getSingleton("mainController").ready(function (_this) {
			return function () {
				return KD.getSingleton("activityController").on("ActivitiesArrived", function () {
					return KD.getSingleton("windowController").isFocused() ? void 0 : _this.updateDocTitle()
				})
			}
		}(this))
	};
	ActivityController.prototype.updateDocTitle = function () {
		var itemCount;
		itemCount = KD.getSingleton("activityController").getNewItemsCount(); - 1 === document.title.indexOf("Activity") && (this.oldTitle = document.title);
		return itemCount > 0 ? document.title = "(" + itemCount + ") Activity" : void 0
	};
	ActivityController.prototype.getNewItemsCount = function () {
		return this.newItemsCount
	};
	ActivityController.prototype.clearNewItemsCount = function () {
		var isOnActivityPage;
		isOnActivityPage = "/Activity" === KD.getSingleton("router").getCurrentPath();
		if (this.flags.liveUpdates && !isOnActivityPage) return !1;
		this.newItemsCount = 0;
		return this.emit("NewItemsCounterCleared")
	};
	return ActivityController
}(KDObject);
var SocialApiController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__slice = [].slice;
SocialApiController = function (_super) {
	function SocialApiController(options, data) {
		null == options && (options = {});
		SocialApiController.__super__.constructor.call(this, options, data)
	}
	var channelApiActivitiesResFunc, channelApiChannelsResFunc, fetchChannelActivities, fetchChannels, fetchGroupActivities, fetchPopularTopics, forwardMessageEvents, getCurrentGroup, mapActivities, mapActivity, mapChannels, mapPrivateMessages, messageApiMessageResFunc, registerAndOpenChannel, sendPrivateMessageRequest;
	__extends(SocialApiController, _super);
	mapActivities = function (messages) {
		var SocialMessage, m, message, revivedMessages, _i, _len, _ref, _ref1;
		if (!messages) return messages;
		messages.messageList && (messages = messages.messageList);
		messages = [].concat(messages);
		revivedMessages = [];
		SocialMessage = KD.remote.api.SocialMessage;
		for (_i = 0, _len = messages.length; _len > _i; _i++) {
			message = messages[_i];
			m = new SocialMessage(message.message);
			m._id = message.message.id;
			m.account = {};
			m.account.constructorName = "JAccount";
			m.account._id = message.accountOldId;
			m.meta = {};
			m.meta.likes = (null != (_ref = message.interactions) && null != (_ref1 = _ref.like) ? _ref1.length : void 0) || 0;
			m.meta.createdAt = message.message.createdAt;
			m.replies = message.replies;
			m.repliesCount = message.replies.length || 0;
			m.interactions = message.interactions;
			revivedMessages.push(m)
		}
		return revivedMessages
	};
	mapActivity = function (message) {
		var SocialMessage, m;
		if (!message) return message;
		SocialMessage = KD.remote.api.SocialMessage;
		m = new SocialMessage(message);
		m._id = message.id;
		m.meta = {};
		m.meta.createdAt = message.createdAt;
		return m
	};
	getCurrentGroup = function (callback) {
		var groupsController;
		groupsController = KD.getSingleton("groupsController");
		return groupsController.ready(function () {
			return callback(KD.getSingleton("groupsController").getCurrentGroup())
		})
	};
	fetchChannelActivities = function (options, callback) {
		return options.id ? getCurrentGroup(function (group) {
			options.groupName = group.slug;
			return channelApiActivitiesResFunc("fetchActivities", options, callback)
		}) : callback({
			message: "Channel id is not set for request"
		})
	};
	fetchGroupActivities = function (options, callback) {
		return getCurrentGroup(function (group) {
			if (!group.socialApiChannelId) return callback({
				message: "Group doesnt have socialApiChannelId"
			});
			options.id = group.socialApiChannelId;
			options.groupName = group.slug;
			return channelApiActivitiesResFunc("fetchActivities", options, callback)
		})
	};
	fetchChannels = function (options, callback) {
		return getCurrentGroup(function (group) {
			options.groupName = group.slug;
			return channelApiChannelsResFunc("fetchChannels", options, callback)
		})
	};
	fetchPopularTopics = function (options, callback) {
		return getCurrentGroup(function (group) {
			options.groupName = group.slug;
			return channelApiChannelsResFunc("fetchPopularTopics", options, callback)
		})
	};
	messageApiMessageResFunc = function () {
		var callback, name, rest, _i, _ref;
		name = arguments[0], rest = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
		return (_ref = KD.remote.api.SocialMessage)[name].apply(_ref, __slice.call(rest).concat([
			function (err, res) {
				return err ? callback(err) : callback(null, mapActivity(res))
			}
		]))
	};
	channelApiActivitiesResFunc = function () {
		var callback, name, rest, _i, _ref;
		name = arguments[0], rest = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
		return (_ref = KD.remote.api.SocialChannel)[name].apply(_ref, __slice.call(rest).concat([
			function (err, result) {
				return err ? callback(err) : callback(null, mapActivities(result))
			}
		]))
	};
	channelApiChannelsResFunc = function () {
		var callback, name, rest, _i, _ref;
		name = arguments[0], rest = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
		return (_ref = KD.remote.api.SocialChannel)[name].apply(_ref, __slice.call(rest).concat([
			function (err, result) {
				return err ? callback(err) : callback(null, mapChannels(result))
			}
		]))
	};
	sendPrivateMessageRequest = function () {
		var callback, name, rest, _i, _ref;
		name = arguments[0], rest = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
		return (_ref = KD.remote.api.SocialMessage)[name].apply(_ref, __slice.call(rest).concat([
			function (err, result) {
				return err ? callback(err) : callback(null, mapPrivateMessages(result))
			}
		]))
	};
	mapPrivateMessages = function (messages) {
		var mappedMessages, message, messageContainer, _i, _len;
		messages = [].concat(messages);
		if (!((null != messages ? messages.length : void 0) > 0)) return [];
		mappedMessages = [];
		for (_i = 0, _len = messages.length; _len > _i; _i++) {
			messageContainer = messages[_i];
			message = mapActivity(messageContainer.lastMessage);
			message.channel = mapChannels(messageContainer)[0];
			mappedMessages.push(message)
		}
		return mappedMessages
	};
	mapChannels = function (channels) {
		var SocialChannel, c, channel, data, revivedChannels, _i, _len;
		if (!channels) return channels;
		revivedChannels = [];
		channels = [].concat(channels);
		SocialChannel = KD.remote.api.SocialChannel;
		for (_i = 0, _len = channels.length; _len > _i; _i++) {
			channel = channels[_i];
			data = channel.channel;
			data.isParticipant = channel.isParticipant;
			data.participantCount = channel.participantCount;
			data.participantsPreview = channel.participantsPreview;
			c = new SocialChannel(data);
			c._id = "channel-" + c.id;
			registerAndOpenChannel(c);
			c.on("*", function () {
				return console.log(arguments)
			});
			c.on("MessageAdded", function () {
				return console.log(arguments, "messageadded")
			});
			revivedChannels.push(c)
		}
		return revivedChannels
	};
	forwardMessageEvents = function (source, target, events) {
		return events.forEach(function (event) {
			return source.on(event, function () {
				var message, rest;
				message = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
				message = mapActivity(message);
				return target.emit.apply(target, [event, message].concat(__slice.call(rest)))
			})
		})
	};
	registerAndOpenChannel = function (socialApiChannel) {
		return getCurrentGroup(function (group) {
			var brokerChannel, name, subscriptionData;
			subscriptionData = {
				serviceType: "socialapi",
				group: group.slug,
				channelType: socialApiChannel.typeConstant,
				channelName: socialApiChannel.name,
				isExclusive: !0
			};
			name = "socialapi." + socialApiChannel.groupName + "-" + socialApiChannel.typeConstant + "-" + socialApiChannel.name;
			brokerChannel = KD.remote.subscribe(name, subscriptionData);
			return forwardMessageEvents(brokerChannel, socialApiChannel, ["MessageAdded", "MessageRemoved"])
		})
	};
	SocialApiController.prototype.message = {
		edit: function () {
			var rest;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return messageApiMessageResFunc.apply(null, ["edit"].concat(__slice.call(rest)))
		},
		post: function () {
			var rest;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return messageApiMessageResFunc.apply(null, ["post"].concat(__slice.call(rest)))
		},
		reply: function () {
			var rest;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return messageApiMessageResFunc.apply(null, ["reply"].concat(__slice.call(rest)))
		},
		"delete": function () {
			var rest, _ref;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return (_ref = KD.remote.api.SocialMessage)["delete"].apply(_ref, rest)
		},
		like: function () {
			var rest, _ref;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return (_ref = KD.remote.api.SocialMessage).like.apply(_ref, rest)
		},
		unlike: function () {
			var rest, _ref;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return (_ref = KD.remote.api.SocialMessage).unlike.apply(_ref, rest)
		},
		sendPrivateMessage: function () {
			var rest;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return sendPrivateMessageRequest.apply(null, ["sendPrivateMessage"].concat(__slice.call(rest)))
		},
		fetchPrivateMessages: function () {
			var rest;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return sendPrivateMessageRequest.apply(null, ["fetchPrivateMessages"].concat(__slice.call(rest)))
		},
		revive: mapActivity
	};
	SocialApiController.prototype.channel = {
		list: fetchChannels,
		fetchActivities: fetchChannelActivities,
		fetchGroupActivities: fetchGroupActivities,
		fetchPopularTopics: fetchPopularTopics,
		fetchPinnedMessages: function () {
			var rest;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return channelApiActivitiesResFunc.apply(null, ["fetchPinnedMessages"].concat(__slice.call(rest)))
		},
		pin: function () {
			var rest, _ref;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return (_ref = KD.remote.api.SocialChannel).pinMessage.apply(_ref, rest)
		},
		unpin: function () {
			var rest, _ref;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return (_ref = KD.remote.api.SocialChannel).unpinMessage.apply(_ref, rest)
		},
		follow: function () {
			var rest, _ref;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return (_ref = KD.remote.api.SocialChannel).follow.apply(_ref, rest)
		},
		unfollow: function () {
			var rest, _ref;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return (_ref = KD.remote.api.SocialChannel).unfollow.apply(_ref, rest)
		},
		fetchFollowedChannels: function () {
			var rest;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return channelApiChannelsResFunc.apply(null, ["fetchFollowedChannels"].concat(__slice.call(rest)))
		}
	};
	return SocialApiController
}(KDController);
var NotificationController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NotificationController = function (_super) {
	function NotificationController() {
		NotificationController.__super__.constructor.apply(this, arguments);
		KD.getSingleton("mainController").on("AccountChanged", function (_this) {
			return function () {
				var _ref, _ref1;
				_this.off("NotificationHasArrived");
				null != (_ref = _this.notificationChannel) && _ref.close().off();
				null != (_ref1 = _this.notificationChannel) && _ref1.off();
				return _this.setListeners()
			}
		}(this))
	}
	var subjectMap;
	__extends(NotificationController, _super);
	subjectMap = function () {
		return {
			JNewStatusUpdate: "<a href='#'>status</a>",
			JPrivateMessage: "<a href='#'>private message</a>",
			JComment: "<a href='#'>comment</a>"
		}
	};
	NotificationController.prototype.setListeners = function () {
		var deleteUserCookie, displayEmailConfirmedNotification;
		this.notificationChannel = KD.remote.subscribe("notification", {
			serviceType: "notification",
			isExclusive: !0
		});
		this.notificationChannel.off();
		this.notificationChannel.on("message", function (_this) {
			return function (notification) {
				_this.emit("NotificationHasArrived", notification);
				if (notification.contents) {
					_this.emit(notification.event, notification.contents);
					return _this.prepareNotification(notification)
				}
			}
		}(this));
		this.on("GuestTimePeriodHasEnded", function () {
			return deleteUserCookie()
		});
		deleteUserCookie = function () {
			return Cookies.expire("clientId")
		};
		displayEmailConfirmedNotification = function (modal) {
			modal.off("KDObjectWillBeDestroyed");
			new KDNotificationView({
				title: "Thanks for confirming your e-mail address",
				duration: 5e3
			});
			return modal.destroy()
		};
		this.once("EmailShouldBeConfirmed", function () {
			var firstName, nickname, _ref;
			_ref = KD.whoami().profile, firstName = _ref.firstName, nickname = _ref.nickname;
			return KD.getSingleton("appManager").tell("Account", "displayConfirmEmailModal", name, nickname, function (_this) {
				return function (modal) {
					_this.once("EmailConfirmed", displayEmailConfirmedNotification.bind(_this, modal));
					return modal.on("KDObjectWillBeDestroyed", deleteUserCookie.bind(_this))
				}
			}(this))
		});
		this.on("UsernameChanged", function (_arg) {
			var oldUsername, username;
			username = _arg.username, oldUsername = _arg.oldUsername;
			deleteUserCookie();
			return new KDModalView({
				title: "Your username was changed",
				overlay: !0,
				content: '<div class="modalformline">\nYour username has been changed to <strong>' + username + "</strong>.\nYour <em>old</em> username <strong>" + oldUsername + "</strong> is\nnow available for registration by another Koding user.  You have\nbeen logged out.  If you wish, you may close this box, and save\nyour work locally.\n</div>",
				buttons: {
					Refresh: {
						style: "modal-clean-red",
						callback: function () {
							return location.replace("/Login")
						}
					},
					Close: {
						style: "modal-clean-gray",
						callback: function () {
							return modal.destroy()
						}
					}
				}
			})
		});
		return this.on("UserBlocked", function (_arg) {
			var blockedDate, modal;
			blockedDate = _arg.blockedDate;
			modal = new KDModalView({
				title: "Permission denied. You've been banned.",
				overlay: !0,
				overlayClick: !1,
				cancelable: !1,
				content: '<div class="modalformline">\n  Hello,\n  This account has been put on suspension by Koding moderators due to violation of our <a href="https://koding.com/acceptable.html">acceptable use policy</a>. The ban will be in effect until <strong>' + blockedDate + "</strong> at which time you will be able to log back in again. If you have any questions regarding this ban, please write to <a href='mailto:ban@koding.com?subject=Username: " + KD.whoami().profile.nickname + '\'>ban@koding.com</a> and allow 2-3 business days for us to research and reply. Even though your account is banned, all your data is safe and will be accessible once the ban is lifted.<br><br>\n\n  Please note, repeated violations of our <a href="https://koding.com/acceptable.html">acceptable use policy</a> will result in the permanent deletion of your account.<br><br>\n\n  Team Koding\n</div>',
				buttons: {
					Ok: {
						style: "modal-clean-gray",
						callback: function () {
							Cookies.expire("clientId");
							modal.destroy();
							return location.reload(!0)
						}
					}
				}
			});
			return this.utils.wait(1e4, function () {
				return function () {
					Cookies.expire("clientId");
					return location.reload(!0)
				}
			}(this))
		})
	};
	NotificationController.prototype.prepareNotification = function (notification) {
		var actionType, actor, actorType, fetchSubjectObj, isMine, options, origin, subject, _ref;
		options = {};
		_ref = notification.contents, origin = _ref.origin, subject = _ref.subject, actionType = _ref.actionType, actorType = _ref.actorType;
		isMine = (null != origin ? origin._id : void 0) && origin._id === KD.whoami()._id ? !0 : !1;
		actor = notification.contents[actorType];
		if (actor) {
			fetchSubjectObj = function () {
				return function (callback) {
					var args, method, _ref1, _ref2;
					if (!subject || "JPrivateMessage" === subject.constructorName) return callback(null);
					if ("JComment" === (_ref1 = subject.constructorName) || "JOpinion" === _ref1) {
						method = "fetchRelated";
						args = subject.id
					} else {
						method = "one";
						args = {
							_id: subject.id
						}
					}
					return null != (_ref2 = KD.remote.api[subject.constructorName]) ? _ref2[method](args, callback) : void 0
				}
			}(this);
			return KD.remote.cacheable(actor.constructorName, actor.id, function (_this) {
				return function (err, actorAccount) {
					return "unregistered" !== actorAccount.type ? fetchSubjectObj(function (err, subjectObj) {
						var actorName, originatorName, separator;
						if (!err && subjectObj) {
							actorName = KD.utils.getFullnameFromAccount(actorAccount);
							options.actorAvatar = new AvatarView({
								size: {
									width: 35,
									height: 35
								}
							}, actorAccount);
							options.title = function () {
								switch (actionType) {
								case "reply":
								case "opinion":
									if (isMine) switch (subject.constructorName) {
									case "JPrivateMessage":
										return "" + actorName + " replied to your " + subjectMap()[subject.constructorName] + ".";
									default:
										return "" + actorName + " commented on your " + subjectMap()[subject.constructorName] + "."
									} else switch (subject.constructorName) {
									case "JPrivateMessage":
										return "" + actorName + " also replied to your " + subjectMap()[subject.constructorName] + ".";
									default:
										originatorName = KD.utils.getFullnameFromAccount(origin);
										if (actorName === originatorName) {
											originatorName = "their own";
											separator = ""
										} else separator = "'s";
										return "" + actorName + " also commented on " + originatorName + separator + " " + subjectMap()[subject.constructorName] + "."
									}
									break;
								case "like":
									return "" + actorName + " liked your " + subjectMap()[subject.constructorName] + ".";
								case "newMessage":
									this.emit("NewMessageArrived");
									return "" + actorName + " sent you a " + subjectMap()[subject.constructorName] + ".";
								case "groupRequestApproved":
									return "Your membership request to <a href='#'>" + subjectObj.title + "</a> has been approved.";
								case "groupAccessRequested":
									return "" + actorName + " has requested access to <a href='#'>" + subjectObj.title + "</a>.";
								case "groupInvited":
									return "" + actorName + " has invited you to <a href='#'>" + subjectObj.title + "</a>.";
								case "groupJoined":
									return "" + actorName + " has joined <a href='/" + subjectObj.slug + "'>" + subjectObj.title + "</a>.";
								case "groupLeft":
									return "" + actorName + " has left <a href='/" + subjectObj.slug + "'>" + subjectObj.title + "</a>.";
								default:
									if ("follower" === actorType) return "" + actorName + " started following you."
								}
							}.call(_this);
							subject && (options.click = function () {
								var suffix, view;
								view = this;
								if ("JPrivateMessage" === subject.constructorName) return KD.getSingleton("router").handleRoute("/Inbox");
								if ("JOpinion" === subjectObj.constructor.name) return KD.remote.api.JOpinion.fetchRelated(subjectObj._id, function (err, post) {
									KD.getSingleton("router").handleRoute("/Activity/" + post.slug, {
										state: post
									});
									return view.destroy()
								});
								if ("JGroup" === subject.constructorName) {
									suffix = "";
									"groupAccessRequested" === actionType && (suffix = "/Dashboard");
									KD.getSingleton("router").handleRoute("/" + subjectObj.slug + suffix);
									return view.destroy()
								}
								KD.getSingleton("router").handleRoute("/Activity/" + subjectObj.slug, {
									state: subjectObj
								});
								return view.destroy()
							});
							options.type = actionType || actorType || "";
							return _this.notify(options)
						}
					}) : void 0
				}
			}(this))
		}
	};
	NotificationController.prototype.notify = function (options) {
		var notification;
		null == options && (options = {});
		options.title || (options.title = "notification arrived");
		notification = new KDNotificationView({
			type: "tray",
			cssClass: "mini realtime " + options.type,
			duration: 1e4,
			title: "<span></span>" + options.title,
			content: options.content || null
		});
		options.actorAvatar && notification.addSubView(options.actorAvatar);
		return notification.once("click", options.click)
	};
	return NotificationController
}(KDObject);
var LinkController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LinkController = function (_super) {
	function LinkController() {
		LinkController.__super__.constructor.apply(this, arguments);
		this.linkHandlers = {}
	}
	__extends(LinkController, _super);
	LinkController.prototype.handleLinkClick = function (link) {
		var JAccount, JGroup, JTag, data, group, href, nickname, options, route, slug, _ref;
		_ref = KD.remote.api, JAccount = _ref.JAccount, JGroup = _ref.JGroup, JTag = _ref.JTag;
		data = "function" == typeof link.getData ? link.getData() : void 0;
		if (null != data) {
			options = {};
			route = function () {
				switch (data.constructor) {
				case JAccount:
					slug = KD.getGroup().slug;
					nickname = data.profile.nickname;
					return href = "koding" === slug ? "/" + nickname : "/" + slug + "/" + nickname;
				case JGroup:
					return "/" + data.slug;
				case JTag:
					group = data.group, slug = data.slug;
					route = group === KD.defaultSlug ? "" : "/" + group;
					return route += "/Activity/?tagged=" + slug
				}
			}();
			return null != route ? KD.getSingleton("router").handleRoute(route, {
				state: data
			}) : void 0
		}
	};
	LinkController.prototype.registerLink = function (link) {
		var handler, id;
		id = link.getId();
		link.on("LinkClicked", handler = function (_this) {
			return function () {
				return _this.handleLinkClick(link)
			}
		}(this));
		return this.linkHandlers[id] = handler
	};
	LinkController.prototype.unregisterLink = function (link) {
		var id;
		id = link.getId();
		link.off(this.linkHandlers[id]);
		return delete this.linkHandlers[id]
	};
	return LinkController
}(KDController);
var OAuthController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
OAuthController = function (_super) {
	function OAuthController() {
		return OAuthController.__super__.constructor.apply(this, arguments)
	}
	var notify;
	__extends(OAuthController, _super);
	OAuthController.prototype.openPopup = function (provider) {
		KD.mixpanel("Authenticate with oauth, click", {
			provider: provider
		});
		return KD.singleton("appManager").require("Login", function () {
			return function () {
				KD.getSingleton("mainController").isLoggingIn(!0);
				return KD.remote.api.OAuth.getUrl(provider, function (err, url) {
					var name, newWindow, size;
					if (err) return notify(err);
					name = "Login";
					size = "height=643,width=1143";
					newWindow = window.open(url, name, size);
					if (newWindow) {
						newWindow.onunload = function () {
							var mainController;
							mainController = KD.getSingleton("mainController");
							return mainController.emit("ForeignAuthPopupClosed", provider)
						};
						return newWindow.focus()
					}
					notify("Please disable your popup blocker and try again.")
				})
			}
		}(this))
	};
	OAuthController.prototype.authCompleted = function (err, provider) {
		var mainController;
		mainController = KD.getSingleton("mainController");
		if (err) return notify(err);
		mainController.emit("ForeignAuthPopupClosed", provider);
		return mainController.emit("ForeignAuthCompleted", provider)
	};
	notify = function (err) {
		var message;
		message = err ? "" + err : "Something went wrong";
		return new KDNotificationView({
			title: message
		})
	};
	return OAuthController
}(KDController);
var WidgetController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
WidgetController = function (_super) {
	function WidgetController(options, data) {
		null == options && (options = {});
		WidgetController.__super__.constructor.call(this, options, data);
		this.placeholders = {};
		this.widgets = {
			preview: {},
			published: {}
		};
		this.registerPlaceholders();
		this.fetchWidgets()
	}
	__extends(WidgetController, _super);
	WidgetController.prototype.fetchWidgets = function () {
		var query;
		query = {
			partialType: "WIDGET",
			$or: [{
				isActive: !0
			}, {
				isPreview: !0
			}]
		};
		return KD.remote.api.JCustomPartials.some(query, {}, function (_this) {
			return function (err, widgets) {
				var key, target, widget, _i, _len, _results;
				if (widgets || err) {
					_results = [];
					for (_i = 0, _len = widgets.length; _len > _i; _i++) {
						widget = widgets[_i];
						target = "published";
						key = "viewInstance";
						if (widget.isPreview) {
							target = "preview";
							key = "previewInstance"
						}
						_results.push(_this.widgets[target][widget[key]] = widget)
					}
					return _results
				}
			}
		}(this))
	};
	WidgetController.prototype.registerPlaceholders = function () {
		this.placeholders.ActivityTop = {
			title: "Activity Top",
			key: "ActivityTop"
		};
		return this.placeholders.ActivityLeft = {
			title: "Activity Left",
			key: "ActivityLeft"
		}
	};
	WidgetController.prototype.getPlaceholders = function () {
		return this.placeholders
	};
	WidgetController.prototype.showWidgets = function (widgets) {
		var css, hasPlaceholder, isPreviewMode, js, key, targetKey, view, widget, widgetData, _i, _len, _ref, _results;
		isPreviewMode = Cookies.get("custom-partials-preview-mode");
		targetKey = isPreviewMode ? "preview" : "published";
		_results = [];
		for (_i = 0, _len = widgets.length; _len > _i; _i++) {
			widget = widgets[_i];
			view = widget.view, key = widget.key;
			widgetData = this.widgets[targetKey][key];
			hasPlaceholder = this.placeholders[key];
			if (view && key && widgetData && hasPlaceholder) try {
				_ref = widgetData.partial, css = _ref.css, js = _ref.js;
				js && this.evalJS(view, js);
				_results.push(css ? this.appendCSS(css, key) : void 0)
			} catch (_error) {
				_results.push(warn("" + key + " widget failed to load"))
			} else _results.push(void 0)
		}
		return _results
	};
	WidgetController.prototype.evalJS = function (view, js) {
		var jsCode;
		jsCode = "viewId = '" + view.getId() + "'; " + js;
		return eval(Encoder.htmlDecode(jsCode))
	};
	WidgetController.prototype.appendCSS = function (css, key) {
		var domId, oldElement, tag;
		domId = "" + key + "WidgetStyle";
		oldElement = document.getElementById(domId);
		oldElement && document.head.removeChild(oldElement);
		tag = document.createElement("style");
		tag.id = domId;
		tag.innerHTML = Encoder.htmlDecode(css);
		return document.head.appendChild(tag)
	};
	return WidgetController
}(KDController);
var LocalSyncController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LocalSyncController = function (_super) {
	function LocalSyncController() {
		LocalSyncController.__super__.constructor.apply(this, arguments);
		this.storage = KD.singletons.localStorageController.storage("editor");
		this.filesToSave = this.storage.getValue("saveRequestedFiles") || [];
		this.openedFiles = this.storage.getValue("openedFiles") || [];
		this.filesToSave.length > 0 && this.syncLocalContentIfDiffExists(function () {
			return log("Synced")
		});
		this.initializeListeners()
	}
	__extends(LocalSyncController, _super);
	LocalSyncController.prototype.initializeListeners = function () {
		return KD.remote.on("reconnected", function (_this) {
			return function () {
				if (!_this.synStarted) {
					_this.synStarted = !0;
					return _this.syncLocalContentIfDiffExists(function (err) {
						_this.synStarted = !1;
						return err ? KD.showError(err) : void 0
					})
				}
			}
		}(this))
	};
	LocalSyncController.prototype.syncLocalContentIfDiffExists = function (callback) {
		var dash, queue;
		dash = Bongo.dash;
		queue = this.filesToSave.map(function (_this) {
			return function (key) {
				return function () {
					var fsfile;
					fsfile = FSHelper.createFileFromPath(key);
					return _this.patchFileIfDiffExist(fsfile, _this.storage.getValue("OE-" + key), function () {
						return queue.fin()
					})
				}
			}
		}(this));
		return dash(queue, callback)
	};
	LocalSyncController.prototype.addToSaveArray = function (file) {
		var fileName, index;
		fileName = FSHelper.getFullPath(file);
		index = this.filesToSave.indexOf(fileName); - 1 === index && this.filesToSave.push(fileName);
		this.storage.setValue("saveRequestedFiles", this.filesToSave);
		this.addSaveRequestTime(file);
		return this.initializeListeners()
	};
	LocalSyncController.prototype.addSaveRequestTime = function (file) {
		var path;
		path = FSHelper.getFullPath(file);
		return this.storage.setValue("" + path + "-savetime", Date.now())
	};
	LocalSyncController.prototype.isFileVersionOk = function (file, lastUpdate) {
		var dt, localTime, path;
		path = FSHelper.getFullPath(file);
		localTime = this.storage.getValue("" + path + "-savetime");
		dt = new Date(lastUpdate);
		if (localTime > dt.getTime()) return !0;
		this.removeFileContentFromLocalStorage(file);
		this.removeFromSaveArray(file);
		this.storage.unsetKey("" + path + "-savetime");
		return !1
	};
	LocalSyncController.prototype.removeFromSaveArray = function (file) {
		var fileName, index;
		fileName = FSHelper.getFullPath(file);
		index = this.filesToSave.indexOf(fileName);
		if (index > -1) {
			this.filesToSave.splice(index, 1);
			return this.storage.setValue("saveRequestedFiles", this.filesToSave)
		}
	};
	LocalSyncController.prototype.patchFileIfDiffExist = function (file, localContent, cb, callCounter) {
		null == callCounter && (callCounter = 0);
		return KD.singletons.vmController.info(file.vmName, this.utils.getTimedOutCallback(function (_this) {
			return function (err, vm, info) {
				return "RUNNING" !== info.state ? cb(err) : FSHelper.getInfo(file.path, file.vmName, function (err, info) {
					return err ? KD.showError(err) : _this.isFileVersionOk(file, info.time) ? file.fetchContents(function (err, content) {
						if (content && !err) {
							if (content !== localContent) return file.save(localContent, function (err) {
								if (err) return cb(err);
								_this.removeFromSaveArray(file);
								_this.removeFileContentFromLocalStorage(file);
								_this.updateEditorStatus(file, localContent);
								_this.emit("LocalContentSynced", file);
								return cb(null, file)
							});
							_this.removeFromSaveArray(file);
							return cb(null, file)
						}
					}) : void 0
				})
			}
		}(this), function (_this) {
			return function () {
				++callCounter;
				return callCounter > 5 ? _this.emit("LocalContentCouldntSynced", file) : _this.patchFileIfDiffExist(file, localContent, cb, callCounter)
			}
		}(this)))
	};
	LocalSyncController.prototype.updateFileContentOnLocalStorage = function (file, content) {
		var fileName;
		fileName = FSHelper.getFullPath(file);
		return this.storage.setValue("OE-" + fileName, content)
	};
	LocalSyncController.prototype.removeFileContentFromLocalStorage = function (file) {
		var fileName;
		fileName = FSHelper.getFullPath(file);
		return this.storage.unsetKey("OE-" + fileName)
	};
	LocalSyncController.prototype.addToOpenedFiles = function (fileName) {
		var index, vmName;
		vmName = FSHelper.getVMNameFromPath(fileName);
		index = this.openedFiles.indexOf(fileName);
		if (-1 === index && vmName) {
			this.openedFiles.push(fileName);
			return this.storage.setValue("openedFiles", this.openedFiles)
		}
	};
	LocalSyncController.prototype.removeFromOpenedFiles = function (file) {
		var fileName, index;
		fileName = FSHelper.getFullPath(file);
		index = this.openedFiles.indexOf(fileName);
		if (-1 !== index) {
			this.openedFiles.splice(index, 1);
			this.storage.setValue("openedFiles", this.openedFiles);
			this.removeFromSaveArray(file);
			return this.removeFileContentFromLocalStorage(file)
		}
	};
	LocalSyncController.prototype.getRecentOpenedFiles = function () {
		return this.openedFiles
	};
	LocalSyncController.prototype.updateEditorStatus = function (file, lastSavedContent) {
		var ace, aceAppView, fileName;
		fileName = FSHelper.getFullPath(file);
		aceAppView = KD.singletons.appManager.get("Ace").getView();
		ace = aceAppView.aceViews[fileName].ace;
		ace.lastSavedContents = lastSavedContent;
		return ace.emit(ace.getContents() !== lastSavedContent ? "FileContentChanged" : "FileContentSynced")
	};
	LocalSyncController.prototype.removeLocalContents = function () {
		var key, _i, _len, _ref, _results;
		_ref = this.storage.getLocalStorageKeys();
		_results = [];
		for (_i = 0, _len = _ref.length; _len > _i; _i++) {
			key = _ref[_i];
			_results.push(key.indexOf("koding-editor") > -1 ? delete window.localStorage[key] : void 0)
		}
		return _results
	};
	return LocalSyncController
}(KDController);
var OnboardingViewController, __bind = function (fn, me) {
		return function () {
			return fn.apply(me, arguments)
		}
	},
	__hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
OnboardingViewController = function (_super) {
	function OnboardingViewController(options, data) {
		var _ref;
		null == options && (options = {});
		this.bindViewEvents = __bind(this.bindViewEvents, this);
		OnboardingViewController.__super__.constructor.call(this, options, data);
		_ref = this.getOptions(), this.app = _ref.app, this.slug = _ref.slug;
		this.items = this.getData().items;
		this.show(this.items.first, !0)
	}
	__extends(OnboardingViewController, _super);
	OnboardingViewController.prototype.show = function (item, setStorage) {
		var view;
		view = new OnboardingItemView({
			slug: this.slug,
			app: this.app,
			items: this.items,
			setStorage: setStorage
		}, item);
		return this.bindViewEvents(view)
	};
	OnboardingViewController.prototype.navigate = function (direction, itemData) {
		var index, item;
		index = this.items.indexOf(itemData);
		item = "next" === direction ? this.items[++index] : this.items[--index];
		return this.show(item)
	};
	OnboardingViewController.prototype.bindViewEvents = function (view) {
		view.on("NavigationRequested", function (_this) {
			return function (direction) {
				return _this.navigate(direction, view.getData())
			}
		}(this));
		return view.on("OnboardingShown", function (_this) {
			return function (slug) {
				return _this.getDelegate().emit("OnboardingShown", slug)
			}
		}(this))
	};
	return OnboardingViewController
}(KDViewController);
var OnboardingController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
OnboardingController = function (_super) {
	function OnboardingController(options, data) {
		var mainController;
		null == options && (options = {});
		OnboardingController.__super__.constructor.call(this, options, data);
		this.onboardings = {};
		mainController = KD.getSingleton("mainController");
		KD.isLoggedIn() ? this.fetchItems() : mainController.on("accountChanged.to.loggedIn", this.bound("fetchItems"));
		this.on("OnboardingShown", function (_this) {
			return function (slug) {
				return _this.appStorage.setValue(slug, !0)
			}
		}(this))
	}
	__extends(OnboardingController, _super);
	OnboardingController.prototype.fetchItems = function () {
		var query;
		this.appStorage = KD.getSingleton("appStorageController").storage("OnboardingStatus", "1.0.0");
		this.hasCookie = Cookies.get("custom-partials-preview-mode");
		query = {
			partialType: "ONBOARDING"
		};
		this.hasCookie ? query.isPreview = !0 : query.isActive = !0;
		return KD.remote.api.JCustomPartials.some(query, {}, function (_this) {
			return function (err, onboardings) {
				var appName, data, _base, _i, _len;
				for (_i = 0, _len = onboardings.length; _len > _i; _i++) {
					data = onboardings[_i];
					if (data.partial) {
						appName = data.partial.app;
						null == (_base = _this.onboardings)[appName] && (_base[appName] = []);
						_this.onboardings[appName].push(data)
					}
				}
				return _this.appStorage.fetchStorage(_this.bound("bindOnboardingEvents"))
			}
		}(this))
	};
	OnboardingController.prototype.bindOnboardingEvents = function () {
		var appManager;
		appManager = KD.getSingleton("appManager");
		return appManager.on("AppCreated", function (_this) {
			return function (app) {
				var appName;
				appName = app.getOptions().name;
				return _this.onboardings[appName] ? KD.utils.wait(3e3, function () {
					var isShown, item, onboarding, onboardings, slug, _i, _len, _ref;
					onboardings = _this.onboardings[appName];
					for (_i = 0, _len = onboardings.length; _len > _i; _i++) {
						item = onboardings[_i];
						slug = KD.utils.slugify(KD.utils.curry(appName, item.name));
						isShown = _this.appStorage.getValue(slug);
						if (!isShown || _this.hasCookie) {
							onboarding = item;
							break
						}
					}
					return (null != onboarding && null != (_ref = onboarding.partial.items) ? _ref.length : void 0) ? new OnboardingViewController({
						app: app,
						slug: slug,
						delegate: _this
					}, onboarding.partial) : void 0
				}) : void 0
			}
		}(this))
	};
	return OnboardingController
}(KDController);
var OnboardingContextMenu, OnboardingItemView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
OnboardingItemView = function (_super) {
	function OnboardingItemView(options, data) {
		var appName, e, index, itemName, length, path, _ref;
		null == options && (options = {});
		OnboardingItemView.__super__.constructor.call(this, options, data);
		data = this.getData();
		_ref = this.getOptions(), this.items = _ref.items, this.app = _ref.app;
		path = data.path;
		appName = this.app.getOptions().name;
		itemName = data.name;
		index = this.items.indexOf(data);
		length = this.items.length - 1;
		this.isLast = index === length;
		this.hasNext = !this.isLast;
		this.hasPrev = 0 !== index && this.hasNext;
		try {
			this.parentElement = eval(Encoder.htmlDecode(path));
			if (this.parentElement instanceof KDView) {
				this.createContextMenu();
				this.listenEvents()
			} else if (this.parentElement instanceof jQuery) {
				this.parentElement = this.getKDViewFromJQueryElement(this.parentElement);
				if (!this.parentElement) return;
				this.createContextMenu();
				this.listenEvents()
			} else console.warn("Target element should be an instance of KDView or jQuery", {
				appName: appName,
				itemName: itemName
			})
		} catch (_error) {
			e = _error;
			console.warn("Couldn't create onboarding item", {
				appName: appName,
				itemName: itemName,
				e: e
			})
		}
	}
	__extends(OnboardingItemView, _super);
	OnboardingItemView.prototype.createContextMenu = function () {
		this.contextMenu = new OnboardingContextMenu({
			cssClass: "onboarding-wrapper",
			sticky: !0,
			arrow: {
				placement: "top"
			},
			menuMaxWidth: 500,
			menuWidth: 500,
			delegate: this.parentElement,
			x: this.parentElement.getX() - 20,
			y: this.parentElement.getY() + 40
		}, {
			customView: this.createContentView()
		});
		return this.contextMenu.on("viewAppended", function (_this) {
			return function () {
				_this.contextMenu.once("KDObjectWillBeDestroyed", function () {
					return _this.destroy()
				});
				return KD.utils.defer(function () {
					var left;
					left = _this.parentElement.getX() - _this.contextMenu.getX() + 10;
					_this.contextMenu.arrow.setCss("left", left);
					return $("body").addClass("noscroll")
				})
			}
		}(this))
	};
	OnboardingItemView.prototype.createContentView = function () {
		var buttonsWrapper, child, closeButton, content, doneButton, item, nextButton, prevButton, stepsWrapper, title, view, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
		_ref = this.getData(), title = _ref.title, content = _ref.content;
		this.overlay = new KDSpotlightView({
			isRemovable: !1,
			delegate: this.parentElement
		});
		title = new KDCustomHTMLView({
			tagName: "h3",
			partial: title
		});
		content = new KDCustomHTMLView({
			tagName: "p",
			partial: content
		});
		buttonsWrapper = new KDCustomHTMLView({
			cssClass: "buttons"
		});
		view = new KDCustomHTMLView({
			cssClass: "onboarding-item"
		});
		closeButton = new KDCustomHTMLView({
			cssClass: "close-icon",
			click: function (_this) {
				return function () {
					return _this.emit("OnboardingCancelled")
				}
			}(this)
		});
		this.hasPrev && (prevButton = new KDButtonView({
			cssClass: "solid compact light-gray",
			title: "PREV",
			callback: function (_this) {
				return function () {
					return _this.emit("NavigationRequested", "prev")
				}
			}(this)
		}));
		this.hasNext && (nextButton = new KDButtonView({
			cssClass: "solid green compact",
			title: "NEXT",
			callback: function (_this) {
				return function () {
					return _this.emit("NavigationRequested", "next")
				}
			}(this)
		}));
		this.isLast && (doneButton = new KDButtonView({
			cssClass: "solid green compact",
			title: "DONE",
			callback: function (_this) {
				return function () {
					return _this.emit("OnboardingCompleted")
				}
			}(this)
		}));
		if (this.items.length > 1) {
			stepsWrapper = new KDCustomHTMLView({
				cssClass: "steps"
			});
			_ref1 = this.items;
			for (_i = 0, _len = _ref1.length; _len > _i; _i++) {
				item = _ref1[_i];
				stepsWrapper.addSubView(new KDCustomHTMLView({
					tagName: "span",
					cssClass: item === this.getData() ? "active" : ""
				}))
			}
		}
		_ref2 = [prevButton, nextButton, doneButton, stepsWrapper];
		for (_j = 0, _len1 = _ref2.length; _len1 > _j; _j++) {
			child = _ref2[_j];
			child && buttonsWrapper.addSubView(child)
		}
		_ref3 = [title, content, buttonsWrapper, closeButton];
		for (_k = 0, _len2 = _ref3.length; _len2 > _k; _k++) {
			child = _ref3[_k];
			child && view.addSubView(child)
		}
		return view
	};
	OnboardingItemView.prototype.getKDViewFromJQueryElement = function ($element) {
		var element, kdinstance, kdview, key, _ref;
		element = $element[0];
		kdview = null;
		_ref = KD.instances;
		for (key in _ref) {
			kdinstance = _ref[key];
			if (("function" == typeof kdinstance.getElement ? kdinstance.getElement() : void 0) === element) {
				kdview = kdinstance;
				break
			}
		}
		return kdview
	};
	OnboardingItemView.prototype.listenEvents = function () {
		var setStorage, slug, _ref;
		this.on("NavigationRequested", function (_this) {
			return function () {
				_this.destroy();
				return KD.mixpanel("Onboarding navigation, click")
			}
		}(this));
		this.on("OnboardingCompleted", function (_this) {
			return function () {
				_this.destroy();
				return KD.mixpanel("Onboarding navigation, success")
			}
		}(this));
		this.on("OnboardingCancelled", function (_this) {
			return function () {
				_this.destroy();
				return KD.mixpanel("Onboarding navigation, failure")
			}
		}(this));
		_ref = this.getOptions(), setStorage = _ref.setStorage, slug = _ref.slug;
		return setStorage ? KD.utils.defer(function (_this) {
			return function () {
				return _this.emit("OnboardingShown", slug)
			}
		}(this)) : void 0
	};
	OnboardingItemView.prototype.destroy = function () {
		var _ref;
		OnboardingItemView.__super__.destroy.apply(this, arguments);
		null != (_ref = this.overlay) && _ref.destroy();
		this.contextMenu.destroy();
		return $("body").removeClass("noscroll")
	};
	return OnboardingItemView
}(KDView);
OnboardingContextMenu = function (_super) {
	function OnboardingContextMenu() {
		return OnboardingContextMenu.__super__.constructor.apply(this, arguments)
	}
	__extends(OnboardingContextMenu, _super);
	OnboardingContextMenu.prototype.childAppended = function () {
		return KD.utils.defer(function (_this) {
			return function () {
				return _this.positionContextMenu()
			}
		}(this))
	};
	return OnboardingContextMenu
}(KDContextMenu);
var TestimonialsQuoteView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
TestimonialsQuoteView = function (_super) {
	function TestimonialsQuoteView(options) {
		null == options && (options = {});
		options.tagName = "article";
		TestimonialsQuoteView.__super__.constructor.call(this, options)
	}
	__extends(TestimonialsQuoteView, _super);
	JView.mixin(TestimonialsQuoteView.prototype);
	TestimonialsQuoteView.prototype.pistachio = function () {
		var content, name, slugifiedName, title, _ref;
		_ref = this.getOptions(), name = _ref.name, title = _ref.title, content = _ref.content;
		slugifiedName = KD.utils.slugify(name);
		return "<p>" + content + "</p>\n<div class='person'>\n  <img src='/a/images/testimonials/" + slugifiedName + ".jpg'>\n  <span class='name'>" + name + "</span>\n  <span class='title'>" + title + "</span>\n</div>"
	};
	return TestimonialsQuoteView
}(KDCustomHTMLView);
var TestimonialsView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
TestimonialsView = function (_super) {
	function TestimonialsView(options) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("testimonials", options.cssClass);
		options.tagName || (options.tagName = "section");
		options.quotesCount || (options.quotesCount = 2);
		null == options.showMoreButton && (options.showMoreButton = !0);
		TestimonialsView.__super__.constructor.call(this, options)
	}
	var quotes;
	__extends(TestimonialsView, _super);
	quotes = [{
		name: "Lisha Sterling",
		title: "Teacher",
		content: "in my classes I have used Koding plenty of times. I love that you have virtual servers available on a web interface. So that in addition to writing code, we can all go into the same command line interface to experiment with things. Super useful."
	}, {
		name: "James Doyle",
		title: "Developer",
		content: "I wanted a place with free hosting and worked like a VPS. If you have something like GoDaddy, good luck installing a Rails or Node app."
	}, {
		name: "Jordan Cauley",
		title: "Front-end Engineer",
		content: "I started working as a freelancer, using Koding on and off. What I have in Koding right now is the start of my first web app, front-end and back-end running on Node.js."
	}, {
		name: "Heidi Dong",
		title: "Student",
		content: "I installed it on Koding and it worked from there. And since Koding had Git and stuff, it was great.  It was very helpful with that contest. I really love the community on Koding."
	}, {
		name: "Gemma Lynn",
		title: "Developer",
		content: "Yeah, and I also did a bunch of Coursera courses. There was an algorithms course, an R course, and a crypto course. And I was using Koding for all of that. It\u2019s incredibly convenient."
	}, {
		name: "Eugene Esca",
		title: "Programmer",
		content: "Well, let\u2019s say we have a client, who want to see your work live, in action. Just get them on Koding and \u2018tada\u2019, they\u2019re watching you work."
	}, {
		name: "Cliff Rowley",
		title: "Developer",
		content: "But what really sold Koding for me was the social element and the banter and most importantly, the KD framework. It\u2019s genius. By offering the VM platform as a platform and allowing us to build apps around the KD framework is just a stroke of genius."
	}, {
		name: "Aydincan Ataberk",
		title: "Entrepreneur",
		content: "Koding\u2019s community is actually the most important thing about Koding. You can get help, you feel like you\u2019re in a family. It feels alive, to see the posts and feed."
	}, {
		name: "Adem Aydin",
		title: "Student",
		content: "recently I found a group of people on Koding who are interested in learning C. I thought C would be good to know for my field. So I found some pretty good people and in the next days we\u2019ll start using Koding to collaborate on our learning."
	}];
	TestimonialsView.prototype.createQuotes = function () {
		var index, randomIndexes, _results;
		randomIndexes = [];
		_results = [];
		for (; randomIndexes.length < this.getOption("quotesCount");) {
			index = Math.floor(Math.random() * quotes.length);
			if (-1 === randomIndexes.indexOf(index)) {
				randomIndexes.push(index);
				_results.push(this.innerContainer.addSubView(new TestimonialsQuoteView(quotes[index])))
			} else _results.push(void 0)
		}
		return _results
	};
	TestimonialsView.prototype.viewAppended = function () {
		this.addSubView(this.innerContainer = new KDCustomHTMLView({
			cssClass: "inner-container clearfix"
		}));
		this.innerContainer.addSubView(new KDCustomHTMLView({
			tagName: "h3",
			cssClass: "general-title",
			partial: "What did they say"
		}));
		this.innerContainer.addSubView(new KDCustomHTMLView({
			tagName: "h4",
			cssClass: "general-subtitle",
			partial: "People love Koding for a reason. Guess what that reason is?"
		}));
		this.createQuotes();
		return this.getOption("showMoreButton") ? this.innerContainer.addSubView(this.storiesButton = new CustomLinkView({
			title: "Read more user stories",
			cssClass: "border-only-green",
			href: "http://stories.koding.com",
			target: "_blank"
		})) : void 0
	};
	return TestimonialsView
}(KDView);
var ApplicationTabView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ApplicationTabView = function (_super) {
	function ApplicationTabView(options, data) {
		var appManager, focusActivePane, mainView;
		null == options && (options = {});
		null == options.resizeTabHandles && (options.resizeTabHandles = !0);
		null == options.lastTabHandleMargin && (options.lastTabHandleMargin = 80);
		null == options.sortable && (options.sortable = !0);
		null == options.closeAppWhenAllTabsClosed && (options.closeAppWhenAllTabsClosed = !0);
		null == options.enableMoveTabHandle && (options.enableMoveTabHandle = !1);
		null == options.detachPanes && (options.detachPanes = !1);
		options.cssClass = KD.utils.curry("application-tabview", options.cssClass);
		ApplicationTabView.__super__.constructor.call(this, options, data);
		appManager = KD.getSingleton("appManager");
		this.on("PaneAdded", function (_this) {
			return function (pane) {
				var plusHandle, tabHandle, tabView;
				_this.tabHandleContainer.repositionPlusHandle(_this.handles);
				tabView = _this;
				pane.on("KDTabPaneDestroy", function () {
					if (tabView.panes.length - 1 === 0) {
						options.closeAppWhenAllTabsClosed && appManager.quit(appManager.getFrontApp());
						tabView.emit("AllTabsClosed")
					}
					return tabView.tabHandleContainer.repositionPlusHandle(tabView.handles)
				});
				tabHandle = pane.tabHandle;
				plusHandle = _this.getOptions().tabHandleContainer.plusHandle;
				tabHandle.on("DragInAction", function () {
					return tabHandle.dragIsAllowed && null != plusHandle ? plusHandle.hide() : void 0
				});
				return tabHandle.on("DragFinished", function () {
					return null != plusHandle ? plusHandle.show() : void 0
				})
			}
		}(this));
		focusActivePane = function (_this) {
			return function (pane) {
				var mainView, tabView, _ref, _ref1;
				if (mainView = pane.getMainView()) {
					tabView = pane.getMainView().tabView;
					if (_this === tabView) return null != (_ref = _this.getActivePane()) && null != (_ref1 = _ref.getHandle()) ? _ref1.$().click() : void 0
				}
			}
		}(this);
		mainView = KD.getSingleton("mainViewController").getView();
		mainView.mainTabView.on("PaneDidShow", focusActivePane);
		this.on("KDObjectWillBeDestroyed", function () {
			return mainView.mainTabView.off("PaneDidShow", focusActivePane)
		})
	}
	__extends(ApplicationTabView, _super);
	return ApplicationTabView
}(KDTabView);
var ApplicationTabHandleHolder, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ApplicationTabHandleHolder = function (_super) {
	function ApplicationTabHandleHolder(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("application-tab-handle-holder", options.cssClass);
		options.bind = "mouseenter mouseleave";
		null == options.addPlusHandle && (options.addPlusHandle = !0);
		ApplicationTabHandleHolder.__super__.constructor.call(this, options, data);
		this.tabs = new KDCustomHTMLView({
			cssClass: "kdtabhandle-tabs clearfix"
		})
	}
	__extends(ApplicationTabHandleHolder, _super);
	ApplicationTabHandleHolder.prototype.viewAppended = function () {
		this.addSubView(this.tabs);
		return this.getOptions().addPlusHandle ? this.addPlusHandle() : void 0
	};
	ApplicationTabHandleHolder.prototype.addPlusHandle = function () {
		var _ref;
		null != (_ref = this.plusHandle) && _ref.destroy();
		return this.tabs.addSubView(this.plusHandle = new KDCustomHTMLView({
			cssClass: "kdtabhandle visible-tab-handle plus",
			partial: "<span class='icon'></span>",
			delegate: this,
			click: function (_this) {
				return function () {
					var _ref1;
					return null != (_ref1 = _this.getDelegate()) ? _ref1.emit("PlusHandleClicked") : void 0
				}
			}(this)
		}))
	};
	ApplicationTabHandleHolder.prototype.repositionPlusHandle = function (handles) {
		var handlesLength, _ref;
		handlesLength = handles.length;
		return handlesLength && null != (_ref = this.plusHandle) ? _ref.$().insertAfter(handles[handlesLength - 1].$()) : void 0
	};
	ApplicationTabHandleHolder.prototype.addHandle = function (handle) {
		return this.tabs.addSubView(handle)
	};
	return ApplicationTabHandleHolder
}(KDView);
var SharePopup, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
SharePopup = function (_super) {
	function SharePopup(options, data) {
		var urlInput, _base, _base1, _base2, _base3, _base4, _base5, _base6, _base7, _base8;
		null == options && (options = {});
		null == options.cssClass && (options.cssClass = "share-popup");
		null == options.shortenURL && (options.shortenURL = !0);
		null == options.url && (options.url = "");
		null == options.gplus && (options.gplus = {});
		null == (_base = options.gplus).enabled && (_base.enabled = !0);
		null == options.twitter && (options.twitter = {});
		null == (_base1 = options.twitter).enabled && (_base1.enabled = !0);
		null == (_base2 = options.twitter).text && (_base2.text = "");
		null == options.facebook && (options.facebook = {});
		null == (_base3 = options.facebook).enabled && (_base3.enabled = !0);
		null == options.linkedin && (options.linkedin = {});
		null == (_base4 = options.linkedin).enabled && (_base4.enabled = !0);
		null == (_base5 = options.linkedin).title && (_base5.title = "Koding.com");
		null == (_base6 = options.linkedin).text && (_base6.text = options.url || "The next generation development environment");
		null == options.newTab && (options.newTab = {});
		null == (_base7 = options.newTab).enabled && (_base7.enabled = !0);
		null == (_base8 = options.newTab).url && (_base8.url = options.url);
		SharePopup.__super__.constructor.call(this, options, data);
		this.urlInput = urlInput = new KDInputView({
			cssClass: "share-input",
			type: "text",
			placeholder: "building url...",
			attributes: {
				readonly: !0
			},
			width: 50
		});
		if (options.shortenURL) KD.utils.shortenUrl(options.url, function (_this) {
			return function (shorten) {
				_this.urlInput.setValue(shorten);
				return _this.urlInput.$().select()
			}
		}(this));
		else {
			urlInput.setValue(options.url);
			urlInput.$().select()
		}
		this.once("viewAppended", function (_this) {
			return function () {
				return _this.urlInput.$().select()
			}
		}(this));
		this.gPlusShareLink = this.buildGPlusShareLink();
		this.twitterShareLink = this.buildTwitterShareLink();
		this.facebookShareLink = this.buildFacebookShareLink();
		this.linkedInShareLink = this.buildLinkedInShareLink()
	}
	__extends(SharePopup, _super);
	SharePopup.prototype.buildURLInput = function () {
		var options;
		this.urlInput = new KDInputView({
			cssClass: "share-input",
			type: "text",
			placeholder: "building url...",
			attributes: {
				readonly: !0
			},
			width: 50
		});
		options = this.getOptions();
		if (options.shortenURL) return KD.utils.shortenUrl(options.url, function (_this) {
			return function (shorten) {
				_this.urlInput.setValue(shorten);
				_this.urlInput.$().select();
				return _this.urlInput
			}
		}(this));
		this.urlInput.setValue(options.url);
		this.urlInput.$().select();
		return this.urlInput
	};
	SharePopup.prototype.buildGPlusShareLink = function () {
		var link;
		if (this.getOptions().gplus.enabled) {
			link = "https://plus.google.com/share?url=" + encodeURIComponent(this.getOptions().url);
			return this.generateView(link, "gplus")
		}
		return new KDView
	};
	SharePopup.prototype.buildTwitterShareLink = function () {
		var link, shareText;
		if (this.getOptions().twitter.enabled) {
			shareText = this.getOptions().twitter.text || this.getOptions().text;
			link = "https://twitter.com/intent/tweet?text=" + encodeURIComponent(shareText) + "&via=koding&source=koding";
			return this.generateView(link, "twitter")
		}
		return new KDView
	};
	SharePopup.prototype.buildFacebookShareLink = function () {
		var link;
		if (this.getOptions().facebook.enabled) {
			link = "https://www.facebook.com/sharer/sharer.php?u=" + encodeURIComponent(this.getOptions().url);
			return this.generateView(link, "facebook")
		}
		return new KDView
	};
	SharePopup.prototype.buildLinkedInShareLink = function () {
		var link;
		if (this.getOptions().linkedin.enabled) {
			link = "http://www.linkedin.com/shareArticle?mini=true&url=" + encodeURIComponent(this.getOptions().url) + "&title=" + encodeURIComponent(this.getOptions().linkedin.title) + "&summary=" + encodeURIComponent(this.getOptions().linkedin.text) + "&source=" + location.origin;
			return this.generateView(link, "linkedin")
		}
		return new KDView
	};
	SharePopup.prototype.generateView = function (link, provider) {
		return new KDCustomHTMLView({
			tagName: "a",
			cssClass: "share-" + provider + " icon-link",
			partial: "<span class='icon'></span>",
			click: function () {
				return function (event) {
					KD.utils.stopDOMEvent(event);
					return window.open(link, "" + provider + "-share-dialog", "width=626,height=436,left=" + Math.floor(screen.width / 2 - 250) + ",top=" + Math.floor(screen.height / 2 - 175))
				}
			}(this)
		})
	};
	SharePopup.prototype.pistachio = function () {
		return "{{> this.urlInput}}\n{{> this.gPlusShareLink}}\n{{> this.linkedInShareLink}}\n{{> this.facebookShareLink}}\n{{> this.twitterShareLink}}"
	};
	return SharePopup
}(JView);
var FacebookShareLink, LinkedInShareLink, ShareLink, TwitterShareLink, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ShareLink = function (_super) {
	function ShareLink(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("share-icon " + options.provider, options.cssClass);
		options.partial = '<span class="icon"></span>';
		null == options.iconOnly && (options.iconOnly = !0);
		null == options.trackingName && (options.trackingName = "");
		ShareLink.__super__.constructor.call(this, options, data)
	}
	__extends(ShareLink, _super);
	ShareLink.prototype.click = function (event) {
		var provider, trackingName, _ref;
		KD.utils.stopDOMEvent(event);
		_ref = this.getOptions(), provider = _ref.provider, trackingName = _ref.trackingName;
		window.open(this.getUrl(), "" + provider + "-share-dialog", "width=626,height=436,left=" + Math.floor(screen.width / 2 - 250) + ",top=" + Math.floor(screen.height / 2 - 175));
		return KD.mixpanel("" + provider + " share link, click in " + trackingName, {
			user: KD.nick()
		})
	};
	return ShareLink
}(KDButtonView);
TwitterShareLink = function (_super) {
	function TwitterShareLink(options, data) {
		null == options && (options = {});
		options.provider = "twitter";
		TwitterShareLink.__super__.constructor.call(this, options, data)
	}
	__extends(TwitterShareLink, _super);
	TwitterShareLink.prototype.getUrl = function () {
		var text, url;
		url = this.getOptions().url;
		text = "Koding is giving away 100TB this week - my link gets you a 5GB VM! " + url + " @koding is AWESOME! #Crazy100TBWeek";
		return "https://twitter.com/intent/tweet?text=" + encodeURIComponent(text) + "&source=koding"
	};
	return TwitterShareLink
}(ShareLink);
FacebookShareLink = function (_super) {
	function FacebookShareLink(options, data) {
		null == options && (options = {});
		options.provider = "facebook";
		FacebookShareLink.__super__.constructor.call(this, options, data)
	}
	__extends(FacebookShareLink, _super);
	FacebookShareLink.prototype.getUrl = function () {
		return "https://www.facebook.com/sharer/sharer.php?u=" + encodeURIComponent(this.getOptions().url)
	};
	return FacebookShareLink
}(ShareLink);
LinkedInShareLink = function (_super) {
	function LinkedInShareLink(options, data) {
		null == options && (options = {});
		options.provider = "linkedin";
		LinkedInShareLink.__super__.constructor.call(this, options, data)
	}
	__extends(LinkedInShareLink, _super);
	LinkedInShareLink.prototype.getUrl = function () {
		var text, url;
		url = this.getOptions().url;
		text = "Koding is giving away 100TB this week - my link gets you a 5GB VM! " + url + " @koding is AWESOME! #Crazy100TBWeek";
		return "http://www.linkedin.com/shareArticle?mini=true&url=" + encodeURIComponent(url) + "&title=" + encodeURIComponent(this.title) + "&summary=" + encodeURIComponent(text) + "&source=" + location.origin
	};
	LinkedInShareLink.prototype.title = "Join me @koding!";
	return LinkedInShareLink
}(ShareLink);
var LinkView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LinkView = function (_super) {
	function LinkView(options, data) {
		null == options && (options = {});
		options.tagName || (options.tagName = "a");
		data || (data = {
			fake: !0
		});
		data = this._addDefaultProfile(data);
		LinkView.__super__.constructor.call(this, options, data);
		data.fake && options.origin && this.loadFromOrigin(options.origin);
		KD.getSingleton("linkController").registerLink(this)
	}
	__extends(LinkView, _super);
	JView.mixin(LinkView.prototype);
	LinkView.prototype._addDefaultProfile = function (data) {
		var _base, _base1;
		data.profile || (data.profile = {});
		null == (_base = data.profile).firstName && (_base.firstName = "a koding");
		null == (_base1 = data.profile).lastName && (_base1.lastName = "user");
		return data
	};
	LinkView.prototype.click = function (event) {
		this.emit("LinkClicked");
		return this.utils.stopDOMEvent(event)
	};
	LinkView.prototype.destroy = function () {
		LinkView.__super__.destroy.apply(this, arguments);
		return KD.getSingleton("linkController").unregisterLink(this)
	};
	LinkView.prototype.loadFromOrigin = function (origin) {
		var callback, kallback;
		callback = function (_this) {
			return function (data) {
				data = _this._addDefaultProfile(data);
				_this.setData(data);
				"function" == typeof data.on && data.on("update", _this.bound("render"));
				_this.render();
				return _this.emit("OriginLoadComplete", data)
			}
		}(this);
		kallback = function (err, originModel) {
			Array.isArray(originModel) && (originModel = originModel.first);
			return originModel ? callback(originModel) : warn("couldn't get the model via cacheable", origin)
		};
		return origin.constructorName ? KD.remote.cacheable(origin.constructorName, origin.id, kallback) : "string" == typeof origin ? KD.remote.cacheable(origin, kallback) : callback(origin)
	};
	return LinkView
}(KDCustomHTMLView);
var LinkMenuItemView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LinkMenuItemView = function (_super) {
	function LinkMenuItemView(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("links-menu-item", options.cssClass);
		LinkMenuItemView.__super__.constructor.call(this, options, data)
	}
	__extends(LinkMenuItemView, _super);
	LinkMenuItemView.prototype.pistachio = function () {
		var link, title, _ref;
		_ref = this.getData(), title = _ref.title, link = _ref.link;
		return '<a href="' + link + '" target="_blank"><span>' + title + "</span></a>"
	};
	return LinkMenuItemView
}(JView);
var CustomLinkView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
CustomLinkView = function (_super) {
	function CustomLinkView(options, data) {
		var _base, _base1;
		null == options && (options = {});
		null == data && (data = {});
		options.tagName || (options.tagName = "a");
		options.cssClass = KD.utils.curry("custom-link-view", options.cssClass);
		null == data.title && (data.title = options.title);
		null == options.attributes && (options.attributes = {});
		null != options.href && (options.attributes.href = options.href);
		null != options.target && (options.attributes.target = options.target);
		if (options.icon) {
			options.icon || (options.icon = {});
			(_base = options.icon).placement || (_base.placement = "left");
			(_base1 = options.icon).cssClass || (_base1.cssClass = "")
		}
		CustomLinkView.__super__.constructor.call(this, options, data);
		if (options.icon) {
			options.icon.tagName = "span";
			options.icon.cssClass = KD.utils.curry("icon", options.icon.cssClass);
			this.icon = new KDCustomHTMLView(options.icon)
		}
	}
	__extends(CustomLinkView, _super);
	JView.mixin(CustomLinkView.prototype);
	CustomLinkView.prototype.pistachio = function () {
		var data, options, tmpl;
		options = this.getOptions();
		data = this.getData();
		null == data.title && (data.title = options.attributes.href);
		tmpl = "{{> this.icon}}";
		options.icon && data.title ? "left" === options.icon.placement ? tmpl += "{span.title{#(title)}}" : tmpl = "{span.title{#(title)}}" + tmpl : !options.icon && data.title && (tmpl = "{span.title{#(title)}}");
		return tmpl
	};
	return CustomLinkView
}(KDCustomHTMLView);
var LinkGroup, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LinkGroup = function (_super) {
	function LinkGroup(options, data) {
		var _ref;
		null == options && (options = {});
		options.tagName = "div";
		options.cssClass = "link-group";
		options.itemClass || (options.itemClass = ProfileLinkView);
		options.itemOptions || (options.itemOptions = {});
		options.itemsToShow || (options.itemsToShow = 3);
		options.totalCount || (options.totalCount = (null != data ? data.length : void 0) || (null != (_ref = options.group) ? _ref.length : void 0) || 0);
		options.hasMore = options.totalCount > options.itemsToShow;
		null == options.separator && (options.separator = ", ");
		options.suffix || (options.suffix = "");
		LinkGroup.__super__.constructor.call(this, options, data);
		this.getData() ? this.createParticipantSubviews() : options.group && this.loadFromOrigins(options.group)
	}
	__extends(LinkGroup, _super);
	JView.mixin(LinkGroup.prototype);
	LinkGroup.prototype.loadFromOrigins = function (group) {
		var callback, lastFour, _ref;
		callback = function (_this) {
			return function (data) {
				_this.setData(data);
				_this.createParticipantSubviews();
				return _this.render()
			}
		}(this);
		if (null != (_ref = group[0]) ? _ref.constructorName : void 0) {
			lastFour = group.slice(-4);
			return KD.remote.cacheable(lastFour, function () {
				return function (err, bucketContents) {
					return err ? warn(err) : callback(bucketContents)
				}
			}(this))
		}
		return callback(group)
	};
	LinkGroup.prototype.createParticipantSubviews = function () {
		var index, itemClass, itemOptions, participant, participants, _i, _len, _ref, _ref1, _ref2;
		_ref = this.getOptions(), itemClass = _ref.itemClass, itemOptions = _ref.itemOptions;
		participants = this.getData();
		index = 0;
		_ref1 = participants.slice(0).reverse();
		for (_i = 0, _len = _ref1.length; _len > _i; _i++) {
			participant = _ref1[_i];
			if ("ObjectRef" === (null != participant && null != (_ref2 = participant.bongo_) ? _ref2.constructorName : void 0)) {
				itemOptions.origin = participant;
				this["participant" + index] = new itemClass(itemOptions)
			} else this["participant" + index] = new itemClass(itemOptions, participant);
			index++
		}
		if (this.participant0) {
			this.setTemplate(this.pistachio());
			return this.template.update()
		}
	};
	LinkGroup.prototype.viewAppended = function () {
		return LinkGroup.__super__.viewAppended.call(this)
	};
	LinkGroup.prototype.createMoreLink = function () {
		var group, totalCount, _ref;
		this.more && this.more.destroy();
		_ref = this.getOptions(), totalCount = _ref.totalCount, group = _ref.group;
		return this.more = new KDCustomHTMLView({
			tagName: "a",
			cssClass: "more",
			partial: "" + (totalCount - 3) + " more",
			attributes: {
				href: "#",
				title: "Click to view..."
			},
			click: function (_this) {
				return function () {
					return new ShowMoreDataModalView({
						group: group
					}, _this.getData())
				}
			}(this)
		})
	};
	LinkGroup.prototype.pistachio = function () {
		var count, group, hasMore, separator, suffix, totalCount, _ref;
		_ref = this.getOptions(), suffix = _ref.suffix, hasMore = _ref.hasMore, totalCount = _ref.totalCount, group = _ref.group, separator = _ref.separator;
		this.createMoreLink();
		count = totalCount;
		4 !== count || this.participant3 || (count = 1e3);
		switch (count) {
		case 0:
			return "";
		case 1:
			return "{{> this.participant0}}" + suffix;
		case 2:
			return "{{> this.participant0}} and {{> this.participant1}}" + suffix;
		case 3:
			return "{{> this.participant0}}" + separator + "{{> this.participant1}} and {{> this.participant2}}" + suffix;
		case 4:
			return "{{> this.participant0}}" + separator + "{{> this.participant1}}" + separator + "{{> this.participant2}} and {{> this.participant3}}" + suffix;
		default:
			return "{{> this.participant0}}" + separator + "{{> this.participant1}}" + separator + "{{> this.participant2}} and {{> this.more}}" + suffix
		}
	};
	LinkGroup.prototype.render = function () {
		return this.createParticipantSubviews()
	};
	return LinkGroup
}(KDCustomHTMLView);
var ProfileLinkView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ProfileLinkView = function (_super) {
	function ProfileLinkView(options, data) {
		null == options && (options = {});
		null == options.noTooltip && (options.noTooltip = !0);
		options.noTooltip || (this.avatarPreview = {
			constructorName: AvatarTooltipView,
			options: {
				delegate: this,
				origin: options.origin
			},
			data: data
		});
		this.avatarPreview && (options.tooltip || (options.tooltip = {
			view: options.noTooltip ? null : this.avatarPreview,
			cssClass: "avatar-tooltip",
			animate: !0,
			placement: "top",
			direction: "left"
		}));
		ProfileLinkView.__super__.constructor.call(this, options, data);
		null != this.avatarPreview && this.on("TooltipReady", function (_this) {
			return function () {
				return _this.utils.defer(function () {
					var _ref, _ref1, _ref2;
					return null != (null != (_ref = _this.getData()) ? _ref.profile.nickname : void 0) && null != (_ref1 = _this.tooltip) && null != (_ref2 = _ref1.getView()) ? _ref2.updateData(_this.getData()) : void 0
				})
			}
		}(this));
		this.setClass("profile")
	}
	__extends(ProfileLinkView, _super);
	JView.mixin(ProfileLinkView.prototype);
	ProfileLinkView.prototype.render = function (fields) {
		var href, nickname, slug, _ref, _ref1;
		nickname = null != (_ref = this.getData().profile) ? _ref.nickname : void 0;
		slug = (null != (_ref1 = KD.getGroup()) ? _ref1.slug : void 0) || "koding";
		href = "koding" === slug ? "/" + nickname : "/" + slug + "/" + nickname;
		nickname && this.setAttribute("href", href);
		return ProfileLinkView.__super__.render.call(this, fields)
	};
	ProfileLinkView.prototype.pistachio = function () {
		var profile;
		profile = this.getData().profile;
		return JView.prototype.pistachio.call(this, "" === profile.firstName && "" === profile.lastName ? "{{#(profile.nickname)}}" : "{{#(profile.firstName) + ' ' + #(profile.lastName)}}")
	};
	return ProfileLinkView
}(LinkView);
var ProfileTextView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ProfileTextView = function (_super) {
	function ProfileTextView(options) {
		options.tagName || (options.tagName = "span");
		ProfileTextView.__super__.constructor.apply(this, arguments)
	}
	__extends(ProfileTextView, _super);
	ProfileTextView.prototype.click = function () {
		return !0
	};
	return ProfileTextView
}(ProfileLinkView);
var ProfileTextGroup, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ProfileTextGroup = function (_super) {
	function ProfileTextGroup(options) {
		null == options && (options = {});
		options.tagName || (options.tagName = "span");
		options.cssClass || (options.cssClass = "link-group");
		options.itemClass || (options.itemClass = ProfileTextView);
		ProfileTextGroup.__super__.constructor.call(this, options)
	}
	__extends(ProfileTextGroup, _super);
	ProfileTextGroup.prototype.click = function () {
		return !0
	};
	return ProfileTextGroup
}(LinkGroup);
var TagLinkView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
TagLinkView = function (_super) {
	function TagLinkView(options, data) {
		null == options && (options = {});
		null == options.expandable && (options.expandable = !0);
		null == options.clickable && (options.clickable = !0);
		!options.expandable && (null != data ? data.title.length : void 0) > 16 && (options.tooltip = {
			title: data.title,
			placement: "above",
			delayIn: 120
		});
		TagLinkView.__super__.constructor.call(this, options, data);
		"function" == typeof data.on && data.on("TagIsDeleted", function (_this) {
			return function () {
				return _this.destroy()
			}
		}(this));
		this.setClass("ttag expandable");
		options.expandable || this.unsetClass("expandable");
		this.on("viewAppended", function (_this) {
			return function () {
				var _ref;
				return null != (_ref = _this.tooltip) ? _ref.setPosition() : void 0
			}
		}(this))
	}
	__extends(TagLinkView, _super);
	JView.mixin(TagLinkView.prototype);
	TagLinkView.prototype.pistachio = function () {
		return JView.prototype.pistachio.call(this, "{{#(title)}}")
	};
	return TagLinkView
}(LinkView);
var ActivityLinkView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ActivityLinkView = function (_super) {
	function ActivityLinkView(options, data) {
		null == options && (options = {});
		options.tagName || (options.tagName = "a");
		ActivityLinkView.__super__.constructor.call(this, options, data)
	}
	__extends(ActivityLinkView, _super);
	ActivityLinkView.prototype.destroy = function () {
		ActivityLinkView.__super__.destroy.apply(this, arguments);
		return KD.getSingleton("linkController").unregisterLink(this)
	};
	ActivityLinkView.prototype.formatContent = function (str) {
		null == str && (str = "");
		str = Encoder.htmlEncode(str);
		str = this.utils.expandTokens(str, this.getData());
		return str
	};
	ActivityLinkView.prototype.pistachio = function () {
		var body, group, groupPath, slug, _ref;
		_ref = this.getData(), body = _ref.body, slug = _ref.slug, group = _ref.group;
		groupPath = "koding" === group ? "" : "/" + group;
		return '<a href="' + groupPath + "/Activity/" + slug + '">{{this.formatContent(#(body))}}</a>'
	};
	return ActivityLinkView
}(JView);
var AppLinkView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AppLinkView = function (_super) {
	function AppLinkView(options, data) {
		null == options && (options = {});
		options.cssClass = "app";
		AppLinkView.__super__.constructor.call(this, options, data);
		this.on("OriginLoadComplete", function (_this) {
			return function (data) {
				log(data);
				_this.setTooltip({
					title: data.body,
					placement: "above",
					delayIn: 120,
					offset: 1
				});
				return "function" == typeof data.on ? data.on("AppIsDeleted", function () {
					return _this.destroy()
				}) : void 0
			}
		}(this))
	}
	__extends(AppLinkView, _super);
	AppLinkView.prototype.pistachio = function () {
		return AppLinkView.__super__.pistachio.call(this, "{{#(title)}}")
	};
	AppLinkView.prototype.click = function () {
		var app;
		app = this.getData();
		return KD.getSingleton("appManager").tell("Apps", "createContentDisplay", app)
	};
	return AppLinkView
}(LinkView);
var ActivityChildViewTagGroup, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ActivityChildViewTagGroup = function (_super) {
	function ActivityChildViewTagGroup() {
		return ActivityChildViewTagGroup.__super__.constructor.apply(this, arguments)
	}
	__extends(ActivityChildViewTagGroup, _super);
	ActivityChildViewTagGroup.prototype.pistachio = function () {
		var group, hasMore, participants, totalCount, _ref;
		participants = this.getData();
		_ref = this.getOptions(), hasMore = _ref.hasMore, totalCount = _ref.totalCount, group = _ref.group;
		this.createMoreLink();
		switch (totalCount) {
		case 0:
			return "";
		case 1:
			return "in {{> this.participant0}}";
		case 2:
			return "in {{> this.participant0}}{{> this.participant1}}";
		case 3:
			return "in {{> this.participant0}}{{> this.participant1}}{{> this.participant2}}";
		case 4:
			return "in {{> this.participant0}}{{> this.participant1}}{{> this.participant2}}{{> this.participant3}}";
		default:
			return "in {{> this.participant0}}{{> this.participant1}}{{> this.participant2}}and {{> this.more}}"
		}
	};
	return ActivityChildViewTagGroup
}(LinkGroup);
var AutoCompleteProfileTextView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AutoCompleteProfileTextView = function (_super) {
	function AutoCompleteProfileTextView() {
		return AutoCompleteProfileTextView.__super__.constructor.apply(this, arguments)
	}
	__extends(AutoCompleteProfileTextView, _super);
	AutoCompleteProfileTextView.prototype.highlightMatch = function (str, isNick) {
		var userInput;
		null == isNick && (isNick = !1);
		userInput = this.getOptions().userInput;
		return userInput ? str ? str = str.replace(RegExp(userInput, "gi"), function (_this) {
			return function (match) {
				isNick && _this.setClass("nick-matches");
				return "<b>" + match + "</b>"
			}
		}(this)) : void 0 : str
	};
	AutoCompleteProfileTextView.prototype.pistachio = function () {
		var name;
		name = KD.utils.getFullnameFromAccount(this.getData());
		return "" + this.highlightMatch(name) + (this.getOptions().shouldShowNick ? "<span class='nick'>\n  (@{{this.highlightMatch(#(profile.nickname), true)}})\n</span>" : "")
	};
	return AutoCompleteProfileTextView
}(ProfileTextView);
var GroupLinkView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
GroupLinkView = function (_super) {
	function GroupLinkView(options, data) {
		null == options && (options = {});
		GroupLinkView.__super__.constructor.call(this, options, data);
		this.setClass("profile")
	}
	__extends(GroupLinkView, _super);
	GroupLinkView.prototype.render = function () {
		var slug;
		slug = this.getData().slug;
		this.setAttribute("href", "/" + slug);
		this.setAttribute("target", "_blank");
		return GroupLinkView.__super__.render.apply(this, arguments)
	};
	GroupLinkView.prototype.pistachio = function () {
		return GroupLinkView.__super__.pistachio.call(this, "{{#(title)}}")
	};
	GroupLinkView.prototype.click = function () {};
	return GroupLinkView
}(LinkView);
var SplitView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
SplitView = function (_super) {
	function SplitView() {
		return SplitView.__super__.constructor.apply(this, arguments)
	}
	__extends(SplitView, _super);
	SplitView.prototype._windowDidResize = function () {
		return this.utils.wait(300, function (_this) {
			return function () {
				_this._setSize(_this._getParentSize());
				_this._resizePanels();
				_this._repositionPanels();
				_this._setPanelPositions();
				return _this.getOptions().resizable ? _this._repositionResizers() : void 0
			}
		}(this))
	};
	return SplitView
}(KDSplitView);
var NominateModal, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NominateModal = function (_super) {
	function NominateModal(options, data) {
		null == options && (options = {});
		options.cssClass = "nominate-modal";
		options.width = 400;
		null == options.overlay && (options.overlay = !0);
		NominateModal.__super__.constructor.call(this, options, data)
	}
	__extends(NominateModal, _super);
	NominateModal.prototype.viewAppended = function () {
		this.unsetClass("kdmodal");
		return this.addSubView(new KDCustomHTMLView({
			partial: '<div class="logo"></div>\n<div class="header"></div>\n\n<h2>\n  Nominate Koding for\n</h2>\n<h1>\n  Best New Startup 2013\n</h1>\n\n<p>\n  The\n  <a href="http://techcrunch.com/events/7th-annual-crunchies-awards/" target="_blank">7th Annual Crunchies Awards</a> are here and we at Koding\n  would like to humbly ask for your nomination for\n  Best Startup 2013.\n</p>\n\n<p>\n  We are eternally grateful for your support.\n</p>\n\n<a href="http://crunchies2013.techcrunch.com/nominated/?MTk6S29kaW5n" target="_blank">\n  <div class="button">\n    Nominate Koding!\n  </div>\n</a>'
		}))
	};
	return NominateModal
}(KDModalView);
var SlidingSplit, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
SlidingSplit = function (_super) {
	function SlidingSplit() {
		return SlidingSplit.__super__.constructor.apply(this, arguments)
	}
	__extends(SlidingSplit, _super);
	SlidingSplit.prototype.viewAppended = function () {
		this.scrollContainer = this.getOptions().scrollContainer || this.parent;
		return SlidingSplit.__super__.viewAppended.apply(this, arguments)
	};
	SlidingSplit.prototype.splitPanel = function (index) {
		index || (index = this.getPanelIndex(this.focusedPanel));
		this.setFocusedPanel(SlidingSplit.__super__.splitPanel.call(this, index));
		this._resizePanels();
		this._repositionPanels();
		return this.getOptions().resizable ? this._repositionResizers() : void 0
	};
	SlidingSplit.prototype.removePanel = function () {
		if (SlidingSplit.__super__.removePanel.apply(this, arguments)) {
			this._resizePanels();
			this._repositionPanels();
			if (this.getOptions().resizable) return this._repositionResizers()
		}
	};
	SlidingSplit.prototype.setFocusedPanel = function (panel) {
		var p, _i, _len, _ref;
		if (panel) {
			this.focusedPanel = panel;
			_ref = this.panels;
			for (_i = 0, _len = _ref.length; _len > _i; _i++) {
				p = _ref[_i];
				p.unsetClass("focused")
			}
			panel.setClass("focused");
			this.scrollToFocusedPanel();
			this.setKeyView();
			return this.emit("PanelIsFocused", panel)
		}
	};
	SlidingSplit.prototype.focusNextPanel = function () {
		var focusedIndex;
		focusedIndex = this.getPanelIndex(this.focusedPanel);
		return focusedIndex < this.panels.length - 1 ? this.setFocusedPanel(this.panels[focusedIndex + 1]) : void 0
	};
	SlidingSplit.prototype.focusPrevPanel = function () {
		var focusedIndex;
		focusedIndex = this.getPanelIndex(this.focusedPanel);
		return focusedIndex > 0 ? this.setFocusedPanel(this.panels[focusedIndex - 1]) : void 0
	};
	SlidingSplit.prototype.focusByIndex = function () {
		return this.setFocusedPanel(this.panels[i])
	};
	SlidingSplit.prototype.scrollToFocusedPanel = function () {
		var container, duration, edge1, edge2, offset1, offset2, options1, options2, panel;
		panel = this.focusedPanel;
		container = this.scrollContainer;
		duration = this.getOptions().duration || 150;
		offset1 = panel._getOffset();
		offset2 = panel._getOffset() + panel._getSize();
		if (this.isVertical()) {
			edge1 = container.getScrollLeft();
			edge2 = edge1 + container.getWidth() - 20;
			options1 = {
				left: offset1 - 2 * panel._getSize(),
				duration: duration
			};
			options2 = {
				left: offset1,
				duration: duration
			}
		} else {
			edge1 = container.getScrollTop();
			edge2 = edge1 + container.getHeight() - 20;
			options1 = {
				top: offset1 - 2 * panel._getSize(),
				duration: duration
			};
			options2 = {
				top: offset1,
				duration: duration
			}
		} if (offset1 > edge1 && edge2 > offset1) {
			if (offset2 > edge2) return container.scrollTo(options1)
		} else {
			edge1 > offset1 && container.scrollTo(options2);
			if (offset1 > edge2) return container.scrollTo(options1)
		}
	};
	SlidingSplit.prototype.keyDown = function (e) {
		var focusedIndex, i, _ref, _ref1;
		e.preventDefault();
		e.stopPropagation();
		focusedIndex = this.getPanelIndex(this.focusedPanel);
		if (e.altKey && (37 === (_ref = e.which) || 39 === _ref)) {
			this.splitPanel(focusedIndex);
			return !1
		}
		if (27 === e.which && this.panels.length > 1) {
			this.removePanel(focusedIndex);
			this.setFocusedPanel(this.panels[focusedIndex - 1] ? this.panels[focusedIndex - 1] : this.panels[0]);
			return !1
		}
		if (e.metaKey) switch (e.which) {
		case 37:
			this.focusPrevPanel();
			break;
		case 39:
			this.focusNextPanel();
			break;
		default:
			0 <= (_ref1 = i = e.which - 49) && 10 > _ref1 && this.focusByIndex(i)
		}
		return !1
	};
	SlidingSplit.prototype._createPanel = function () {
		var panel;
		panel = SlidingSplit.__super__._createPanel.apply(this, arguments);
		panel.on("click", function (_this) {
			return function () {
				return _this.setFocusedPanel(panel)
			}
		}(this));
		return panel
	};
	SlidingSplit.prototype._resizeUponPanelCount = function () {
		var i, l, parentSize, sizeArr;
		i = 0;
		sizeArr = [];
		parentSize = this._getParentSize();
		switch (l = this.panels.length) {
		case 1:
		case 2:
		case 3:
			for (; l > i;) {
				sizeArr.push(parentSize / l);
				i++
			}
			this._setSize(parentSize);
			break;
		default:
			for (; l > i;) {
				sizeArr.push(parentSize / 3);
				i++
			}
			this._setSize(parentSize + (l - 3) / 3 * parentSize)
		}
		return this.sizes = sizeArr
	};
	SlidingSplit.prototype._resizePanels = function () {
		this._resizeUponPanelCount();
		this.getOptions().sizes = this.sizes.slice();
		return SlidingSplit.__super__._resizePanels.apply(this, arguments)
	};
	SlidingSplit.prototype._windowDidResize = function () {
		return this.utils.wait(300, function (_this) {
			return function () {
				_this._resizePanels();
				_this._repositionPanels();
				return _this.getOptions().resizable ? _this._repositionResizers() : void 0
			}
		}(this))
	};
	return SlidingSplit
}(KDSplitView);
var BidirectionalNavigation, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
BidirectionalNavigation = function (_super) {
	function BidirectionalNavigation() {
		return BidirectionalNavigation.__super__.constructor.apply(this, arguments)
	}
	__extends(BidirectionalNavigation, _super);
	BidirectionalNavigation.prototype.viewAppended = function () {
		this.setClass("navigation");
		this.addSubView(this.createButton("Back"));
		return this.addSubView(this.createButton("Next"))
	};
	BidirectionalNavigation.prototype.createButton = function (action) {
		return new KDButtonView({
			cssClass: action.toLowerCase(),
			title: action,
			callback: function (_this) {
				return function () {
					return _this.emit(action)
				}
			}(this)
		})
	};
	return BidirectionalNavigation
}(KDView);
var KodingSwitch, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
KodingSwitch = function (_super) {
	function KodingSwitch(options, data) {
		null == options && (options = {});
		options.labels || (options.labels = ["", ""]);
		null == options.defaultValue && (options.defaultValue = !1);
		KodingSwitch.__super__.constructor.call(this, options, data)
	}
	__extends(KodingSwitch, _super);
	KodingSwitch.prototype.setDomElement = function (cssClass) {
		return this.domElement = $("<div class='kdinput koding-on-off off " + cssClass + "'><a href='#' class='knob' title='turn on'></a></div>")
	};
	KodingSwitch.prototype.mouseDown = function () {
		return this.getOption("disabled") ? void 0 : this.setValue(this.getValue() === !0 ? !1 : !0)
	};
	KodingSwitch.prototype.setOff = function (wCallback) {
		null == wCallback && (wCallback = !0);
		if (this.getValue() || !wCallback) {
			this.$("input").attr("checked", !1);
			this.unsetClass("on");
			this.setClass("off");
			return wCallback ? this.switchStateChanged() : void 0
		}
	};
	KodingSwitch.prototype.setOn = function (wCallback) {
		null == wCallback && (wCallback = !0);
		if (!this.getValue() || !wCallback) {
			this.$("input").attr("checked", !0);
			this.unsetClass("off");
			this.setClass("on");
			return wCallback ? this.switchStateChanged() : void 0
		}
	};
	return KodingSwitch
}(KDOnOffSwitch);
var AnimatedModalView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AnimatedModalView = function (_super) {
	function AnimatedModalView(options, data) {
		var closeButton;
		null == options && (options = {});
		options.cssClass = KD.utils.curry("animated-modalview", options.cssClass);
		AnimatedModalView.__super__.constructor.call(this, options, data);
		this.addSubView(closeButton = new KDCustomHTMLView({
			partial: "<span class='close-icon closeModal' title='Close [ESC]'></span>",
			click: this.bound("destroy")
		}));
		options.overlay && this.putOverlay();
		this.setMagic(0);
		this.appendToDomBody()
	}
	__extends(AnimatedModalView, _super);
	AnimatedModalView.prototype.keyUp = function (event) {
		27 === event.which && this.destroy();
		return event
	};
	AnimatedModalView.prototype.putOverlay = function () {
		var removable;
		removable = this.getOption("overlayClick");
		this.overlay = new KDOverlayView({
			isRemovable: removable
		});
		if (removable) {
			this.overlay.on("OverlayWillBeRemoved", this.bound("destroy"));
			return $("body").addClass("noscroll")
		}
	};
	AnimatedModalView.prototype.viewAppended = function () {
		this.listenWindowResize();
		this.setMagic(1);
		return KD.utils.defer(this.bound("setKeyView"))
	};
	AnimatedModalView.prototype.setMagic = function (scale) {
		var css, h, height, prop, props, w, width, x, y, _base, _i, _j, _len, _len1, _ref, _wind;
		null == scale && (scale = 1);
		_wind = $(window);
		height = _wind.height();
		width = _wind.width();
		_ref = ("function" == typeof (_base = this.getDelegate()).getBounds ? _base.getBounds() : void 0) || {
			x: 1,
			y: 1,
			w: 1,
			h: 1
		}, x = _ref.x, y = _ref.y, w = _ref.w, h = _ref.h;
		css = {};
		props = ["webkitTransform", "MozTransform", "transform"];
		for (_i = 0, _len = props.length; _len > _i; _i++) {
			prop = props[_i];
			css[prop] = "scale(" + scale + ")\ntranslate(" + Math.floor(width / 2 - 320) + "px,\n          " + Math.floor(y + (height / 2 - 240)) + "px)"
		}
		props = ["webkitTransformOrigin", "MozTransformOrigin", "transformOrigin"];
		for (_j = 0, _len1 = props.length; _len1 > _j; _j++) {
			prop = props[_j];
			css[prop] = "" + (x + w / 3) + "px " + (y + h / 3) + "px"
		}
		return this.setStyle(css)
	};
	AnimatedModalView.prototype._windowDidResize = function () {
		this.setClass("inresize");
		this.setMagic();
		return KD.utils.wait(400, function (_this) {
			return function () {
				return _this.unsetClass("inresize")
			}
		}(this))
	};
	AnimatedModalView.prototype.destroy = function () {
		$("body").removeClass("noscroll");
		this.setMagic(0);
		return KD.utils.wait(500, function (_this) {
			return function () {
				_this.overlay.destroy();
				return KDModalView.prototype.destroy.call(_this)
			}
		}(this))
	};
	return AnimatedModalView
}(KDView);
var FooterView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
FooterView = function (_super) {
	function FooterView(options, data) {
		null == options && (options = {});
		options.tagName = "footer";
		options.cssClass = "main-footer";
		FooterView.__super__.constructor.call(this, options, data)
	}
	__extends(FooterView, _super);
	FooterView.prototype.pistachio = function () {
		return '<div class="inner-container clearfix">\n  <article class="footer-block about-koding">\n    <h5>ABOUT KODING</h5>\n    <p>Koding is a developer community and cloud development environment where developers come together and code in the browser \u2013 with a real development server to run their code. Developers can work, collaborate, write and run apps without jumping</p>\n    <a href="/About">More about Koding</a>\n  </article>\n\n  <nav class="footer-block">\n    <h5>COMPANY</h5>\n    <a href="http://learn.koding.com" target="_blank">KODING UNIVERSITY</a>\n    <a href="/About">JOBS</a>\n    <a href="/tos.html" target="_blank">TERMS AND CONDITIONS</a>\n    <a href="/privacy.html" target="_blank">PRIVACY POLICY</a>\n    <a href="mailto:hello@koding.com" target=\'_self\'>CONTACT US</a>\n    <a href="http://status.koding.com" target="_blank">STATUS</a>\n  </nav>\n\n  <nav class="footer-block">\n    <h5>COMMUNITY</h5>\n    <a href=\'/Activity\'>ACTIVITY</a>\n    <a href=\'http://blog.koding.com\'>KODING BLOG</a>\n    <a href=\'https://www.facebook.com/kodingcom/events\'>MEETUPS</a>\n    <a href=\'http://stories.koding.com\'>TESTIMONIALS</a>\n    <a href=\'https://koding-cdn.s3.amazonaws.com/brand/koding-logo.pdf\'>BRAND GUIDELINES</a>\n    <a href=\'/copyright.html\' target=\'_blank\'>COPYRIGHT/DMCA GUIDELINES</a>\n    <a href=\'/acceptable.html\' target=\'_blank\'>ACCEPTABLE USER POLICY</a>\n  </nav>\n\n  <nav class="footer-block blog">\n    <h5>KODING BLOG</h5>\n    <a href="http://blog.koding.com/2014/03/announcing-devtools-now-everyone-can-make-koding-apps/">Now Everyone Can Make Koding Apps!</a>\n    <a href="http://blog.koding.com/2014/03/you-ask-we-do-were-extending-crazy250tbweek-with-another-week-and-250tb-enjoy/">You ask, we do! We\u2019re extending #Crazy250TBWeek with another week and +250TB \u2013 Enjoy :)</a>\n    <a href="http://blog.koding.com/2014/02/use-your-own-domain-with-koding-for-free/">Use your own domain with Koding! For free!</a>\n    <a href="http://blog.koding.com/2014/02/groups-and-pricing-deployed/">Groups and Pricing \u2013 deployed!</a>\n    <a href="http://blog.koding.com">Other posts...</a>\n  </nav>\n\n  <cite></cite>\n\n  <address>' + (new Date).getFullYear() + ' Â© Koding, Inc. 358 Brannan Street, San Francisco, CA, 94107</address>\n\n  <div class="social-links">\n    <a href="http://twitter.com/koding">TWITTER</a> Â· <a href="http://facebook.com/kodingcom">FACEBOOK</a>\n  </div>\n</div>'
	};
	return FooterView
}(JView);
var TokenView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
TokenView = function (_super) {
	function TokenView(options, data) {
		null == options && (options = {});
		options.tagName || (options.tagName = "span");
		options.cssClass = KD.utils.curry("token", options.cssClass);
		options.attributes || (options.attributes = {});
		options.attributes.contenteditable = !1;
		options.itemClass || (options.itemClass = KDCustomHTMLView);
		options.type || (options.type = "generic");
		TokenView.__super__.constructor.call(this, options, data);
		this.item = new options.itemClass({}, data)
	}
	__extends(TokenView, _super);
	TokenView.prototype.getKey = function () {
		return this.getData().getId()
	};
	TokenView.prototype.getIdentity = function () {
		var data;
		data = this.getData();
		return "" + data.bongo_.constructorName + ":" + data.getId() + ":" + data.title
	};
	TokenView.prototype.encodeValue = function () {
		var data, prefix;
		if (!(data = this.getData())) return "";
		prefix = this.getOptions().prefix;
		return "|" + prefix + ":" + this.getIdentity() + "|"
	};
	TokenView.prototype.pistachio = function () {
		return "{{> this.item}}"
	};
	return TokenView
}(JView);
var SuggestedTokenView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
SuggestedTokenView = function (_super) {
	function SuggestedTokenView(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("suggested", options.cssClass);
		options.pistachio = "";
		SuggestedTokenView.__super__.constructor.call(this, options, data)
	}
	__extends(SuggestedTokenView, _super);
	SuggestedTokenView.prototype.getPrefix = function () {
		return this.getOptions().prefix
	};
	SuggestedTokenView.prototype.getKey = function () {
		return "$suggest"
	};
	SuggestedTokenView.prototype.getIdentity = function () {
		var $suggest;
		$suggest = this.getData().$suggest;
		return "" + this.getKey() + ":" + $suggest
	};
	SuggestedTokenView.prototype.pistachio = function () {
		var $suggest, prefix;
		prefix = this.getOptions().prefix;
		$suggest = this.getData().$suggest;
		return "" + prefix + Encoder.XSSEncode($suggest)
	};
	return SuggestedTokenView
}(TokenView);
var TagContextMenuItem, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
TagContextMenuItem = function (_super) {
	function TagContextMenuItem(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("tag-context-menu-item", options.cssClass);
		TagContextMenuItem.__super__.constructor.call(this, options, data)
	}
	__extends(TagContextMenuItem, _super);
	TagContextMenuItem.prototype.pistachio = function () {
		var $deleted, $suggest, _ref;
		_ref = this.getData(), $suggest = _ref.$suggest, $deleted = _ref.$deleted;
		return $suggest ? 'Suggest <span class="ttag">' + Encoder.XSSEncode($suggest) + "</span> as a new topic?" : $deleted ? 'You can not tag your post with <span class="ttag">' + Encoder.XSSEncode($deleted) + "</span>" : "{{#(title)}}"
	};
	return TagContextMenuItem
}(JContextMenuItem);
var AvatarView, ErrorlessImageView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AvatarView = function (_super) {
	function AvatarView(options, data) {
		var height, width, _base, _base1, _base2, _base3, _base4, _base5, _base6, _ref, _ref1;
		null == options && (options = {});
		options.cssClass = KD.utils.curry("avatarview", options.cssClass);
		options.size || (options.size = {
			width: 50,
			height: 50
		});
		null == (_base = options.size).width && (_base.width = 50);
		null == (_base1 = options.size).height && (_base1.height = options.size.width);
		null == options.detailed && (options.detailed = !1);
		options.showStatus || (options.showStatus = !1);
		options.statusDiameter || (options.statusDiameter = 5);
		if (options.detailed) {
			this.detailedAvatar = {
				constructorName: AvatarTooltipView,
				options: {
					delegate: this,
					origin: options.origin
				},
				data: data
			};
			options.tooltip || (options.tooltip = {});
			(_base2 = options.tooltip).view || (_base2.view = options.detailed ? this.detailedAvatar : null);
			(_base3 = options.tooltip).cssClass || (_base3.cssClass = "avatar-tooltip");
			null == (_base4 = options.tooltip).animate && (_base4.animate = !0);
			(_base5 = options.tooltip).placement || (_base5.placement = "top");
			(_base6 = options.tooltip).direction || (_base6.direction = "right")
		}
		this.dpr = null != (_ref = window.devicePixelRatio) ? _ref : 1;
		_ref1 = options.size, width = _ref1.width, height = _ref1.height;
		this.gravatar = new ErrorlessImageView({
			width: width,
			height: height
		});
		this.gravatar.on("load", function (_this) {
			return function () {
				_this.gravatar.setCss("opacity", "1");
				return _this.setCss("background-image", "none")
			}
		}(this));
		AvatarView.__super__.constructor.call(this, options, data);
		null != this.detailedAvatar && this.on("TooltipReady", function (_this) {
			return function () {
				return _this.utils.defer(function () {
					data = _this.getData();
					return (null != data ? data.profile.nickname : void 0) ? _this.tooltip.getView().updateData(data) : void 0
				})
			}
		}(this))
	}
	__extends(AvatarView, _super);
	JView.mixin(AvatarView.prototype);
	AvatarView.prototype.getAvatar = function () {
		var _ref;
		return null != (_ref = this.gravatar) ? _ref.getAttribute("src") : void 0
	};
	AvatarView.prototype.setAvatar = function (src) {
		if (src && this.gravatar.getAttribute("src") !== src) {
			this.gravatar.show();
			return this.gravatar.setAttribute("src", src)
		}
	};
	AvatarView.prototype.getGravatarUri = function () {
		var defaultAvatarUri, profile, size, width;
		profile = this.getData().profile;
		if (null == (null != profile ? profile.hash : void 0)) return !1;
		width = this.getOptions().size.width;
		size = width * this.dpr;
		defaultAvatarUri = "https://koding-cdn.s3.amazonaws.com/images/default.avatar." + size + ".png";
		return "//gravatar.com/avatar/" + profile.hash + "?size=" + size + "&d=" + defaultAvatarUri + "&r=g"
	};
	AvatarView.prototype.render = function () {
		var account, avatarURI, flags, height, key, profile, resizedAvatar, type, value, width, _ref, _ref1;
		if (account = this.getData()) {
			profile = account.profile, type = account.type;
			if ("unregistered" !== type) {
				_ref = this.getOptions().size, width = _ref.width, height = _ref.height;
				height || (height = width);
				avatarURI = this.getGravatarUri();
				if (null != (_ref1 = profile.avatar) ? _ref1.match(/^https?:\/\//) : void 0) {
					resizedAvatar = KD.utils.proxifyUrl(profile.avatar, {
						crop: !0,
						width: width,
						height: height
					});
					avatarURI = resizedAvatar
				}
				this.setAvatar(avatarURI);
				flags = account.globalFlags ? Array.isArray(account.globalFlags) ? account.globalFlags.join(" ") : function () {
					var _ref2, _results;
					_ref2 = account.globalFlags;
					_results = [];
					for (key in _ref2)
						if (__hasProp.call(_ref2, key)) {
							value = _ref2[key];
							_results.push(value)
						}
					return _results
				}().join(" ") : "";
				this.$("cite").addClass(flags);
				KD.getSingleton("groupsController").ready(function (_this) {
					return function () {
						var href, slug;
						slug = KD.getSingleton("groupsController").getCurrentGroup().slug;
						href = "koding" === slug ? "/" + profile.nickname : "/" + slug + "/" + profile.nickname;
						return _this.setAttribute("href", href)
					}
				}(this));
				return this.getOptions().showStatus ? this.showStatus() : void 0
			}
		}
	};
	AvatarView.prototype.showStatus = function () {
		var account, onlineStatus;
		account = this.getData();
		onlineStatus = account.onlineStatus || "offline";
		null != this.statusAttr && onlineStatus !== this.statusAttr && this.setClass("animate");
		this.statusAttr = onlineStatus;
		if ("online" === this.statusAttr) {
			this.unsetClass("offline");
			return this.setClass("online")
		}
		this.unsetClass("online");
		return this.setClass("offline")
	};
	AvatarView.prototype.viewAppended = function () {
		var height, statusDiameter, width, _ref;
		JView.prototype.viewAppended.call(this);
		_ref = this.getOptions().size, width = _ref.width, height = _ref.height;
		this.setCss("background-size", "" + width + "px " + height + "px");
		this.getData() && this.render();
		if (this.getOptions().showStatus) {
			statusDiameter = this.getOptions().statusDiameter;
			this.addSubView(this.statusIndicator = new KDCustomHTMLView({
				cssClass: "statusIndicator"
			}));
			this.statusIndicator.setWidth(statusDiameter);
			return this.statusIndicator.setHeight(statusDiameter)
		}
	};
	AvatarView.prototype.pistachio = function () {
		return "{{> this.gravatar}}\n<cite></cite>"
	};
	return AvatarView
}(LinkView);
ErrorlessImageView = function (_super) {
	function ErrorlessImageView(options, data) {
		null == options && (options = {});
		ErrorlessImageView.__super__.constructor.call(this, {
			tagName: "img",
			cssClass: "hidden",
			bind: "load error",
			attributes: {
				width: options.width,
				height: options.height
			}
		}, data);
		this.setCss("opacity", "0.0001")
	}
	__extends(ErrorlessImageView, _super);
	ErrorlessImageView.prototype.error = function () {
		this.hide();
		return !1
	};
	return ErrorlessImageView
}(KDCustomHTMLView);
var AvatarTooltipView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AvatarTooltipView = function (_super) {
	function AvatarTooltipView(options, data) {
		var name, origin;
		null == options && (options = {});
		AvatarTooltipView.__super__.constructor.call(this, options, data);
		origin = options.origin;
		name = KD.utils.getFullnameFromAccount(this.getData());
		this.profileName = new JView({
			tagName: "a",
			cssClass: "profile-name",
			attributes: {
				href: "/" + this.getData().profile.nickname,
				target: "_blank"
			},
			pistachio: "<h2>" + name + "</h2>"
		}, data);
		this.staticAvatar = new AvatarStaticView({
			cssClass: "avatar-static",
			noTooltip: !0,
			size: {
				width: 80,
				height: 80
			},
			origin: origin
		}, data);
		this.followButton = new MemberFollowToggleButton({
			style: "follow-btn",
			loader: {
				color: "#333333",
				diameter: 18,
				top: 11
			}
		}, this.getData());
		this.followers = new JView({
			tagName: "a",
			attributes: {
				href: "#"
			},
			pistachio: "<cite/>{{#(counts.followers)}} <span>Followers</span>",
			click: function () {
				return 0 !== this.getData().counts.followers ? KD.getSingleton("appManager").tell("Members", "createFolloweeContentDisplay", this.getData(), "followers") : void 0
			}
		}, this.getData());
		this.following = new JView({
			tagName: "a",
			attributes: {
				href: "#"
			},
			pistachio: "<cite/>{{#(counts.following)}} <span>Following</span>",
			click: function () {
				return 0 !== this.getData().counts.following ? KD.getSingleton("appManager").tell("Members", "createFolloweeContentDisplay", this.getData(), "following") : void 0
			}
		}, this.getData());
		this.likes = new JView({
			tagName: "a",
			attributes: {
				href: "#"
			},
			pistachio: "<cite/>{{#(counts.likes) || 0}} <span>Likes</span>",
			click: function (_this) {
				return function () {
					return 0 !== _this.getData().counts.following ? KD.getSingleton("appManager").tell("Members", "createLikedContentDisplay", _this.getData()) : void 0
				}
			}(this)
		}, this.getData());
		this.sendMessageLink = new MemberMailLink({}, this.getData())
	}
	__extends(AvatarTooltipView, _super);
	AvatarTooltipView.prototype.viewAppended = function () {
		AvatarTooltipView.__super__.viewAppended.call(this);
		this.setTemplate(this.pistachio());
		return this.template.update()
	};
	AvatarTooltipView.prototype.click = function () {};
	AvatarTooltipView.prototype.decorateFollowButton = function (data) {
		var _base;
		if (null != data.getId) {
			if (null == data.followee) "function" == typeof (_base = KD.whoami()).isFollowing && _base.isFollowing(data.getId(), "JAccount", function (_this) {
				return function (err, following) {
					data.followee = following;
					KD.isLoggedIn() && warn(err);
					if (data.followee) {
						_this.followButton.setClass("following-btn");
						return _this.followButton.setState("Following")
					}
					_this.followButton.setState("Follow");
					return _this.followButton.unsetClass("following-btn")
				}
			}(this));
			else if (data.followee) {
				this.followButton.setClass("following-btn");
				this.followButton.setState("Following")
			}
			this.followButton.setData(data);
			return this.followButton.render()
		}
	};
	AvatarTooltipView.prototype.updateData = function (data) {
		null == data && (data = {});
		this.setData(data);
		this.decorateFollowButton(data);
		this.profileName.setData(data);
		this.profileName.render();
		this.followers.setData(data);
		this.following.setData(data);
		this.likes.setData(data);
		this.sendMessageLink.setData(data);
		this.followers.render();
		this.following.render();
		this.likes.render();
		return this.sendMessageLink.render()
	};
	AvatarTooltipView.prototype.pistachio = function () {
		return '<div class="leftcol">\n  {{> this.staticAvatar}}\n  {{> this.followButton}}\n</div>\n<div class="rightcol">\n  {{> this.profileName}}\n  <div class="profilestats">\n      <div class="fers">\n        {{> this.followers}}\n      </div>\n      <div class="fing">\n        {{> this.following}}\n      </div>\n       <div class="liks">\n        {{> this.likes}}\n      </div>\n      <div class=\'contact\'>\n        {{> this.sendMessageLink}}\n      </div>\n    </div>\n</div>'
	};
	return AvatarTooltipView
}(JView);
var AvatarImage, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AvatarImage = function (_super) {
	function AvatarImage(options, data) {
		null == options && (options = {});
		options.tagName || (options.tagName = "img");
		options.cssClass || (options.cssClass = "");
		options.size || (options.size = {
			width: 50,
			height: 50
		});
		options.cssClass = KD.utils.curry("avatarimage", options.cssClass);
		AvatarImage.__super__.constructor.call(this, options, data)
	}
	__extends(AvatarImage, _super);
	AvatarImage.prototype.setAvatar = function (uri) {
		var height, width, _ref;
		if (this.bgImg !== uri) {
			_ref = this.getOptions().size, width = _ref.width, height = _ref.height;
			this.setAttribute("src", uri);
			this.setAttribute("width", width);
			this.setAttribute("height", height);
			return this.bgImg = uri
		}
	};
	AvatarImage.prototype.pistachio = function () {
		return ""
	};
	return AvatarImage
}(AvatarView);
var AvatarStaticView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AvatarStaticView = function (_super) {
	function AvatarStaticView(options) {
		null == options && (options = {});
		options.tagName || (options.tagName = "span");
		AvatarStaticView.__super__.constructor.apply(this, arguments)
	}
	__extends(AvatarStaticView, _super);
	AvatarStaticView.prototype.click = function () {
		return !0
	};
	return AvatarStaticView
}(AvatarView);
var AutoCompleteAvatarView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AutoCompleteAvatarView = function (_super) {
	function AutoCompleteAvatarView(options) {
		null == options && (options = {});
		options.size || (options.size = {
			width: 20,
			height: 20
		});
		options.cssClass = "avatarview " + options.cssClass;
		AutoCompleteAvatarView.__super__.constructor.apply(this, arguments)
	}
	__extends(AutoCompleteAvatarView, _super);
	return AutoCompleteAvatarView
}(AvatarView);
var ActivityWidgetItem, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ActivityWidgetItem = function (_super) {
	function ActivityWidgetItem(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("status-update-widget-item", options.cssClass);
		ActivityWidgetItem.__super__.constructor.call(this, options, data);
		this.createAuthor();
		this.createCommentBox();
		this.actionLinks = new ActivityActionsView({
			cssClass: "comment-header",
			delegate: this.commentBox.commentList
		}, data);
		this.timeAgo = new KDTimeAgoView(null, data.meta.createdAt)
	}
	__extends(ActivityWidgetItem, _super);
	ActivityWidgetItem.prototype.createAuthor = function () {
		var avatarHeight, avatarWidth, origin, originId, originType, _ref, _ref1;
		_ref = this.getOptions(), avatarWidth = _ref.avatarWidth, avatarHeight = _ref.avatarHeight;
		_ref1 = this.getData(), originId = _ref1.originId, originType = _ref1.originType;
		origin = {
			id: originId,
			constructorName: originType
		};
		this.avatar = new AvatarView({
			size: {
				width: avatarWidth || 50,
				height: avatarHeight || 50
			},
			origin: origin,
			showStatus: !0
		});
		return this.author = new ProfileLinkView({
			origin: origin
		})
	};
	ActivityWidgetItem.prototype.createCommentBox = function () {
		var commentSettings, _base;
		commentSettings = this.getOptions().commentSettings;
		commentSettings || (commentSettings = {});
		commentSettings.itemChildOptions || (commentSettings.itemChildOptions = {});
		null == (_base = commentSettings.itemChildOptions).showAvatar && (_base.showAvatar = !1);
		return this.commentBox = new CommentView(commentSettings, this.getData())
	};
	ActivityWidgetItem.prototype.formatContent = function (str) {
		null == str && (str = "");
		str = this.utils.applyMarkdown(str);
		str = this.utils.expandTokens(str, this.getData());
		return str
	};
	ActivityWidgetItem.prototype.pistachio = function () {
		return '<header>\n  {{> this.avatar}}\n  <div class="content">\n    {{> this.author}}\n    {article{this.formatContent(#(body))}}\n  </div>\n</header>\n<footer>\n  {{> this.actionLinks}}\n  {{> this.timeAgo}}\n</footer>\n{{> this.commentBox}}'
	};
	return ActivityWidgetItem
}(JView);
var ActivityWidget, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ActivityWidget = function (_super) {
	function ActivityWidget(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("status-update-widget", options.cssClass);
		options.showForm || (options.showForm = !0);
		options.childOptions || (options.childOptions = {});
		ActivityWidget.__super__.constructor.call(this, options, data);
		this.activity = null
	}
	__extends(ActivityWidget, _super);
	ActivityWidget.prototype.showForm = function (callback) {
		var _ref;
		null != (_ref = this.inputWidget) && _ref.show();
		return this.inputWidget.once("Submit", callback)
	};
	ActivityWidget.prototype.hideForm = function () {
		var _ref;
		return null != (_ref = this.inputWidget) ? _ref.hide() : void 0
	};
	ActivityWidget.prototype.display = function (id, callback) {
		null == callback && (callback = noop);
		return KD.remote.cacheable("JNewStatusUpdate", id, function (_this) {
			return function (err, activity) {
				KD.showError(err);
				callback(err, activity);
				return activity.fetchTags(function (err, tags) {
					activity.tags = tags;
					return activity && !err ? _this.addActivity(activity) : void 0
				})
			}
		}(this))
	};
	ActivityWidget.prototype.create = function (body, callback) {
		null == callback && (callback = noop);
		return KD.remote.api.JNewStatusUpdate.create({
			body: body
		}, function (_this) {
			return function (err, activity) {
				KD.showError(err);
				callback(err, activity);
				return activity && !err ? _this.addActivity(activity) : void 0
			}
		}(this))
	};
	ActivityWidget.prototype.reply = function (body, callback) {
		var _ref;
		null == callback && (callback = noop);
		return null != (_ref = this.activity) ? _ref.reply(body, callback) : void 0
	};
	ActivityWidget.prototype.addActivity = function (activity) {
		this.activity = activity;
		return this.addSubView(new ActivityWidgetItem(this.getOptions().childOptions, activity))
	};
	ActivityWidget.prototype.setInputContent = function (str) {
		var _ref;
		null == str && (str = "");
		return null != (_ref = this.inputWidget) ? _ref.input.setContent(str) : void 0
	};
	ActivityWidget.prototype.viewAppended = function () {
		var defaultValue, showForm, _ref;
		_ref = this.getOptions(), defaultValue = _ref.defaultValue, showForm = _ref.showForm;
		return KD.singleton("appManager").require("Activity", function (_this) {
			return function () {
				_this.addSubView(_this.inputWidget = new ActivityInputWidget({
					defaultValue: defaultValue
				}));
				return _this.inputWidget.once("Submit", function (err, activity) {
					return err ? KD.showError(err) : activity ? _this.addActivity(activity) : void 0
				})
			}
		}(this))
	};
	return ActivityWidget
}(KDView);
var UploadImageModalView, __bind = function (fn, me) {
		return function () {
			return fn.apply(me, arguments)
		}
	},
	__hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
UploadImageModalView = function (_super) {
	function UploadImageModalView(options, data) {
		null == options && (options = {});
		this.updateImage = __bind(this.updateImage, this);
		null == options.title && (options.title = "Upload photo");
		null == options.uploaderTitle && (options.uploaderTitle = "Drag & drop image here!");
		null == options.overlay && (options.overlay = !0);
		null == options.preview && (options.preview = options.image);
		null == options.overlayClick && (options.overlayClick = !1);
		null == options.buttons && (options.buttons = {
			uploadButton: {
				title: "Upload",
				cssClass: "modal-clean-green",
				callback: this.bound("upload")
			}
		});
		UploadImageModalView.__super__.constructor.call(this, options, data);
		this.uploaderView = new DNDUploader({
			title: this.getOptions().uploaderTitle,
			uploadToVM: !1,
			size: this.getOptions().preview.size
		});
		this.loaderView = new KDLoaderView({
			showLoader: !1,
			cssClass: "hidden",
			size: {
				width: 32
			}
		});
		this.uploaderView.on("dropFile", function (_this) {
			return function (_arg) {
				var content, origin;
				origin = _arg.origin, content = _arg.content;
				if ("external" === origin) {
					_this.previewData = "data:image/png;base64," + btoa(content);
					_this.uploaderView.updatePartial("");
					return _this.updateImage()
				}
			}
		}(this));
		this.addSubView(this.uploaderView);
		this.addSubView(this.loaderView)
	}
	__extends(UploadImageModalView, _super);
	UploadImageModalView.prototype.updateImage = function () {
		var _ref;
		null != (_ref = this.imagePreview) && _ref.destroy();
		this.imagePreview = new KDCustomHTMLView({
			tagName: "figure",
			size: this.getOptions().preview.size
		});
		this.imagePreview.setStyle({
			"background-image": "url(" + this.previewData + ")"
		});
		return this.uploaderView.addSubView(this.imagePreview)
	};
	UploadImageModalView.prototype.uploadToS3 = function (avatarData, callback) {
		var groupsController;
		groupsController = KD.singletons.groupsController;
		return groupsController.ready(function (_this) {
			return function () {
				var group, imageName, imageType;
				group = groupsController.getCurrentGroup();
				imageType = _this.getOptions().image.type;
				imageName = "" + group.slug + "-" + imageType + "-" + Date.now() + ".png";
				return FSHelper.s3.upload(imageName, avatarData, "groups", group.slug, function (err, url) {
					var message;
					if (!err) {
						group = KD.singletons.groupsController.getCurrentGroup();
						return "coverPhoto" === _this.getOptions().image.type ? group.modify({
							"customize.coverPhoto": "" + url
						}, callback) : group.modify({
							"customize.logo": "" + url
						}, callback)
					}
					message = 100 === err.code ? "First you have to create a VM" : "Error while uploading photo.";
					KD.showError(message);
					_this.loaderView.hide()
				})
			}
		}(this))
	};
	UploadImageModalView.prototype.upload = function (callback) {
		var imageBase64, _, _ref;
		if (!this.previewData) return new KDNotificationView({
			title: "Please drag & drop an image to upload!"
		});
		this.loaderView.show();
		_ref = this.previewData.split(","), _ = _ref[0], imageBase64 = _ref[1];
		return this.uploadToS3(imageBase64, function (_this) {
			return function (err) {
				_this.loaderView.hide();
				return "function" == typeof callback ? callback(err) : void 0
			}
		}(this))
	};
	return UploadImageModalView
}(KDModalView);
var IdleUserDetector, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
IdleUserDetector = function (_super) {
	function IdleUserDetector(options, data) {
		IdleUserDetector.__super__.constructor.call(this, options, data);
		this.detectIdleUser()
	}
	__extends(IdleUserDetector, _super);
	IdleUserDetector.prototype.detectIdleUser = function () {
		var threshold;
		threshold = this.getOptions().threshold;
		window.addEventListener("mousemove", this.bound("notIdle"), !0);
		window.addEventListener("keypress", this.bound("notIdle"), !0);
		KD.utils.repeat(1e3, function (_this) {
			return function () {
				return Date.now() - _this.idleSince > threshold ? _this.idle() : void 0
			}
		}(this));
		return this.notIdle()
	};
	IdleUserDetector.prototype.idle = function () {
		var wasIdle;
		wasIdle = this.isIdle;
		this.isIdle = !0;
		return wasIdle ? void 0 : this.emit("userIdle")
	};
	IdleUserDetector.prototype.notIdle = function () {
		var wasIdle;
		wasIdle = this.isIdle;
		this.isIdle = !1;
		this.idleSince = Date.now();
		return wasIdle ? this.emit("userBack") : void 0
	};
	return IdleUserDetector
}(KDObject);
var Junction, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__slice = [].slice;
Junction = function (_super) {
	function Junction(fields) {
		var field, _i, _len;
		null == fields && (fields = []);
		Junction.__super__.constructor.call(this);
		this.id = this.createId();
		this.fields = {};
		this.children = {};
		this.ordered = [];
		this.index = 0;
		for (_i = 0, _len = fields.length; _len > _i; _i++) {
			field = fields[_i];
			this.addField(field)
		}
	}
	var All, Any;
	__extends(Junction, _super);
	Junction.prototype.createId = KD.utils.createCounter();
	Junction.prototype.isJunction = !0;
	Junction.prototype.getFields = function (isDeep) {
		var child, fields, key, _, _ref, _ref1, _results;
		if (isDeep) {
			fields = this.getFields();
			_ref = this.children;
			for (_ in _ref)
				if (__hasProp.call(_ref, _)) {
					child = _ref[_];
					fields.push.apply(fields, child.getFields(isDeep))
				}
			return fields
		}
		_ref1 = this.fields;
		_results = [];
		for (key in _ref1) __hasProp.call(_ref1, key) && (key in this.children || _results.push(key));
		return _results
	};
	Junction.prototype.iterate = function () {
		this.index++;
		return this.nextNode()
	};
	Junction.prototype.nextNode = function () {
		var node;
		node = this.ordered[this.index];
		if (null == node) {
			this.index = 0;
			return this.nextNode()
		}
		if (node.isJunction) return node.isSatisfied() ? this.iterate() : node.shouldPropagate() ? node.nextNode() : this.iterate();
		this.index++;
		return node
	};
	Junction.prototype.shouldPropagate = function () {
		return !0
	};
	Junction.prototype.addChild = function (child) {
		this.children[child] = child;
		return this
	};
	Junction.prototype.removeChild = function (child) {
		delete this.children[child];
		return this
	};
	Junction.prototype.addField = function (field) {
		var satisfier;
		this.ordered.push(field);
		satisfier = this.createSatisfier();
		this.fields[field] = satisfier;
		if (field.isJunction) {
			this.addChild(field);
			field.on("status", function (isSatisfied) {
				return isSatisfied ? satisfier.satisfy() : satisfier.cancel()
			})
		}
		return this
	};
	Junction.prototype.removeKey = function (key) {
		var child, _, _ref;
		if (key in this.fields) {
			this.index = 0;
			this.fields[key].cancel()
		} else {
			_ref = this.children;
			for (_ in _ref)
				if (__hasProp.call(_ref, _)) {
					child = _ref[_];
					child.removeKey(key)
				}
		}
		return this
	};
	Junction.prototype.satisfy = function (field) {
		var child, satisfier, _, _ref;
		null != (satisfier = this.fields[field]) && satisfier.satisfy();
		_ref = this.children;
		for (_ in _ref)
			if (__hasProp.call(_ref, _)) {
				child = _ref[_];
				child.satisfy(field)
			}
		return this
	};
	Junction.prototype.createSatisfier = function () {
		var satisfier;
		satisfier = new Junction.Satisfier;
		satisfier.on("Satisfied", this.bound("report"));
		satisfier.on("Canceled", this.bound("report"));
		return satisfier
	};
	Junction.prototype.report = function () {
		this.emit("status", this.isSatisfied());
		return this
	};
	Junction.prototype.kill = function () {
		return this.compliment(!1)
	};
	Junction.prototype.compliment = function (value) {
		return value
	};
	Junction.prototype.isSatisfied = function () {
		var category, node, _, _i, _len, _ref;
		_ref = [this.fields, this.children];
		for (_i = 0, _len = _ref.length; _len > _i; _i++) {
			category = _ref[_i];
			for (_ in category)
				if (__hasProp.call(category, _)) {
					node = category[_];
					if (!this.compliment(node.isSatisfied())) return this.kill()
				}
		}
		return !this.kill()
	};
	Junction.prototype.toString = function () {
		return "junction-" + this.id
	};
	Junction.All = All = function (_super1) {
		function All() {
			return All.__super__.constructor.apply(this, arguments)
		}
		__extends(All, _super1);
		return All
	}(Junction);
	Junction.Any = Any = function (_super1) {
		function Any() {
			return Any.__super__.constructor.apply(this, arguments)
		}
		__extends(Any, _super1);
		Any.prototype.compliment = function (value) {
			return !value
		};
		Any.prototype.createSatisfier = function () {
			return null != this.satisfier ? this.satisfier : this.satisfier = Any.__super__.createSatisfier.apply(this, arguments)
		};
		return Any
	}(Junction);
	Junction.all = function () {
		var fields;
		fields = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
		return new All(fields)
	};
	Junction.any = function () {
		var fields;
		fields = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
		return new Any(fields)
	};
	return Junction
}(KDObject);
var __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
Junction.Satisfier = function (_super) {
	function Satisfier() {
		Satisfier.__super__.constructor.call(this);
		this.dirty = !1;
		this.satisfied = 0
	}
	__extends(Satisfier, _super);
	Satisfier.prototype.isSatisfied = function () {
		return this.satisfied > 0
	};
	Satisfier.prototype.isDirty = function () {
		return this.dirty
	};
	Satisfier.prototype.satisfy = function () {
		this.dirty = !0;
		this.satisfied++;
		return this.emit("Satisfied")
	};
	Satisfier.prototype.cancel = function () {
		this.dirty = !0;
		this.satisfied = Math.max(this.satisfied - 1, 0);
		return this.emit("Canceled")
	};
	return Satisfier
}(KDEventEmitter);
var FormWorkflow, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
FormWorkflow = function (_super) {
	function FormWorkflow(options, data) {
		null == options && (options = {});
		FormWorkflow.__super__.constructor.call(this, options, data);
		this.collector = new FormWorkflow.Collector;
		this.collector.on("Pending", this.bound("nextForm"));
		this.forwardEvent(this.collector, "DataCollected");
		this.forms = {};
		this.providers = {};
		this.active = null;
		this.history = new FormWorkflow.History
	}
	__extends(FormWorkflow, _super);
	FormWorkflow.prototype.isWorkflow = !0;
	FormWorkflow.prototype.enter = function () {
		return this.ready(this.bound("nextForm"))
	};
	FormWorkflow.prototype.go = function (direction) {
		var provider;
		provider = this.history[direction]();
		provider.isWorkflow && (provider === this.active && "back" === direction || "next" === direction) && provider.go(direction);
		return this.showForm(provider, !1)
	};
	FormWorkflow.prototype.next = function () {
		return this.go("next")
	};
	FormWorkflow.prototype.back = function () {
		return this.go("back")
	};
	FormWorkflow.prototype.requireData = function (fields) {
		this.collector.addRequirement(fields);
		return this
	};
	FormWorkflow.prototype.getFields = function (isDeep) {
		return this.collector.getFields(isDeep)
	};
	FormWorkflow.prototype.getData = function () {
		return this.collector.data
	};
	FormWorkflow.prototype.isSatisfied = function () {
		return this.collector.gate.isSatisfied()
	};
	FormWorkflow.prototype.collectData = function (data) {
		this.collector.collectData(data);
		return this
	};
	FormWorkflow.prototype.clearData = function (key) {
		this.collector.removeKey(key);
		return this
	};
	FormWorkflow.prototype.provideData = function (form, providers) {
		var field, _base, _i, _len;
		for (_i = 0, _len = providers.length; _len > _i; _i++) {
			field = providers[_i];
			null == (_base = this.providers)[field] && (_base[field] = []);
			this.providers[field].push("string" == typeof form ? this.forms[form] : form)
		}
		return this
	};
	FormWorkflow.prototype.nextForm = function () {
		var provider;
		provider = this.nextProvider();
		return null != provider ? this.showForm(provider) : void 0
	};
	FormWorkflow.prototype.nextRequirement = function () {
		return this.collector.nextRequirement()
	};
	FormWorkflow.prototype.nextProvider = function (key, from) {
		var e, provider, providers, _ref;
		null == key && (key = this.nextRequirement());
		providers = this.providers[key];
		providers.i = null != (_ref = null != from ? from : providers.i) ? _ref : 0;
		provider = providers[providers.i++];
		if (null != provider) return provider;
		try {
			return this.nextProvider(key, 0)
		} catch (_error) {
			e = _error;
			if (!(e instanceof RangeError)) throw e
		}
	};
	FormWorkflow.prototype.addForm = function (formName, form, provides) {
		null == provides && (provides = []);
		this.forms[formName] = form;
		this.addSubView(form);
		form.hide();
		this.forwardEvent(form, "Cancel");
		this.provideData(formName, provides);
		return this
	};
	FormWorkflow.prototype.removeForm = function (form) {
		form = this.getForm(form);
		this.removeSubView(form);
		delete this.forms[form];
		return this
	};
	FormWorkflow.prototype.getForm = function (form) {
		return "string" == typeof form ? this.forms[form] : form
	};
	FormWorkflow.prototype.getFormNames = function () {
		return Object.keys(this.forms)
	};
	FormWorkflow.prototype.hideForms = function (forms) {
		var form, _i, _len, _ref;
		null == forms && (forms = this.getFormNames());
		for (_i = 0, _len = forms.length; _len > _i; _i++) {
			form = forms[_i];
			null != (_ref = this.forms[form]) && _ref.hide()
		}
		return this
	};
	FormWorkflow.prototype.showForm = function (form, shouldPushState) {
		null == shouldPushState && (shouldPushState = !0);
		this.hideForms();
		form = this.getForm(form);
		form.show();
		"function" == typeof form.activate && form.activate(this);
		this.active = form;
		shouldPushState && this.history.push(form);
		this.emit("FormIsShown", form);
		return this
	};
	FormWorkflow.prototype.addLoader = function () {
		return this.addSubView(this.loader = new KDLoaderView({
			size: {
				width: 60,
				height: 60
			},
			loaderOptions: {
				color: "#1aaf5d"
			}
		}))
	};
	FormWorkflow.prototype.showLoader = function () {
		return this.loader.show()
	};
	FormWorkflow.prototype.hideLoader = function () {
		return this.loader.hide()
	};
	FormWorkflow.prototype.viewAppended = function () {
		this.addLoader();
		"function" == typeof this.prepareWorkflow && this.prepareWorkflow();
		this.emit("ready");
		return this.hideLoader()
	};
	FormWorkflow.prototype.skip = function (data) {
		var v;
		v = new KDView;
		v.activate = function (_this) {
			return function () {
				return _this.collectData(data)
			}
		}(this);
		return v
	};
	return FormWorkflow
}(KDView);
var __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
FormWorkflow.History = function (_super) {
	function History() {
		History.__super__.constructor.call(this);
		this.state = -1;
		this.stack = []
	}
	__extends(History, _super);
	History.prototype.push = function (provider) {
		this.stack[this.state + 1] !== provider && this.stack.push(provider);
		this.emit("Push", provider);
		return this.inc()
	};
	History.prototype.lastIndex = function () {
		return this.stack.length - 1
	};
	History.prototype.inc = function (n) {
		null == n && (n = 1);
		this.state = Math.min(Math.max(0, this.state + n), this.lastIndex());
		return this.state
	};
	History.prototype.go = function (n) {
		null == n && (n = 1);
		return this.stack[this.inc(n)]
	};
	History.prototype.back = function () {
		return this.go(-1)
	};
	History.prototype.next = function () {
		return this.go(1)
	};
	return History
}(KDObject);
var __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
FormWorkflow.Collector = function (_super) {
	function Collector(gate) {
		this.gate = null != gate ? gate : new Junction;
		Collector.__super__.constructor.call(this);
		this.data = KD.utils.dict();
		this.gate.on("status", function (_this) {
			return function (isSatisfied) {
				return isSatisfied ? _this.emit("DataCollected", _this.data) : _this.emit("Pending")
			}
		}(this))
	}
	__extends(Collector, _super);
	Collector.prototype.addRequirement = function (requirement) {
		return this.gate.addField(requirement.isJunction ? requirement : Junction.all.apply(Junction, requirement))
	};
	Collector.prototype.nextRequirement = function () {
		return this.gate.nextNode()
	};
	Collector.prototype.getFields = function (isDeep) {
		return this.gate.getFields(isDeep)
	};
	Collector.prototype.getData = function () {
		return this.data
	};
	Collector.prototype.collectData = function (data) {
		var key, val, _results;
		_results = [];
		for (key in data)
			if (__hasProp.call(data, key)) {
				val = data[key];
				_results.push(this.defineKey(key, val))
			}
		return _results
	};
	Collector.prototype.removeKey = function (key) {
		delete this.data[key];
		return this.gate.removeKey(key)
	};
	Collector.prototype.defineKey = function (key, value) {
		this.data[key] = value;
		return this.gate.satisfy(key)
	};
	return Collector
}(KDEventEmitter);
var FormWorkflowModal, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
FormWorkflowModal = function (_super) {
	function FormWorkflowModal(options, data) {
		null == options && (options = {});
		null == data && (data = {});
		null == options.showNav && (options.showNav = !0);
		FormWorkflowModal.__super__.constructor.call(this, options, data)
	}
	__extends(FormWorkflowModal, _super);
	FormWorkflowModal.prototype.viewAppended = function () {
		var nav, workflow;
		workflow = this.getOptions().view;
		this.setClass("workflow-modal");
		if (this.getOption("showNav")) {
			nav = new BidirectionalNavigation;
			this.addSubView(nav, ".kdmodal-title");
			nav.on("Back", workflow.bound("back"));
			return nav.on("Next", workflow.bound("next"))
		}
	};
	return FormWorkflowModal
}(KDModalView);
var MainNavController, NavigationController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
NavigationController = function (_super) {
	function NavigationController() {
		return NavigationController.__super__.constructor.apply(this, arguments)
	}
	__extends(NavigationController, _super);
	NavigationController.prototype.reset = function () {
		var name, previousSelection, _i, _len, _results;
		previousSelection = this.selectedItems.slice();
		this.removeAllItems();
		this.instantiateListItems(this.getData().items);
		_results = [];
		for (_i = 0, _len = previousSelection.length; _len > _i; _i++) {
			name = previousSelection[_i].name;
			_results.push(this.selectItemByName(name))
		}
		return _results
	};
	NavigationController.prototype.getItemByName = function (name) {
		var navItem, _i, _len, _ref, _ref1;
		_ref = this.itemsOrdered;
		for (_i = 0, _len = _ref.length; _len > _i; _i++) {
			navItem = _ref[_i];
			if ((null != (_ref1 = navItem.getData()) ? _ref1.title : void 0) === name) return navItem
		}
	};
	NavigationController.prototype.selectItemByName = function (name) {
		var item;
		(item = this.getItemByName(name)) ? this.selectItem(item): this.deselectAllItems();
		return item
	};
	NavigationController.prototype.removeItemByTitle = function (name) {
		var navItem, _i, _len, _ref, _results;
		_ref = this.itemsOrdered;
		_results = [];
		for (_i = 0, _len = _ref.length; _len > _i; _i++) {
			navItem = _ref[_i];
			(null != navItem ? navItem.name : void 0) === name && _results.push(this.removeItem(navItem))
		}
		return _results
	};
	NavigationController.prototype.instantiateListItems = function (items) {
		var itemData, roles, _i, _len, _ref, _results;
		roles = KD.config.roles;
		_results = [];
		for (_i = 0, _len = items.length; _len > _i; _i++) {
			itemData = items[_i];
			if (null != itemData.loggedIn) {
				if (itemData.loggedIn && !KD.isLoggedIn()) continue;
				if (!itemData.loggedIn && KD.isLoggedIn()) continue
			}
			itemData.role ? (_ref = itemData.role, _results.push(__indexOf.call(roles, _ref) >= 0 ? this.getListView().addItem(itemData) : void 0)) : _results.push(this.getListView().addItem(itemData))
		}
		return _results
	};
	return NavigationController
}(KDListViewController);
MainNavController = function (_super) {
	function MainNavController() {
		return MainNavController.__super__.constructor.apply(this, arguments)
	}
	__extends(MainNavController, _super);
	MainNavController.prototype.reset = function () {
		var name, previousSelection, _i, _len, _results;
		previousSelection = this.selectedItems.slice();
		this.removeAllItems();
		this.instantiateListItems(KD.getNavItems());
		_results = [];
		for (_i = 0, _len = previousSelection.length; _len > _i; _i++) {
			name = previousSelection[_i].name;
			_results.push(this.selectItemByName(name))
		}
		return _results
	};
	return MainNavController
}(NavigationController);
var VideoPopup, VideoPopupController, VideoPopupList, VideoPopupListItem, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
VideoPopupController = function (_super) {
	function VideoPopupController(options, data) {
		VideoPopupController.__super__.constructor.call(this, options, data);
		this.videoPopups = []
	}
	__extends(VideoPopupController, _super);
	VideoPopupController.prototype.newPopup = function (url, windowTitle, optionString, imageTitle, imageThumb) {
		var newWindow;
		newWindow = window.open(url, windowTitle, optionString);
		newWindow.onbeforeunload = function (_this) {
			return function () {
				newWindow.onbeforeunload = noop;
				_this.closePopup(newWindow);
				return void 0
			}
		}(this);
		this.videoPopups.push(newWindow);
		this.emit("PopupOpened", newWindow, {
			title: imageTitle,
			thumb: imageThumb
		});
		return newWindow
	};
	VideoPopupController.prototype.listPopups = function () {
		return this.videoPopups
	};
	VideoPopupController.prototype.countPopups = function () {
		return this.videoPopups.length
	};
	VideoPopupController.prototype.focusWindowByName = function (windowName, callback) {
		var video, _i, _len, _ref, _results;
		null == callback && (callback = noop);
		_ref = this.videoPopups;
		_results = [];
		for (_i = 0, _len = _ref.length; _len > _i; _i++) {
			video = _ref[_i];
			_results.push(video.name === windowName ? video.focus() : void 0)
		}
		return _results
	};
	VideoPopupController.prototype.closeWindowByName = function (windowName, callback) {
		var video, _i, _len, _ref, _results;
		null == callback && (callback = noop);
		_ref = this.videoPopups;
		_results = [];
		for (_i = 0, _len = _ref.length; _len > _i; _i++) {
			video = _ref[_i];
			_results.push((null != video ? video.name : void 0) === windowName ? this.closePopup(video) : void 0)
		}
		return _results
	};
	VideoPopupController.prototype.closePopup = function (popupWindow) {
		var i, videoPopup, _i, _len, _ref;
		_ref = this.videoPopups;
		for (i = _i = 0, _len = _ref.length; _len > _i; i = ++_i) {
			videoPopup = _ref[i];
			if (popupWindow === videoPopup) {
				this.videoPopups.splice(i, 1);
				this.emit("PopupClosed", popupWindow.name, i)
			}
		}
		return null != popupWindow ? popupWindow.close() : void 0
	};
	return VideoPopupController
}(KDController);
VideoPopupList = function (_super) {
	function VideoPopupList(options, data) {
		VideoPopupList.__super__.constructor.call(this, options, data);
		this.setClass("video-popup-list");
		this.controller = KD.getSingleton("mainController").popupController;
		this.controller.on("PopupOpened", function (_this) {
			return function (popup, data) {
				_this.addItem({
					delegate: _this,
					name: popup.name || "New Window",
					title: data.title,
					thumb: data.thumb
				});
				return _this.resizeView()
			}
		}(this));
		this.controller.on("PopupClosed", function (_this) {
			return function (popupName, index) {
				_this.removeItem({}, {}, index);
				return _this.resizeView()
			}
		}(this));
		this.on("FocusWindow", function (_this) {
			return function (windowName) {
				return _this.controller.focusWindowByName(windowName, function () {
					return _this.resizeView()
				})
			}
		}(this));
		this.on("CloseWindow", function (_this) {
			return function (windowName) {
				return _this.controller.closeWindowByName(windowName, function () {
					return _this.resizeView()
				})
			}
		}(this));
		this.hasNoItems = new KDView({
			cssClass: "has-no-video",
			partial: "There are no open Videos"
		});
		this.addSubView(this.hasNoItems)
	}
	__extends(VideoPopupList, _super);
	VideoPopupList.prototype.resizeView = function () {
		var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
		switch (this.controller.countPopups()) {
		case 0:
			this.hasNoItems.show();
			null != (_ref = KD.getSingleton("mainView")) && null != (_ref1 = _ref.videoButton) && _ref1.unsetClass("has-videos");
			this.unsetClass("layout1x1");
			this.unsetClass("layout2x2");
			return this.unsetClass("layout3x3");
		case 1:
			this.hasNoItems.hide();
			null != (_ref2 = KD.getSingleton("mainView")) && null != (_ref3 = _ref2.videoButton) && _ref3.setClass("has-videos");
			this.setClass("layout1x1");
			this.unsetClass("layout2x2");
			return this.unsetClass("layout3x3");
		case 2:
		case 3:
		case 4:
			this.hasNoItems.hide();
			null != (_ref4 = KD.getSingleton("mainView")) && null != (_ref5 = _ref4.videoButton) && _ref5.setClass("has-videos");
			this.unsetClass("layout1x1");
			this.setClass("layout2x2");
			return this.unsetClass("layout3x3");
		default:
			this.hasNoItems.hide();
			null != (_ref6 = KD.getSingleton("mainView")) && null != (_ref7 = _ref6.videoButton) && _ref7.setClass("has-videos");
			this.unsetClass("layout1x1");
			this.unsetClass("layout2x2");
			return this.setClass("layout3x3")
		}
	};
	return VideoPopupList
}(KDListView);
VideoPopupListItem = function (_super) {
	function VideoPopupListItem(options, data) {
		VideoPopupListItem.__super__.constructor.call(this, options, data);
		this.setClass("video-popup-list-item");
		this.focusWindowBar = new KDView({
			cssClass: "overlay-bar focus",
			partial: "<span class='overlay-text'>Focus</span>",
			click: function (_this) {
				return function () {
					return _this.getDelegate().emit("FocusWindow", _this.getData().name)
				}
			}(this)
		});
		this.closeWindowBar = new KDView({
			cssClass: "overlay-bar close",
			partial: "<span class='overlay-text'>Close</span>",
			click: function (_this) {
				return function () {
					return _this.getDelegate().emit("CloseWindow", _this.getData().name)
				}
			}(this)
		})
	}
	__extends(VideoPopupListItem, _super);
	VideoPopupListItem.prototype.viewAppended = function () {
		this.setTemplate(this.pistachio());
		return this.template.update()
	};
	VideoPopupListItem.prototype.pistachio = function () {
		return '<img title="' + this.getData().title + '" src="' + this.utils.proxifyUrl(this.getData().thumb) + '" />\n{{> this.focusWindowBar}}\n{{> this.closeWindowBar}}'
	};
	return VideoPopupListItem
}(KDListItemView);
VideoPopup = function (_super) {
	function VideoPopup(options, data) {
		VideoPopup.__super__.constructor.call(this, options, data);
		this.setClass("hidden invisible");
		this.embedData = data;
		this.options = options;
		this.controller = KD.getSingleton("mainController").popupController
	}
	__extends(VideoPopup, _super);
	VideoPopup.prototype.openVideoPopup = function () {
		var h, minH, minW, popupUrl, t, w, _ref;
		minH = 185;
		minW = 240;
		h = this.getDelegate().getHeight() > minH ? this.getDelegate().getHeight() : minH;
		w = this.getDelegate().getWidth() > minW ? this.getDelegate().getWidth() : minW;
		t = this.getDelegate().$().offset();
		null != (_ref = this.videoPopup) && _ref.close();
		popupUrl = "/video-container.html";
		this.videoPopup = this.controller.newPopup(popupUrl, "KodingVideo_" + Math.random().toString(36).substring(7), "menubar=no,location=no,resizable=yes,titlebar=no,scrollbars=no,status=no,innerHeight=" + h + ",width=" + w + ",left=" + (t.left + window.screenX) + ",top=" + (window.screenY + t.top + (window.outerHeight - window.innerHeight)), this.options.title, this.options.thumb);
		return this.utils.wait(1500, function (_this) {
			return function () {
				var command, _ref1, _ref2;
				window.onfocus = function () {
					return _this.utils.wait(500, function () {
						var countdownInterval, currentSeconds, modal, secondsToAutoClose, userChoice;
						if (0 !== _this.videoPopup.length) {
							window.onfocus = noop;
							userChoice = !1;
							secondsToAutoClose = 10;
							modal = new KDModalView({
								title: "Do you want to keep the video running?",
								content: "<p class='modal-video-close'>Your video will automatically end in <span class='countdown'>" + secondsToAutoClose + "</span> seconds unless you click the 'Yes'-Button below.</p>",
								overlay: !0,
								buttons: {
									"No, close it": {
										title: "No, close it",
										cssClass: "modal-clean-gray",
										callback: function () {
											var _ref1;
											null != (_ref1 = _this.videoPopup) && _ref1.close();
											return modal.destroy()
										}
									},
									"Yes, keep it running": {
										title: "Yes, keep it running",
										cssClass: "modal-clean-green",
										callback: function () {
											modal.destroy();
											return userChoice = !0
										}
									}
								}
							});
							currentSeconds = secondsToAutoClose - 1;
							countdownInterval = window.setInterval(function () {
								return modal.$("span.countdown").text(currentSeconds--)
							}, 1e3);
							return _this.utils.wait(1e3 * secondsToAutoClose, function () {
								window.clearInterval(countdownInterval);
								if (!userChoice) {
									_this.controller.closePopup(_this.videoPopup);
									return modal.destroy()
								}
							})
						}
					})
				};
				command = {
					type: "embed",
					embed: _this.embedData,
					coordinates: {
						left: (null != (_ref1 = _this.options.popup) ? _ref1.left : void 0) || t.left + window.screenX || 100,
						top: (null != (_ref2 = _this.options.popup) ? _ref2.top : void 0) || window.screenY + t.top + (window.outerHeight - window.innerHeight) || 100
					}
				};
				return command && _this.videoPopup ? _this.videoPopup.postMessage(command, "*") : void 0
			}
		}(this))
	};
	return VideoPopup
}(KDView);
var LikeView, LikeViewClean, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LikeView = function (_super) {
	function LikeView(options, data) {
		null == options && (options = {});
		options.tagName || (options.tagName = "span");
		options.cssClass || (options.cssClass = "like-view");
		options.tooltipPosition || (options.tooltipPosition = "se");
		null == options.checkIfLikedBefore && (options.checkIfLikedBefore = !1);
		null == options.useTitle && (options.useTitle = !0);
		LikeView.__super__.constructor.call(this, options, data);
		this._lastUpdatedCount = -1;
		this._currentState = !1;
		this.likeCount = new ActivityLikeCount({
			tooltip: {
				gravity: options.tooltipPosition,
				title: ""
			},
			bind: "mouseenter",
			mouseenter: function (_this) {
				return function () {
					return _this.fetchLikeInfo()
				}
			}(this),
			attributes: {
				href: "#"
			},
			click: function (_this) {
				return function (event) {
					KD.utils.stopDOMEvent(event);
					return data.meta.likes > 0 ? data.fetchLikedByes({}, {
						sort: {
							timestamp: -1
						}
					}, function (err, likes) {
						return new ShowMoreDataModalView({
							title: "Members who liked <cite>" + _this.utils.expandTokens(data.body, data) + "</cite>"
						}, likes)
					}) : void 0
				}
			}(this)
		}, data);
		this.likeLink = new ActivityActionLink({
			partial: "Like"
		});
		null != options.checkIfLikedBefore && KD.isLoggedIn() && "function" == typeof data.checkIfLikedBefore && data.checkIfLikedBefore(function (_this) {
			return function (err, likedBefore) {
				var useTitle;
				useTitle = _this.getOptions().useTitle;
				if (likedBefore) {
					_this.setClass("liked");
					useTitle && _this.likeLink.updatePartial("Unlike")
				} else {
					_this.unsetClass("liked");
					useTitle && _this.likeLink.updatePartial("Like")
				}
				return _this._currentState = likedBefore
			}
		}(this))
	}
	__extends(LikeView, _super);
	LikeView.prototype.fetchLikeInfo = function () {
		var data;
		data = this.getData();
		if (this._lastUpdatedCount !== data.meta.likes) {
			this.likeCount.getTooltip().update({
				title: "Loading..."
			});
			if (0 !== data.meta.likes) return data.fetchLikedByes({}, {
				limit: 3,
				sort: {
					timestamp: -1
				}
			}, function (_this) {
				return function (err, likes) {
					var andMore, guests, item, likers, name, sep, strong, tooltip, users, _i, _len;
					users = [];
					likers = [];
					guests = 0;
					if (likes) {
						strong = function (x) {
							return "<strong>" + x + "</strong>"
						};
						for (_i = 0, _len = likes.length; _len > _i; _i++) {
							item = likes[_i];
							name = KD.utils.getFullnameFromAccount(item);
							likers.push("" + strong(name));
							"unregistered" === item.type ? guests++ : users.push("" + strong(name))
						}
						if (data.meta.likes > 3) {
							sep = ", ";
							andMore = "and <strong>" + (data.meta.likes - 3) + " more.</strong>"
						} else {
							sep = " and ";
							andMore = ""
						}
						tooltip = function () {
							switch (data.meta.likes) {
							case 0:
								return "";
							case 1:
								return "" + likers[0];
							case 2:
								return 2 === guests ? "" + strong("2 guests") : "" + likers[0] + " and " + likers[1];
							default:
								switch (guests) {
								case 3:
									return "" + strong("3 guests") + " " + andMore;
								case 2:
									return "" + users[0] + sep + strong("2 guests") + " " + andMore;
								default:
									return "" + likers[0] + ", " + likers[1] + sep + likers[2] + " " + andMore
								}
							}
						}();
						_this.likeCount.getTooltip().update({
							title: tooltip
						});
						return _this._lastUpdatedCount = data.meta.likes
					}
				}
			}(this));
			this.unsetClass("liked")
		}
	};
	LikeView.prototype.click = function (event) {
		event.preventDefault();
		return $(event.target).is("a.action-link") ? this.getData().like(function (_this) {
			return function (err) {
				var useTitle;
				KD.showError(err, {
					AccessDenied: "You are not allowed to like activities",
					KodingError: "Something went wrong while like"
				});
				if (!err) {
					_this._currentState = !_this._currentState;
					useTitle = _this.getOptions().useTitle;
					if (_this._currentState) {
						_this.setClass("liked");
						useTitle && _this.likeLink.updatePartial("Unlike");
						KD.mixpanel("Activity like, success");
						KD.getSingleton("badgeController").checkBadge({
							source: "JNewStatusUpdate",
							property: "likes",
							relType: "like",
							targetSelf: 1
						})
					} else {
						_this.unsetClass("liked");
						useTitle && _this.likeLink.updatePartial("Like");
						KD.mixpanel("Activity unlike, success")
					}
					return _this._lastUpdatedCount = -1
				}
			}
		}(this)) : void 0
	};
	LikeView.prototype.pistachio = function () {
		return "{{> this.likeLink}}{{> this.likeCount}}"
	};
	return LikeView
}(JView);
LikeViewClean = function (_super) {
	function LikeViewClean() {
		LikeViewClean.__super__.constructor.apply(this, arguments);
		this.likeLink.updatePartial("Like")
	}
	__extends(LikeViewClean, _super);
	LikeViewClean.prototype.pistachio = function () {
		return "<span class='comment-actions'>{{> this.likeLink}}{{> this.likeCount}}</span>"
	};
	return LikeViewClean
}(LikeView);
var ShowMoreDataModalView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
ShowMoreDataModalView = function (_super) {
	function ShowMoreDataModalView(options, data) {
		var css, participants;
		null == options && (options = {});
		participants = data;
		if (participants[0] instanceof KD.remote.api.JAccount) {
			this.type = "account";
			css = "modal-topic-wrapper"
		} else if (participants[0] instanceof KD.remote.api.JTag) {
			this.type = "tag";
			css = "modal-topic-wrapper"
		} else {
			this.type = "app";
			css = "modal-applications-wrapper"
		}
		options.title || (options.title = titleMap()[this.type]);
		options.height = "auto";
		options.overlay = !0;
		options.width || (options.width = 540);
		options.cssClass = css;
		options.buttons = {
			Close: {
				style: "modal-clean-gray",
				callback: function (_this) {
					return function () {
						return _this.destroy()
					}
				}(this)
			}
		};
		ShowMoreDataModalView.__super__.constructor.apply(this, arguments)
	}
	var listControllerMap, listItemMap, titleMap;
	__extends(ShowMoreDataModalView, _super);
	titleMap = function () {
		return {
			account: "Members",
			tag: "Topics",
			app: "Applications"
		}
	};
	listControllerMap = function () {
		return {
			account: KDListViewController,
			tag: KDListViewController,
			app: KDListViewController
		}
	};
	listItemMap = function () {
		return {
			account: MembersListItemView,
			tag: ModalTopicsListItem,
			app: ModalAppsListItemView
		}
	};
	ShowMoreDataModalView.prototype.viewAppended = function () {
		this.addSubView(this.loader = new KDLoaderView({
			size: {
				width: 30
			},
			loaderOptions: {
				color: "#cccccc",
				shape: "spiral",
				diameter: 30,
				density: 30,
				range: .4,
				speed: 1,
				FPS: 24
			}
		}));
		this.loader.show();
		this.prepareList();
		return this.setPositions()
	};
	ShowMoreDataModalView.prototype.putList = function (participants) {
		this.controller = new KDListViewController({
			view: new KDListView({
				itemClass: listItemMap()[this.type],
				cssClass: "modal-topic-list"
			})
		}, {
			items: participants
		});
		this.controller.getListView().on("CloseTopicsModal", function (_this) {
			return function () {
				return _this.destroy()
			}
		}(this));
		this.controller.on("AllItemsAddedToList", function (_this) {
			return function () {
				var item;
				"tag" === _this.type && _this.reviveFollowButtons(function () {
					var _i, _len, _results;
					_results = [];
					for (_i = 0, _len = participants.length; _len > _i; _i++) {
						item = participants[_i];
						_results.push(item.getId())
					}
					return _results
				}());
				return _this.loader.destroy()
			}
		}(this));
		return this.addSubView(this.controller.getView())
	};
	ShowMoreDataModalView.prototype.reviveFollowButtons = function (ids) {
		return KD.remote.api.JTag.fetchMyFollowees(ids, function (_this) {
			return function (err, followees) {
				var button, id, modal, _i, _len, _ref, _ref1, _results;
				_ref = _this.controller.getItemsOrdered();
				_results = [];
				for (_i = 0, _len = _ref.length; _len > _i; _i++) {
					modal = _ref[_i];
					button = modal.followButton;
					id = null != button && null != (_ref1 = button.getData()) ? _ref1.getId() : void 0;
					_results.push(id && __indexOf.call(followees, id) >= 0 ? button.setState("Following") : void 0)
				}
				return _results
			}
		}(this))
	};
	ShowMoreDataModalView.prototype.prepareList = function () {
		var group;
		group = this.getOptions().group;
		return group ? KD.remote.cacheable(group, function (_this) {
			return function (err, participants) {
				return err ? warn(err) : _this.putList(participants)
			}
		}(this)) : this.putList(this.getData())
	};
	return ShowMoreDataModalView
}(KDModalView);
var SkillTagFormView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
SkillTagFormView = function (_super) {
	function SkillTagFormView(options, data) {
		var _base;
		null == options && (options = {});
		options.cssClass = "kdautocomplete-form";
		SkillTagFormView.__super__.constructor.call(this, options, null);
		this.memberData = data;
		(_base = this.memberData).skillTags || (_base.skillTags = [])
	}
	__extends(SkillTagFormView, _super);
	SkillTagFormView.prototype.showForm = function () {
		if (!this.hasClass("active")) {
			this.setClass("active");
			return this.focusFirstElement()
		}
	};
	SkillTagFormView.prototype.viewAppended = function () {
		var tagWrapper;
		SkillTagFormView.__super__.viewAppended.apply(this, arguments);
		this.parent.on("EditingModeToggled", function (_this) {
			return function (state) {
				return state ? _this.showForm() : _this.unsetClass("active")
			}
		}(this));
		this.addSubView(tagWrapper = new KDCustomHTMLView({
			tagName: "div",
			cssClass: "form-actions-holder clearfix"
		}));
		tagWrapper.addSubView(this.label = new KDLabelView({
			cssClass: "skilltagslabel",
			title: "SKILLS",
			"for": "skillTagsInput",
			click: function (_this) {
				return function () {
					return _this.parent.setEditingMode(!0)
				}
			}(this)
		}));
		tagWrapper.addSubView(this.tip = new KDCustomHTMLView({
			tagName: "span",
			cssClass: "tip hidden",
			pistachio: "Adding skills help others to find you more easily."
		}));
		0 === this.memberData.skillTags.length && this.tip.show();
		tagWrapper.addSubView(this.loader = new KDLoaderView({
			size: {
				width: 14
			}
		}));
		this.tagController = new SkillTagAutoCompleteController({
			name: "skillTagsInput",
			cssClass: "skilltag-form",
			type: "tags",
			itemDataPath: "title",
			itemClass: TagAutoCompleteItemView,
			selectedItemClass: SkillTagAutoCompletedItem,
			outputWrapper: tagWrapper,
			selectedItemsLimit: 10,
			form: this,
			view: new KDAutoComplete({
				placeholder: "Add a skill...",
				name: "skillTagsInput"
			}),
			dataSource: function (_this) {
				return function (_arg, callback) {
					var blacklist, data, inputValue;
					inputValue = _arg.inputValue;
					blacklist = function () {
						var _i, _len, _ref, _results;
						_ref = this.tagController.getSelectedItemData();
						_results = [];
						for (_i = 0, _len = _ref.length; _len > _i; _i++) {
							data = _ref[_i];
							"function" == typeof data.getId && _results.push(data.getId())
						}
						return _results
					}.call(_this);
					return _this.emit("AutoCompleteNeedsTagData", {
						inputValue: inputValue,
						blacklist: blacklist,
						callback: callback
					})
				}
			}(this)
		});
		this.tagController.on("ItemListChanged", function (_this) {
			return function () {
				var skillTags;
				_this.loader.show();
				skillTags = _this.getData().skillTags;
				return _this.memberData.addTags(skillTags, function (err) {
					var skillTagsFlat;
					if (err) return KD.notify_("There was an error while adding new skills.");
					skillTagsFlat = skillTags.map(function (tag) {
						var _ref;
						return null != (_ref = tag.$suggest) ? _ref : tag.title
					});
					skillTagsFlat.length ? _this.tip.hide() : _this.tip.show();
					return _this.memberData.modify({
						skillTags: skillTagsFlat
					}, function (err) {
						err && KD.notify_("There was an error updating your skills.");
						_this.memberData.emit("update");
						return _this.loader.hide()
					})
				})
			}
		}(this));
		this.addSubView(this.tagController.getView());
		return this.tagController.putDefaultValues(this.memberData.skillTags)
	};
	SkillTagFormView.prototype.mouseDown = function () {
		return !1
	};
	return SkillTagFormView
}(KDFormView);
var SkillTagAutoCompleteController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
SkillTagAutoCompleteController = function (_super) {
	function SkillTagAutoCompleteController(options, data) {
		null == options && (options = {});
		options.nothingFoundItemClass || (options.nothingFoundItemClass = SuggestNewTagItem);
		null == options.allowNewSuggestions && (options.allowNewSuggestions = !0);
		SkillTagAutoCompleteController.__super__.constructor.call(this, options, data)
	}
	__extends(SkillTagAutoCompleteController, _super);
	SkillTagAutoCompleteController.prototype.putDefaultValues = function (stringTags) {
		return KD.remote.api.JTag.fetchSkillTags({
			title: {
				$in: stringTags
			}
		}, {
			sort: {
				title: 1
			}
		}, function (_this) {
			return function (err, tags) {
				return !err || tags ? _this.setDefaultValue(tags) : warn("There was a problem fetching default tags!", err, tags)
			}
		}(this))
	};
	SkillTagAutoCompleteController.prototype.getCollectionPath = function () {
		return "skillTags"
	};
	return SkillTagAutoCompleteController
}(KDAutoCompleteController);
var SkillTagAutoCompletedItem, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
SkillTagAutoCompletedItem = function (_super) {
	function SkillTagAutoCompletedItem(options, data) {
		null == options && (options = {});
		options.cssClass = "clearfix";
		SkillTagAutoCompletedItem.__super__.constructor.call(this, options, data);
		this.tag = new TagLinkView({}, this.getData())
	}
	__extends(SkillTagAutoCompletedItem, _super);
	JView.mixin(SkillTagAutoCompletedItem.prototype);
	SkillTagAutoCompletedItem.prototype.pistachio = function () {
		return "{{> this.tag}}"
	};
	SkillTagAutoCompletedItem.prototype.click = function (event) {
		var delegate;
		delegate = this.getDelegate();
		$(event.target).is("span.close-icon") && delegate.removeFromSubmitQueue(this);
		return delegate.getView().$input().trigger(event)
	};
	return SkillTagAutoCompletedItem
}(KDAutoCompletedItem);
var MessagesListController, MessagesListItemView, MessagesListView, NotificationListItem, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
MessagesListItemView = function (_super) {
	function MessagesListItemView() {
		MessagesListItemView.__super__.constructor.apply(this, arguments)
	}
	__extends(MessagesListItemView, _super);
	MessagesListItemView.prototype.partial = function (data) {
		return "<div>" + (data.subject || "(No title)") + "</div>"
	};
	return MessagesListItemView
}(KDListItemView);
MessagesListView = function (_super) {
	function MessagesListView() {
		return MessagesListView.__super__.constructor.apply(this, arguments)
	}
	__extends(MessagesListView, _super);
	return MessagesListView
}(KDListView);
MessagesListController = function (_super) {
	function MessagesListController(options, data) {
		options.itemClass || (options.itemClass = MessagesListItemView);
		options.listView || (options.listView = new MessagesListView);
		options.startWithLazyLoader = !0;
		options.lazyLoaderOptions = {
			partial: "",
			spinnerOptions: {
				loaderOptions: {
					color: "#6BB197"
				},
				size: {
					width: 32
				}
			}
		};
		MessagesListController.__super__.constructor.call(this, options, data);
		this.getListView().on("AvatarPopupShouldBeHidden", function (_this) {
			return function () {
				return _this.emit("AvatarPopupShouldBeHidden")
			}
		}(this))
	}
	__extends(MessagesListController, _super);
	MessagesListController.prototype.fetchMessages = function (callback) {
		return KD.isLoggedIn() ? KD.getSingleton("appManager").tell("Inbox", "fetchMessages", {
			limit: 3,
			sort: {
				timestamp: -1
			}
		}, function (_this) {
			return function (err, messages) {
				var message, unreadCount, _i, _len, _ref;
				_this.removeAllItems();
				_this.instantiateListItems(messages);
				unreadCount = 0;
				for (_i = 0, _len = messages.length; _len > _i; _i++) {
					message = messages[_i];
					(null != (_ref = message.flags_) ? _ref.read : void 0) || unreadCount++
				}
				_this.emit("MessageCountDidChange", unreadCount);
				_this.hideLazyLoader();
				return "function" == typeof callback ? callback(err, messages) : void 0
			}
		}(this)) : "function" == typeof callback ? callback(!0) : void 0
	};
	MessagesListController.prototype.fetchNotificationTeasers = function (callback) {
		var _base;
		return "function" == typeof (_base = KD.whoami()).fetchActivityTeasers ? _base.fetchActivityTeasers({
			targetName: {
				$in: ["CReplieeBucketActivity", "CFolloweeBucketActivity", "CLikeeBucketActivity", "CGroupJoineeBucketActivity", "CNewMemberBucketActivity", "CGroupLeaveeBucketActivity"]
			}
		}, {
			limit: 8,
			sort: {
				timestamp: -1
			}
		}, function (_this) {
			return function (err, items) {
				var unglanced;
				if (err) warn("There was a problem fetching notifications!", err);
				else {
					unglanced = items.filter(function (item) {
						return item.getFlagValue("glanced") !== !0
					});
					_this.emit("NotificationCountDidChange", unglanced.length);
					"function" == typeof callback && callback(items)
				}
				return _this.hideLazyLoader()
			}
		}(this)) : void 0
	};
	return MessagesListController
}(KDListViewController);
NotificationListItem = function (_super) {
	function NotificationListItem(options, data) {
		var group, member, myid, _ref;
		null == options && (options = {});
		options.tagName || (options.tagName = "li");
		options.linkGroupClass || (options.linkGroupClass = LinkGroup);
		options.avatarClass || (options.avatarClass = AvatarView);
		NotificationListItem.__super__.constructor.call(this, options, data);
		this.setClass(bucketNameMap[data.bongo_.constructorName]);
		this.snapshot = JSON.parse(Encoder.htmlDecode(data.snapshot));
		group = this.snapshot.group;
		myid = null != (_ref = KD.whoami()) ? _ref.getId() : void 0;
		if (myid) {
			this.group = function () {
				var _i, _len, _results;
				_results = [];
				for (_i = 0, _len = group.length; _len > _i; _i++) {
					member = group[_i];
					member.id !== myid && _results.push(member)
				}
				return _results
			}();
			this.participants = new options.linkGroupClass({
				group: this.group
			});
			this.avatar = new options.avatarClass({
				size: {
					width: 40,
					height: 40
				},
				origin: this.group[0]
			});
			this.interactedGroups = "JGroup" === this.snapshot.anchor.constructorName ? new options.linkGroupClass({
				itemClass: GroupLinkView,
				group: [this.snapshot.anchor.data]
			}) : new KDCustomHTMLView;
			this.activityPlot = new KDCustomHTMLView({
				tagName: "span"
			});
			this.timeAgoView = new KDTimeAgoView(null, this.getLatestTimeStamp(this.getData().dummy))
		}
	}
	var actionPhraseMap, activityNameMap, bucketNameMap;
	__extends(NotificationListItem, _super);
	JView.mixin(NotificationListItem.prototype);
	activityNameMap = {
		JNewStatusUpdate: "status.",
		JStatusUpdate: "your status update.",
		JCodeSnip: "your status update.",
		JAccount: "started following you.",
		JPrivateMessage: "your private message.",
		JComment: "your comment.",
		JDiscussion: "your discussion.",
		JOpinion: "your opinion.",
		JReview: "your review.",
		JGroup: "your group"
	};
	bucketNameMap = {
		CReplieeBucketActivity: "comment",
		CFolloweeBucketActivity: "follow",
		CLikeeBucketActivity: "like",
		CGroupJoineeBucketActivity: "groupJoined",
		CGroupLeaveeBucketActivity: "groupLeft"
	};
	actionPhraseMap = {
		comment: "commented on",
		reply: "replied to",
		like: "liked",
		follow: "",
		share: "shared",
		commit: "committed",
		member: "joined",
		groupJoined: "joined",
		groupLeft: "left"
	};
	NotificationListItem.prototype.viewAppended = function () {
		return this.getActivityPlot(function (_this) {
			return function (err) {
				if (err) return KD.showError(err);
				_this.setTemplate(_this.pistachio());
				return _this.template.update()
			}
		}(this))
	};
	NotificationListItem.prototype.pistachio = function () {
		return "<div class='avatar-wrapper fl'>\n  {{> this.avatar}}\n</div>\n<div class='right-overflow'>\n  <p>{{> this.participants}} {{this.getActionPhrase(#(dummy))}} {{> this.activityPlot}} {{> this.interactedGroups}}</p>\n  <footer>\n    {{> this.timeAgoView}}\n  </footer>\n</div>"
	};
	NotificationListItem.prototype.getLatestTimeStamp = function () {
		var data, lastUpdateAt;
		data = this.getData();
		lastUpdateAt = this.snapshot.group.modifiedAt;
		return lastUpdateAt || data.createdAt
	};
	NotificationListItem.prototype.getActionPhrase = function () {
		var data;
		data = this.getData();
		if ("JPrivateMessage" === this.snapshot.anchor.constructorName) {
			this.unsetClass("comment");
			this.setClass("reply");
			return actionPhraseMap.reply
		}
		return actionPhraseMap[bucketNameMap[data.bongo_.constructorName]]
	};
	NotificationListItem.prototype.getActivityPlot = function (callback) {
		var constructorName, data, id, _ref;
		null == callback && (callback = function () {});
		data = this.getData();
		_ref = this.snapshot.anchor, constructorName = _ref.constructorName, id = _ref.id;
		if ("JNewStatusUpdate" === constructorName) return KD.remote.cacheable(constructorName, id, function (_this) {
			return function (err, post) {
				return err || !post ? callback(err) : KD.remote.cacheable("JAccount", post.originId, function (err, origin) {
					var adjective, originatorName, _ref1;
					if (err || !origin) return callback(err);
					originatorName = KD.utils.getFullnameFromAccount(origin);
					adjective = post.originId === (null != (_ref1 = KD.whoami()) ? _ref1.getId() : void 0) ? "your" : 1 === _this.group.length && _this.group[0].id === origin.getId() ? "their own" : "" + originatorName + "'s";
					_this.activityPlot.updatePartial("" + adjective + " " + activityNameMap[constructorName]);
					return callback()
				})
			}
		}(this));
		this.activityPlot.updatePartial(activityNameMap[this.snapshot.anchor.constructorName]);
		return callback()
	};
	NotificationListItem.prototype.click = function () {
		var appManager, showPost, _ref, _ref1;
		showPost = function (err, post) {
			var groupSlug, internalApp;
			err && warn(err);
			if (post) {
				internalApp = "JNewApp" === post.constructor.name ? "Apps" : "Activity";
				groupSlug = "koding" === post.group ? "" : "/" + post.group;
				return KD.getSingleton("router").handleRoute("" + groupSlug + "/" + internalApp + "/" + post.slug, {
					state: post
				})
			}
			return new KDNotificationView({
				title: "This post has been deleted!",
				duration: 1e3
			})
		};
		switch (this.snapshot.anchor.constructorName) {
		case "JPrivateMessage":
			appManager = KD.getSingleton("appManager");
			appManager.open("Inbox");
			return appManager.tell("Inbox", "goToMessages");
		case "JComment":
		case "JReview":
		case "JOpinion":
			return null != (_ref = KD.remote.api[this.snapshot.anchor.constructorName]) ? _ref.fetchRelated(this.snapshot.anchor.id, showPost) : void 0;
		case "JAccount":
			return KD.remote.api.JAccount.one({
				_id: this.snapshot.group[0].id
			}, function (err, account) {
				return KD.getSingleton("router").handleRoute("/" + account.profile.nickname)
			});
		case "JGroup":
			break;
		default:
			if ("JAccount" !== this.snapshot.anchor.constructorName) return null != (_ref1 = KD.remote.api[this.snapshot.anchor.constructorName]) ? _ref1.one({
				_id: this.snapshot.anchor.id
			}, showPost) : void 0
		}
	};
	return NotificationListItem
}(KDListItemView);
var SplitViewWithOlderSiblings, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
SplitViewWithOlderSiblings = function (_super) {
	function SplitViewWithOlderSiblings() {
		return SplitViewWithOlderSiblings.__super__.constructor.apply(this, arguments)
	}
	__extends(SplitViewWithOlderSiblings, _super);
	SplitViewWithOlderSiblings.prototype.viewAppended = function () {
		var index, siblings;
		SplitViewWithOlderSiblings.__super__.viewAppended.apply(this, arguments);
		siblings = this.parent.getSubViews();
		index = siblings.indexOf(this);
		return this._olderSiblings = siblings.slice(0, index)
	};
	SplitViewWithOlderSiblings.prototype._windowDidResize = function () {
		var newH, offset, olderSibling, siblingStyle, _i, _len, _ref;
		SplitViewWithOlderSiblings.__super__._windowDidResize.apply(this, arguments);
		offset = 0;
		_ref = this._olderSiblings;
		for (_i = 0, _len = _ref.length; _len > _i; _i++) {
			olderSibling = _ref[_i];
			siblingStyle = window.getComputedStyle(olderSibling.getElement());
			"absolute" !== siblingStyle.position && (offset += olderSibling.getHeight())
		}
		newH = this.parent.getHeight() - offset;
		return this.setHeight(newH)
	};
	return SplitViewWithOlderSiblings
}(SplitView);
var ContentPageSplitBelowHeader, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ContentPageSplitBelowHeader = function (_super) {
	function ContentPageSplitBelowHeader() {
		return ContentPageSplitBelowHeader.__super__.constructor.apply(this, arguments)
	}
	__extends(ContentPageSplitBelowHeader, _super);
	ContentPageSplitBelowHeader.prototype.viewAppended = function () {
		var panel0, panel1, _ref;
		ContentPageSplitBelowHeader.__super__.viewAppended.apply(this, arguments);
		_ref = this.panels, panel0 = _ref[0], panel1 = _ref[1];
		panel0.setClass("toggling");
		panel0.addSubView(this._toggler = new KDCustomHTMLView({
			tagName: "span",
			cssClass: "generic-menu-toggler",
			click: this.bound("toggleFirstPanel")
		}));
		panel0.on("click", function (_this) {
			return function (event) {
				return panel0.$().hasClass("collapsed") ? _this.toggleFirstPanel(event) : void 0
			}
		}(this));
		return panel1.on("PanelDidResize", function (_this) {
			return function () {
				return _this.setRightColumnClass()
			}
		}(this))
	};
	ContentPageSplitBelowHeader.prototype.toggleFirstPanel = function (event) {
		var $panel;
		$panel = this.panels[0].$();
		if ($panel.hasClass("collapsed")) {
			$panel.removeClass("collapsed");
			this.resizePanel(139, 0)
		} else this.resizePanel(10, 0, function () {
			return $panel.addClass("collapsed")
		});
		return event.stopPropagation()
	};
	ContentPageSplitBelowHeader.prototype._windowDidResize = function () {
		ContentPageSplitBelowHeader.__super__._windowDidResize.apply(this, arguments);
		return this.setRightColumnClass()
	};
	ContentPageSplitBelowHeader.prototype.setRightColumnClass = function () {
		var col, w;
		col = this.panels[1];
		col.unsetClass("extra-wide wide medium narrow extra-narrow");
		w = col.size;
		return col.setClass(w > 1200 ? "extra-wide" : w > 900 && 1200 > w ? "wide" : w > 600 && 900 > w ? "medium" : w > 300 && 600 > w ? "narrow" : "extra-narrow")
	};
	return ContentPageSplitBelowHeader
}(SplitViewWithOlderSiblings);
var CommonListHeader, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
CommonListHeader = function (_super) {
	function CommonListHeader(options, data) {
		null == options && (options = {});
		options.tagName = "header";
		options.cssClass = "feeder-header clearfix";
		CommonListHeader.__super__.constructor.call(this, options, data)
	}
	__extends(CommonListHeader, _super);
	CommonListHeader.prototype.viewAppended = function () {
		this.setPartial("<p>" + this.getOptions().title + "</p> <span></span>");
		return this.emit("ready")
	};
	return CommonListHeader
}(KDView);
var CommonInnerNavigation, CommonInnerNavigationList, CommonInnerNavigationListController, CommonInnerNavigationListItem, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
CommonInnerNavigation = function (_super) {
	function CommonInnerNavigation(options, data) {
		null == options && (options = {});
		options.tagName = "aside";
		options.cssClass = KD.utils.curry("common-inner-nav", options.cssClass);
		CommonInnerNavigation.__super__.constructor.call(this, options, data)
	}
	__extends(CommonInnerNavigation, _super);
	CommonInnerNavigation.prototype.setListController = function (options, data, isSorter) {
		var controller;
		null == isSorter && (isSorter = !1);
		controller = new CommonInnerNavigationListController(options, data);
		controller.getListView().on("NavItemReceivedClick", function (_this) {
			return function (data) {
				return _this.emit("NavItemReceivedClick", data)
			}
		}(this));
		isSorter && (this.sortController = controller);
		return controller
	};
	CommonInnerNavigation.prototype.selectSortItem = function (sortType) {
		var item, itemToBeSelected, _i, _len, _ref;
		if (this.sortController) {
			itemToBeSelected = null;
			_ref = this.sortController.itemsOrdered;
			for (_i = 0, _len = _ref.length; _len > _i; _i++) {
				item = _ref[_i];
				item.getData().type === sortType && (itemToBeSelected = item)
			}
			return itemToBeSelected ? this.sortController.selectItem(itemToBeSelected) : void 0
		}
	};
	return CommonInnerNavigation
}(KDView);
CommonInnerNavigationListController = function (_super) {
	function CommonInnerNavigationListController(options, data) {
		var listView;
		null == options && (options = {});
		options.viewOptions || (options.viewOptions = {
			itemClass: options.itemClass || CommonInnerNavigationListItem
		});
		null == options.scrollView && (options.scrollView = !1);
		null == options.wrapper && (options.wrapper = !1);
		options.view || (options.view = new CommonInnerNavigationList(options.viewOptions));
		CommonInnerNavigationListController.__super__.constructor.call(this, options, data);
		listView = this.getListView();
		listView.on("ItemWasAdded", function (_this) {
			return function (view) {
				return view.on("click", function () {
					if (!view.getData().disabledForBeta) {
						_this.selectItem(view);
						_this.emit("NavItemReceivedClick", view.getData());
						return listView.emit("NavItemReceivedClick", view.getData())
					}
				})
			}
		}(this))
	}
	__extends(CommonInnerNavigationListController, _super);
	CommonInnerNavigationListController.prototype.loadView = function (mainView) {
		var list;
		list = this.getListView();
		mainView.setClass("list");
		mainView.addSubView(new KDHeaderView({
			size: "small",
			title: this.getData().title,
			cssClass: "list-group-title"
		}));
		mainView.addSubView(list);
		return this.instantiateListItems(this.getData().items || [])
	};
	return CommonInnerNavigationListController
}(NavigationController);
CommonInnerNavigationList = function (_super) {
	function CommonInnerNavigationList(options, data) {
		null == options && (options = {});
		options.tagName || (options.tagName = "nav");
		options.type = "inner-nav";
		CommonInnerNavigationList.__super__.constructor.call(this, options, data)
	}
	__extends(CommonInnerNavigationList, _super);
	return CommonInnerNavigationList
}(KDListView);
CommonInnerNavigationListItem = function (_super) {
	function CommonInnerNavigationListItem(options, data) {
		null == options && (options = {});
		options.tagName || (options.tagName = "a");
		options.attributes = {
			href: data.slug || "#"
		};
		options.partial || (options.partial = data.title);
		CommonInnerNavigationListItem.__super__.constructor.call(this, options, data)
	}
	__extends(CommonInnerNavigationListItem, _super);
	CommonInnerNavigationListItem.prototype.partial = function () {
		return ""
	};
	return CommonInnerNavigationListItem
}(KDListItemView);
var HeaderViewSection, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
HeaderViewSection = function (_super) {
	function HeaderViewSection() {
		HeaderViewSection.__super__.constructor.apply(this, arguments);
		this.setClass("header-view-section")
	}
	__extends(HeaderViewSection, _super);
	HeaderViewSection.prototype.setTitle = function (title) {
		return this.$().append("<cite></cite> <span class='section-title'>" + title + "</span>")
	};
	HeaderViewSection.prototype.setSearchInput = function (options) {
		var icon, _ref;
		null == options && (options = {});
		null != (_ref = this.searchInput) && _ref.destroy();
		this.addSubView(this.searchInput = new KDHitEnterInputView({
			placeholder: options.placeholder || "Search...",
			name: options.name || "searchInput",
			cssClass: options.cssClass || "header-search-input",
			type: "text",
			callback: function (_this) {
				return function () {
					_this.parent.emit("searchFilterChanged", _this.searchInput.getValue());
					return _this.searchInput.focus()
				}
			}(this),
			keyup: function (_this) {
				return function () {
					return "" === _this.searchInput.getValue() ? _this.parent.emit("searchFilterChanged", "") : void 0
				}
			}(this)
		}));
		return this.addSubView(icon = new KDCustomHTMLView({
			tagName: "span",
			cssClass: "header-search-input-icon"
		}))
	};
	return HeaderViewSection
}(KDHeaderView);
var HelpBox, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
HelpBox = function (_super) {
	function HelpBox(options, data) {
		null == options && (options = {});
		null == data && (data = {});
		options.cssClass || (options.cssClass = "help-box");
		options.title || (options.title = "NEED HELP?");
		options.subtitle || (options.subtitle = "Learn about sharing");
		data.title = options.title;
		data.subtitle = options.subtitle;
		HelpBox.__super__.constructor.call(this, options, data)
	}
	__extends(HelpBox, _super);
	HelpBox.prototype.click = function () {
		var bookIndex, mainController;
		bookIndex = this.getOptions().bookIndex;
		if (bookIndex) {
			mainController = KD.getSingleton("mainController");
			return mainController.emit("ShowInstructionsBook", bookIndex)
		}
	};
	HelpBox.prototype.pistachio = function () {
		return '<span></span>\n<div>\n  {cite{#(title)}}\n  <a href="#">{{#(subtitle)}}</a>\n</div>'
	};
	return HelpBox
}(JView);
var KeySetView, KeyView, KeyboardHelperModalView, KeyboardHelperView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
KeyboardHelperView = function (_super) {
	function KeyboardHelperView(options, data) {
		options = $.extend({
			title: "",
			itemClass: KeySetView
		}, options);
		KeyboardHelperView.__super__.constructor.call(this, options, data)
	}
	__extends(KeyboardHelperView, _super);
	KeyboardHelperView.prototype.viewAppended = function () {
		this.getOptions().title && this.setPartial("<li class='title'>" + this.getOptions().title + "</li>");
		return KeyboardHelperView.__super__.viewAppended.apply(this, arguments)
	};
	KeyboardHelperView.prototype.setDomElement = function (cssClass) {
		return this.domElement = $("<ul class='kdview keyboard-helper " + cssClass + "'></ul>")
	};
	return KeyboardHelperView
}(KDListView);
KeySetView = function (_super) {
	function KeySetView() {
		KeySetView.__super__.constructor.apply(this, arguments)
	}
	__extends(KeySetView, _super);
	KeySetView.prototype.setDomElement = function (cssClass) {
		return this.domElement = $("<li class='kdview keyset clearfix " + cssClass + "'></li>")
	};
	KeySetView.prototype.viewAppended = function () {
		var i, keyGroup, keyGroups, keySet, title, _i, _len, _ref;
		_ref = this.getData(), keySet = _ref.keySet, title = _ref.title;
		keyGroups = this.getKeyGroups(keySet);
		for (i = _i = 0, _len = keyGroups.length; _len > _i; i = ++_i) {
			keyGroup = keyGroups[i];
			this.createKeyGroup(keyGroup);
			i !== keyGroups.length - 1 && this.setPartial("<cite>+</cite>")
		}
		return this.setPartial("<h6>" + title + "</h6>")
	};
	KeySetView.prototype.getKeyGroups = function (keySet) {
		var group, groups, i, keyGroups;
		keyGroups = keySet.split("+");
		return groups = function () {
			var _i, _len, _results;
			_results = [];
			for (i = _i = 0, _len = keyGroups.length; _len > _i; i = ++_i) {
				group = keyGroups[i];
				_results.push(group = /,/.test(group) ? group.split(",") : [group])
			}
			return _results
		}()
	};
	KeySetView.prototype.createKeyGroup = function (keyGroup) {
		var key, _i, _len, _results;
		_results = [];
		for (_i = 0, _len = keyGroup.length; _len > _i; _i++) {
			key = keyGroup[_i];
			_results.push(this.addSubView(new KeyView(null, key)))
		}
		return _results
	};
	return KeySetView
}(KDListItemView);
KeyView = function (_super) {
	function KeyView(options, data) {
		options = $.extend({
			tagName: "span",
			cssClass: "keyview"
		}, options);
		KeyView.__super__.constructor.call(this, options, data)
	}
	var sanitizePrinting;
	__extends(KeyView, _super);
	sanitizePrinting = function (text) {
		var metaKey, optionKey;
		if (/Macintosh/.test(navigator.userAgent)) {
			metaKey = "\u2318";
			optionKey = "option"
		} else {
			metaKey = "ctrl";
			optionKey = "alt"
		}
		switch (text) {
		case "cmd":
			return metaKey;
		case "option":
			return optionKey;
		case "up":
			return "\u2191";
		case "down":
			return "\u2193";
		case "left":
			return "\u2190";
		case "right":
			return "\u2192";
		default:
			return text
		}
	};
	KeyView.prototype.viewAppended = function () {
		var printing, text;
		text = this.getData();
		printing = sanitizePrinting(text);
		this.setPartial(printing);
		this.setClass("key-" + text);
		return printing.length > 1 ? this.setClass("large") : void 0
	};
	return KeyView
}(KDCustomHTMLView);
KeyboardHelperModalView = function (_super) {
	function KeyboardHelperModalView(options, data) {
		options = $.extend({
			overlay: !1,
			height: 300,
			width: 400,
			title: null,
			content: null,
			cssClass: "",
			buttons: null,
			fx: !1,
			view: null,
			draggable: null,
			resizable: !1
		}, options);
		options.overlay && this.putOverlay(options.overlay);
		KeyboardHelperModalView.__super__.constructor.call(this, options, data);
		options.fx && this.setClass("fx");
		options.content && this.setContent(options.content);
		this.appendToDomBody();
		this.setModalWidth(options.width);
		options.height && this.setModalHeight(options.height);
		this.display();
		this.setPositions();
		$(window).on("keydown.modal", function (_this) {
			return function (e) {
				return 27 === e.which ? _this.destroy() : void 0
			}
		}(this))
	}
	__extends(KeyboardHelperModalView, _super);
	KeyboardHelperModalView.prototype.setDomElement = function (cssClass) {
		return this.domElement = $("<div class='kdmodal keyboard-helper " + cssClass + "'>\n  <span class='close-icon'></span>\n</div>")
	};
	KeyboardHelperModalView.prototype.click = function (e) {
		return $(e.target).is(".close-icon") ? this.destroy() : void 0
	};
	KeyboardHelperModalView.prototype.setTitle = function (title) {
		this.getDomElement().find(".kdmodal-title").append("<span class='title'>" + title + "</span>");
		return this.modalTitle = title
	};
	return KeyboardHelperModalView
}(KDModalView);
var VerifyPINModal, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
VerifyPINModal = function (_super) {
	function VerifyPINModal(buttonTitle, callback) {
		var options;
		null == buttonTitle && (buttonTitle = "Submit");
		options = {
			title: "Please provide the code that we've emailed",
			overlay: !0,
			overlayClick: !1,
			width: 605,
			height: "auto",
			cancel: function (_this) {
				return function () {
					callback(null);
					return _this.destroy()
				}
			}(this),
			tabs: {
				navigable: !0,
				forms: {
					verifyPINForm: {
						callback: function (_this) {
							return function () {
								callback(_this.modalTabs.forms.verifyPINForm.inputs.pin.getValue());
								return _this.destroy()
							}
						}(this),
						buttons: {
							Submit: {
								title: buttonTitle,
								cssClass: "modal-clean-green",
								type: "submit"
							}
						},
						fields: {
							pin: {
								name: "pin",
								placeholder: "Code",
								testPath: "account-email-pin",
								validate: {
									rules: {
										required: !0
									},
									messages: {
										required: "Code required!"
									}
								}
							}
						}
					}
				}
			}
		};
		VerifyPINModal.__super__.constructor.call(this, options)
	}
	__extends(VerifyPINModal, _super);
	return VerifyPINModal
}(KDModalViewWithForms);
var VerifyPasswordModal, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
VerifyPasswordModal = function (_super) {
	function VerifyPasswordModal(buttonTitle, callback) {
		var options;
		null == buttonTitle && (buttonTitle = "Submit");
		options = {
			title: "Please verify your current password ",
			overlay: !0,
			overlayClick: !1,
			width: 605,
			height: "auto",
			cancel: function (_this) {
				return function () {
					callback(null);
					return _this.destroy()
				}
			}(this),
			tabs: {
				navigable: !0,
				forms: {
					verifyPasswordForm: {
						callback: function (_this) {
							return function () {
								callback(_this.modalTabs.forms.verifyPasswordForm.inputs.password.getValue());
								return _this.destroy()
							}
						}(this),
						buttons: {
							Submit: {
								title: buttonTitle,
								cssClass: "modal-clean-green",
								type: "submit"
							},
							Forgot: {
								title: "Forgot Password?",
								callback: function (_this) {
									return function () {
										var entryPoint;
										entryPoint = KD.config.entryPoint;
										KD.singleton("router").handleRoute("/Recover", {
											entryPoint: entryPoint
										});
										return _this.destroy()
									}
								}(this)
							}
						},
						fields: {
							password: {
								name: "password",
								placeholder: "current password",
								type: "password",
								validate: {
									rules: {
										required: !0
									},
									messages: {
										required: "Current Password required!"
									}
								}
							}
						}
					}
				}
			}
		};
		VerifyPasswordModal.__super__.constructor.call(this, options)
	}
	__extends(VerifyPasswordModal, _super);
	return VerifyPasswordModal
}(KDModalViewWithForms);
var FollowButton, MemberFollowToggleButton, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
FollowButton = function (_super) {
	function FollowButton(options, data) {
		var _ref, _ref1, _ref2, _ref3;
		null == options && (options = {});
		options.cssClass = this.utils.curry("follow-btn", options.cssClass);
		options = $.extend({
			defaultState: data.followee ? "Following" : "Follow",
			bind: "mouseenter mouseleave",
			dataPath: "followee",
			loader: {
				color: "#333333"
			},
			states: [{
				title: "Follow",
				cssClass: null != (_ref = options.stateOptions) && null != (_ref1 = _ref.follow) ? _ref1.cssClass : void 0,
				callback: function (_this) {
					return function (cb) {
						return KD.requireMembership({
							tryAgain: !0,
							onFailMsg: "Login required to follow",
							onFail: function () {
								return cb(!0)
							},
							callback: function () {
								var account;
								account = _this.getData();
								return account.follow(function (err, response) {
									account.followee = response;
									KD.getSingleton("badgeController").checkBadge({
										property: "following",
										relType: "follower",
										source: "JAccount",
										targetSelf: 1
									});
									return "function" == typeof cb ? cb(err) : void 0
								})
							}
						})
					}
				}(this)
			}, {
				title: "Following",
				cssClass: null != (_ref2 = options.stateOptions) && null != (_ref3 = _ref2.unfollow) ? _ref3.cssClass : void 0,
				callback: function (_this) {
					return function (cb) {
						return _this.getData().unfollow(function (err, response) {
							KD.showError(err, options.errorMessages);
							_this.getData().followee = response;
							return "function" == typeof cb ? cb(err) : void 0
						})
					}
				}(this)
			}]
		}, options);
		FollowButton.__super__.constructor.call(this, options, data)
	}
	__extends(FollowButton, _super);
	FollowButton.prototype.viewAppended = function () {
		var dataType, _base;
		FollowButton.__super__.viewAppended.apply(this, arguments);
		if (!this.getData().followee) {
			dataType = this.getOptions().dataType;
			if (!dataType) return;
			return "function" == typeof (_base = KD.whoami()).isFollowing ? _base.isFollowing(this.getData().getId(), dataType, function (_this) {
				return function (err, following) {
					_this.getData().followee = following;
					return following ? _this.setState("Following", !1) : void 0
				}
			}(this)) : void 0
		}
	};
	FollowButton.prototype.mouseEnter = function () {
		return "Following" === this.getTitle() ? this.setTitle("Unfollow") : void 0
	};
	FollowButton.prototype.mouseLeave = function () {
		return "Unfollow" === this.getTitle() ? this.setTitle("Following") : void 0
	};
	return FollowButton
}(KDToggleButton);
MemberFollowToggleButton = function (_super) {
	function MemberFollowToggleButton(options, data) {
		null == options && (options = {});
		options = $.extend({
			errorMessages: {
				KodingError: "Something went wrong while follow",
				AccessDenied: "You are not allowed to follow members"
			},
			stateOptions: {
				unfollow: {
					cssClass: "following-btn"
				}
			},
			dataType: "JAccount"
		}, options);
		MemberFollowToggleButton.__super__.constructor.call(this, options, data)
	}
	__extends(MemberFollowToggleButton, _super);
	MemberFollowToggleButton.prototype.decorateState = function () {
		return MemberFollowToggleButton.__super__.decorateState.apply(this, arguments)
	};
	return MemberFollowToggleButton
}(FollowButton);
var MarkdownModal, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
MarkdownModal = function (_super) {
	function MarkdownModal(options, data) {
		null == options && (options = {});
		options = $.extend({
			title: "How to use the <em>Markdown</em> syntax.",
			cssClass: "what-you-should-know-modal markdown-cheatsheet",
			height: "auto",
			overlay: !0,
			width: 500,
			content: this.markdownText(),
			buttons: {
				Close: {
					title: "Close",
					style: "modal-clean-gray",
					callback: function (_this) {
						return function () {
							return _this.destroy()
						}
					}(this)
				}
			}
		}, options);
		if (!KD._markdownHelpModal) {
			KD._markdownHelpModal = this;
			MarkdownModal.__super__.constructor.call(this, options, data)
		}
	}
	__extends(MarkdownModal, _super);
	MarkdownModal.prototype.destroy = function () {
		delete KD._markdownHelpModal;
		return MarkdownModal.__super__.destroy.apply(this, arguments)
	};
	MarkdownModal.prototype.markdownText = function () {
		var text;
		return text = this.markdownTextHTML()
	};
	MarkdownModal.prototype.markdownTextHTML = function () {
		return '<div class=\'modalformline\'>This form supports <a href="http://daringfireball.net/projects/markdown/" target="_blank" title="Markdown project homepage">Markdown</a> and <a href="http://github.github.com/github-flavored-markdown/" target="_blank">GitHub-flavored Markdown</a>. Here is how to use it:</div>\n\n<div class="modalformline markdown-cheatsheet">\n<div class="modal-block">\n<h3>Phrase Emphasis</h3>\n\n<pre><code>*italic*   **bold**\n_italic_   __bold__\n</code></pre>\n</div><div class="modal-block">\n\n<h3>Links</h3>\n\n<p>Inline:</p>\n\n<pre><code>An [example](http://url.com/ "Title")\n</code></pre>\n\n<p>Reference-style labels (titles are optional):</p>\n\n<pre><code>An [example][id]. Then, anywhere\nelse in the doc, define the link:\n\n  [id]: http://example.com/  "Title"\n</code></pre>\n</div><div class="modal-block">\n<h3>Images</h3>\n\n<p>Inline (titles are optional):</p>\n\n<pre><code>![alt text](/path/img.jpg "Title")\n</code></pre>\n\n<p>Reference-style:</p>\n\n<pre><code>![alt text][id]\n\n[id]: /url/to/img.jpg "Title"\n</code></pre>\n</div><div class="modal-block">\n<h3>Headers</h3>\n\n<p>Setext-style:</p>\n\n<pre><code>Header 1\n========\n\nHeader 2\n--------\n</code></pre>\n\n<p>atx-style (closing #\'s are optional):</p>\n\n<pre><code># Header 1 #\n\n## Header 2 ##\n\n###### Header 6\n</code></pre>\n</div><div class="modal-block">\n<h3>Lists</h3>\n\n<p>Ordered, without paragraphs:</p>\n\n<pre><code>1.  Foo\n2.  Bar\n</code></pre>\n\n<p>Unordered, with paragraphs:</p>\n\n<pre><code>*   A list item.\n\n    With multiple paragraphs.\n\n*   Bar\n</code></pre>\n\n<p>You can nest them:</p>\n\n<pre><code>*   Abacus\n    * answer\n*   Bubbles\n    1.  bunk\n    2.  bupkis\n        * BELITTLER\n    3. burper\n*   Cunning\n</code></pre>\n</div><div class="modal-block">\n<h3>Blockquotes</h3>\n\n<pre><code>&gt; Email-style angle brackets\n&gt; are used for blockquotes.\n\n&gt; &gt; And, they can be nested.\n\n&gt; #### Headers in blockquotes\n&gt;\n&gt; * You can quote a list.\n&gt; * Etc.\n</code></pre>\n</div><div class="modal-block">\n<h3>Code Spans</h3>\n\n<pre><code>`&lt;code&gt;` spans are delimited\nby backticks.\n\nYou can include literal backticks\nlike `` `this` ``.\n</code></pre>\n</div><div class="modal-block">\n<h3>Preformatted Code Blocks</h3>\n\n<p>Indent every line of a code block by at least 4 spaces or 1 tab.</p>\n\n<pre><code>This is a normal paragraph.\n\n    This is a preformatted\n    code block.\n</code></pre>\n</div><div class="modal-block">\n<h3>Horizontal Rules</h3>\n\n<p>Three or more dashes or asterisks:</p>\n\n<pre><code>---\n\n* * *\n\n- - - -\n</code></pre>\n</div><div class="modal-block">\n<h3>Manual Line Breaks</h3>\n\n<p>End a line with two or more spaces:</p>\n\n<pre><code>Roses are red,\nViolets are blue.\n</code></pre>\n</div>\n</div>\n</div>'
	};
	return MarkdownModal
}(KDModalView);
var DropboxDownloadItemView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
DropboxDownloadItemView = function (_super) {
	function DropboxDownloadItemView(options, data) {
		var fileData;
		null == options && (options = {});
		options.cssClass = "dropbox-download-item";
		DropboxDownloadItemView.__super__.constructor.call(this, options, data);
		fileData = this.getData();
		this.thumbnail = new KDCustomHTMLView({
			tagName: "image",
			attributes: {
				src: fileData.thumbnails["64x64"] || fileData.icon
			}
		});
		this.fileName = new KDCustomHTMLView({
			cssClass: "file-name",
			partial: fileData.name
		});
		this.fileSize = new KDCustomHTMLView({
			cssClass: "file-size",
			partial: KD.utils.formatBytesToHumanReadable(fileData.bytes)
		});
		this.loader = new KDLoaderView({
			size: {
				width: 24
			}
		});
		this.success = new KDCustomHTMLView({
			cssClass: "done"
		});
		this.success.hide();
		this.on("FileNeedsToBeDownloaded", function (path) {
			this.loader.show();
			return KD.getSingleton("vmController").run({
				withArgs: "cd " + path + " ; wget " + fileData.link,
				vmName: this.getOptions().nodeView.getData().vmName
			}, function (_this) {
				return function (err, res) {
					if (err) return warn(err);
					if (res.exitStatus > 0) return warn(res.stderr);
					_this.loader.hide();
					_this.success.show();
					return _this.emit("FileDownloadDone")
				}
			}(this))
		})
	}
	__extends(DropboxDownloadItemView, _super);
	DropboxDownloadItemView.prototype.pistachio = function () {
		return '{{> this.thumbnail}}\n<div class="details">\n  {{> this.fileName}}\n  {{> this.fileSize}}\n</div>\n<div class="indicators">\n  {{> this.loader}}\n  {{> this.success}}\n</div>'
	};
	return DropboxDownloadItemView
}(JView);
var CommonVMUsageBar, VMDiskUsageBar, VMRamUsageBar, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
CommonVMUsageBar = function (_super) {
	function CommonVMUsageBar(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("vm-usage-bar", options.cssClass);
		CommonVMUsageBar.__super__.constructor.call(this, options, data)
	}
	__extends(CommonVMUsageBar, _super);
	CommonVMUsageBar.prototype.decorateUsage = function (usage) {
		var item, key, label, ratio, title;
		label = this.getOptions().label;
		ratio = (100 * usage.current / usage.max).toFixed(2);
		this.updateBar(ratio, "%", label);
		if (0 === usage.max) title = "Failed to fetch " + label + " info";
		else
			for (key in usage) {
				item = usage[key];
				usage[key] = KD.utils.formatBytesToHumanReadable(item)
			}
		return this.setTooltip({
			title: title || "" + usage.current + " of " + usage.max,
			placement: "bottom",
			delayIn: 300,
			offset: {
				top: 2,
				left: -8
			}
		})
	};
	CommonVMUsageBar.prototype.fetchUsage = function () {};
	CommonVMUsageBar.prototype.viewAppended = function () {
		CommonVMUsageBar.__super__.viewAppended.apply(this, arguments);
		return this.fetchUsage(this.bound("decorateUsage"))
	};
	return CommonVMUsageBar
}(KDProgressBarView);
VMRamUsageBar = function (_super) {
	function VMRamUsageBar(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("ram", options.cssClass);
		options.label = "RAM";
		VMRamUsageBar.__super__.constructor.call(this, options, data)
	}
	__extends(VMRamUsageBar, _super);
	VMRamUsageBar.prototype.fetchUsage = function (callback) {
		return KD.getSingleton("vmController").fetchRamUsage(this.getData(), callback)
	};
	return VMRamUsageBar
}(CommonVMUsageBar);
VMDiskUsageBar = function (_super) {
	function VMDiskUsageBar(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("disk", options.cssClass);
		options.label = "DISK";
		VMDiskUsageBar.__super__.constructor.call(this, options, data)
	}
	__extends(VMDiskUsageBar, _super);
	VMDiskUsageBar.prototype.fetchUsage = function (callback) {
		return KD.getSingleton("vmController").fetchDiskUsage(this.getData(), callback)
	};
	return VMDiskUsageBar
}(CommonVMUsageBar);
var ModalViewWithTerminal, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ModalViewWithTerminal = function (_super) {
	function ModalViewWithTerminal(options, data) {
		var terminalWrapper, _base, _base1, _ref;
		null == options && (options = {});
		options.cssClass = KD.utils.curry("terminal", options.cssClass);
		ModalViewWithTerminal.__super__.constructor.call(this, options, data);
		this.terminal = options.terminal;
		this.terminal || (this.terminal = {});
		(_base = this.terminal).height || (_base.height = 200);
		(_base1 = this.terminal).screen || (_base1.screen = !1);
		this.on("terminal.connected", function (_this) {
			return function (remote) {
				_this.on("terminal.input", function (command) {
					remote.input(command);
					return _this.webterm.$().click()
				});
				return _this.terminal.command && !_this.hidden ? _this.run(_this.terminal.command) : void 0
			}
		}(this));
		terminalWrapper = new KDView({
			cssClass: "modal-terminal-wrapper",
			noScreen: !this.terminal.screen,
			vmName: this.terminal.vmName
		});
		this.createWebTermView(terminalWrapper);
		this.hidden = null != (_ref = this.terminal.hidden) ? _ref : !1;
		terminalWrapper.$().css("height", this.hidden ? 0 : this.terminal.height);
		this.webterm.on("WebTermEvent", function (_this) {
			return function (data) {
				return _this.emit("terminal.event", data)
			}
		}(this));
		this.webterm.on("WebTermConnected", function (_this) {
			return function (remote) {
				return _this.emit("terminal.connected", remote)
			}
		}(this));
		this.webterm.on("WebTerm.terminated", function (_this) {
			return function () {
				return _this.emit("terminal.terminated")
			}
		}(this));
		terminalWrapper.addSubView(this.webterm);
		this.addSubView(terminalWrapper)
	}
	__extends(ModalViewWithTerminal, _super);
	ModalViewWithTerminal.prototype.createWebTermView = function (terminalWrapper) {
		var handler;
		handler = function (_this) {
			return function () {
				return _this.webterm.connectToTerminal()
			}
		}(this);
		this.webterm = new WebTermView({
			delegate: terminalWrapper,
			cssClass: "webterm",
			advancedSettings: !1
		});
		return WebTermView.setTerminalTimeout(null, 15e3, handler, handler)
	};
	ModalViewWithTerminal.prototype.run = function (command) {
		return this.hidden ? this.showTerminal(function (_this) {
			return function () {
				return _this.input(command)
			}
		}(this)) : this.input(command)
	};
	ModalViewWithTerminal.prototype.input = function (command) {
		return this.emit("terminal.input", command + "\n")
	};
	ModalViewWithTerminal.prototype.hideTerminal = function () {
		this.hidden = !0;
		return this.webterm.getDelegate().$().animate({
			height: 0
		}, 100, function (_this) {
			return function () {
				return _this.setPositions()
			}
		}(this))
	};
	ModalViewWithTerminal.prototype.showTerminal = function (callback) {
		this.hidden = !1;
		return this.webterm.getDelegate().$().animate({
			height: this.terminal.height
		}, 100, function (_this) {
			return function () {
				_this.setPositions();
				_this.terminal.command && _this.run(_this.terminal.command);
				_this.webterm.$().click();
				return "function" == typeof callback ? callback() : void 0
			}
		}(this))
	};
	ModalViewWithTerminal.prototype.toggleTerminal = function (callback) {
		return this[this.hidden ? "showTerminal" : "hideTerminal"](callback)
	};
	return ModalViewWithTerminal
}(KDModalView);
var CloneRepoModal, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
CloneRepoModal = function (_super) {
	function CloneRepoModal(options, data) {
		null == options && (options = {});
		options.title = "Clone Remote Repository";
		options.cssClass = "modal-with-text clone-repo-modal";
		options.content = "<p>Enter the URL of remote Git repository to clone.</p>";
		options.overlay = !0;
		options.width = 500;
		options.terminal = {
			hidden: !0,
			vmName: options.vmName,
			height: 300
		};
		options.buttons = {
			Clone: {
				title: "Clone",
				cssClass: "modal-clean-green",
				loader: {
					color: "#FFFFFF",
					diameter: 14
				},
				callback: function (_this) {
					return function () {
						return _this.repoPath.validate() ? _this.cloneRepo() : void 0
					}
				}(this)
			},
			Cancel: {
				title: "Cancel",
				cssClass: "modal-cancel",
				callback: function (_this) {
					return function () {
						return _this.destroy()
					}
				}(this)
			}
		};
		CloneRepoModal.__super__.constructor.call(this, options, data);
		this.addSubView(this.repoPath = new KDHitEnterInputView({
			type: "text",
			placeholder: "Type a git repository URL...",
			validationNotifications: !0,
			validate: {
				rules: {
					required: !0
				},
				messages: {
					required: "Please enter a repo URL."
				}
			},
			callback: this.bound("cloneRepo")
		}))
	}
	__extends(CloneRepoModal, _super);
	CloneRepoModal.prototype.cloneRepo = function () {
		var command;
		if (!this.cloning) {
			this.buttons.Clone.showLoader();
			command = "cd " + FSHelper.plainPath(this.getOptions().path) + " ; git clone " + this.repoPath.getValue() + "; echo $?|kdevent;";
			this.cloning = !0;
			this.setClass("running");
			this.run(command);
			return this.once("terminal.event", function (data) {
				if ("0" === data) {
					this.destroy();
					return this.emit("RepoClonedSuccessfully")
				}
			})
		}
	};
	return CloneRepoModal
}(ModalViewWithTerminal);
var MemberAutoCompleteItemView, MemberAutoCompletedItemView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
MemberAutoCompleteItemView = function (_super) {
	function MemberAutoCompleteItemView(options, data) {
		var userInput;
		options.cssClass = "clearfix member-suggestion-item";
		MemberAutoCompleteItemView.__super__.constructor.call(this, options, data);
		userInput = options.userInput || this.getDelegate().userInput;
		this.addSubView(this.profileLink = new AutoCompleteProfileTextView({
			userInput: userInput,
			shouldShowNick: !0
		}, data))
	}
	__extends(MemberAutoCompleteItemView, _super);
	MemberAutoCompleteItemView.prototype.viewAppended = function () {
		return JView.prototype.viewAppended.call(this)
	};
	return MemberAutoCompleteItemView
}(KDAutoCompleteListItemView);
MemberAutoCompletedItemView = function (_super) {
	function MemberAutoCompletedItemView() {
		return MemberAutoCompletedItemView.__super__.constructor.apply(this, arguments)
	}
	__extends(MemberAutoCompletedItemView, _super);
	MemberAutoCompletedItemView.prototype.viewAppended = function () {
		this.addSubView(this.profileText = new AutoCompleteProfileTextView({}, this.getData()));
		return JView.prototype.viewAppended.call(this)
	};
	return MemberAutoCompletedItemView
}(KDAutoCompletedItem);
var EditorModal, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
EditorModal = function (_super) {
	function EditorModal(options, data) {
		var appManager, closeOnSave, editorOptions, saveFailedMessage, saveMessage, _ref;
		null == options && (options = {});
		options.cssClass = KD.utils.curry("editor-modal", options.cssClass);
		options.domId = "editor-modal";
		options.width = 800;
		options.height = 400;
		null == options.overlay && (options.overlay = !0);
		null == options.editor && (options.editor = {
			readOnly: !0
		});
		null == options.removeOnOverlayClick && (options.removeOnOverlayClick = !1);
		EditorModal.__super__.constructor.call(this, options, data);
		this.setClass("loading");
		this.addSubView(this.loader = new KDLoaderView({
			showLoader: !0,
			size: {
				width: 36
			}
		}));
		appManager = KD.getSingleton("appManager");
		editorOptions = options.editor || {};
		appManager.require("Teamwork", function (_this) {
			return function () {
				var buttons, content, readOnly, title;
				title = editorOptions.title, content = editorOptions.content, readOnly = editorOptions.readOnly, buttons = editorOptions.buttons;
				_this.editor = new EditorPane({
					cssClass: "hidden",
					title: title || "",
					readOnly: null != readOnly ? readOnly : !1,
					content: Encoder.htmlDecode(content || ""),
					size: {
						width: 800,
						height: 400
					},
					buttons: buttons || [{
						title: "Save",
						cssClass: "solid compact green",
						callback: _this.bound("save")
					}, {
						title: "Close",
						cssClass: "solid compact gray",
						callback: function () {
							return _this.destroy()
						}
					}]
				});
				_this.addSubView(_this.editor);
				return _this.editor.ace.once("ace.ready", function () {
					_this.editor.unsetClass("hidden");
					_this.unsetClass("loading");
					_this.loader.destroy();
					_this.editor.ace.addKeyCombo("save", "Ctrl-S", _this.bound("save"));
					return _this.overlay.click = function () {
						return options.removeOnOverlayClick ? void 0 : !1
					}
				})
			}
		}(this));
		_ref = this.getOptions().editor, saveMessage = _ref.saveMessage, saveFailedMessage = _ref.saveFailedMessage, closeOnSave = _ref.closeOnSave;
		saveMessage && this.on("Saved", function (_this) {
			return function () {
				_this.showNotification(saveMessage, "success");
				return closeOnSave ? KD.utils.wait(800, function () {
					return _this.destroy()
				}) : void 0
			}
		}(this));
		saveFailedMessage && this.on("SaveFailed", function (_this) {
			return function () {
				return _this.showNotification(saveFailedMessage, "error")
			}
		}(this))
	}
	__extends(EditorModal, _super);
	EditorModal.prototype.save = function () {
		var callback, editorOptions;
		editorOptions = this.getOptions().editor || {};
		callback = editorOptions.saveCallback || noop;
		return callback(this.editor.getValue(), this)
	};
	EditorModal.prototype.showNotification = function (title, cssClass) {
		var container, duration, type;
		type = "mini";
		duration = 3e3;
		container = this;
		return new KDNotificationView({
			title: title,
			cssClass: cssClass,
			container: container,
			duration: duration,
			type: type
		})
	};
	return EditorModal
}(KDModalView);
var NavigationList, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NavigationList = function (_super) {
	function NavigationList() {
		NavigationList.__super__.constructor.apply(this, arguments);
		this.viewWidth = 55;
		this.on("ItemWasAdded", function (_this) {
			return function (view) {
				var lastChange;
				view.once("viewAppended", function () {
					"persistent" === view.data.type && (view.options.draggable = {
						axis: "x"
					});
					null == view._index && (view._index = _this.getItemIndex(view));
					view.setX(view._index * _this.viewWidth);
					_this._width = _this.viewWidth * (_this.items.length + 1);
					_this.setWidth(_this._width - _this.viewWidth);
					return KD.utils.defer(function () {
						return view.unsetClass("no-anim")
					})
				});
				lastChange = 0;
				view.on("DragStarted", function () {
					return _this._dragStarted = !0
				});
				view.on("DragInAction", function (x, y) {
					var current, dock;
					if (_this._dragStarted && y > 15 && "persistent" !== view.data.type) {
						dock = KD.singletons.dock.mainView;
						dock.setClass("remove-app-state");
						delete _this._dragStarted
					}
					if (!(x + view._x > _this._width || x + view._x < 0)) {
						"persistent" !== view.data.type && y > 25 ? view.setClass("remove") : view.unsetClass("remove");
						current = x > _this.viewWidth ? Math.floor(x / _this.viewWidth) : x < -_this.viewWidth ? Math.ceil(x / _this.viewWidth) : 0;
						if (current > lastChange) {
							_this.moveItemToIndex(view, view._index + 1);
							return lastChange = current
						}
						if (lastChange > current) {
							_this.moveItemToIndex(view, view._index - 1);
							return lastChange = current
						}
					}
				});
				return view.on("DragFinished", function () {
					view.unsetClass("no-anim remove");
					if ("persistent" !== view.data.type && view.getRelativeY() > 25) {
						view.setClass("explode");
						KD.utils.wait(500, function () {
							return _this.removeApp(view)
						})
					} else {
						KD.utils.wait(200, function () {
							return view.unsetClass("on-top")
						});
						view.setX(view._index * _this.viewWidth);
						view.setY(0);
						KD.singletons.dock.saveItemOrders(_this.items)
					}
					lastChange = 0;
					return KD.utils.wait(200, function () {
						delete _this._dragStarted;
						return KD.singletons.dock.mainView.unsetClass("remove-app-state")
					})
				})
			}
		}(this))
	}
	__extends(NavigationList, _super);
	NavigationList.prototype.removeApp = function (view) {
		this.removeItem(view);
		this.updateItemPositions();
		return KD.singletons.dock.removeItem(view)
	};
	NavigationList.prototype.updateItemPositions = function (excluded) {
		var index, _i, _item, _len, _ref, _results;
		this._width = this.viewWidth * (this.items.length + 1);
		this.setWidth(this._width - this.viewWidth);
		_ref = this.items;
		_results = [];
		for (index = _i = 0, _len = _ref.length; _len > _i; index = ++_i) {
			_item = _ref[index];
			_item._index = index;
			_results.push(_item !== excluded ? _item.setX(index * this.viewWidth) : void 0)
		}
		return _results
	};
	NavigationList.prototype.moveItemToIndex = function (item, index) {
		NavigationList.__super__.moveItemToIndex.call(this, item, index);
		return this.updateItemPositions(item)
	};
	return NavigationList
}(KDListView);
var NavigationLink, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
NavigationLink = function (_super) {
	function NavigationLink(options, data) {
		var appsHasIcon, entryPoint, slug, _ref;
		null == options && (options = {});
		null == data && (data = {});
		data.type || (data.type = "");
		options.tagName || (options.tagName = "a");
		options.type || (options.type = "main-nav");
		options.bind = KD.utils.curry("contextmenu", options.bind);
		options.draggable = !0;
		options.cssClass = KD.utils.curry(this.utils.slugify(data.title), options.cssClass);
		options.cssClass = KD.utils.curry("no-anim", options.cssClass);
		options.attributes = {};
		entryPoint = KD.config.entryPoint;
		if (entryPoint) {
			slug = entryPoint.slug;
			options.attributes.href = "/" + slug + data.path
		} else options.attributes.href = data.path;
		NavigationLink.__super__.constructor.call(this, options, data);
		this.name = data.title;
		this.icon = new KDCustomHTMLView({
			cssClass: "fake-icon",
			partial: "<span class='logo'>" + this.name[0] + "</span>"
		});
		this.icon.setCss("backgroundColor", KD.utils.getColorFromString(this.name));
		appsHasIcon = Object.keys(KD.config.apps);
		appsHasIcon.push("Editor");
		(_ref = this.name, __indexOf.call(appsHasIcon, _ref) >= 0) && !data.useFakeIcon && this.icon.hide();
		this.on("DragStarted", this.bound("dragStarted"))
	}
	var NAMES;
	__extends(NavigationLink, _super);
	JView.mixin(NavigationLink.prototype);
	NAMES = {
		Editor: "Ace"
	};
	NavigationLink.prototype.setState = function (state) {
		var states;
		null == state && (state = "initial");
		states = "running failed loading";
		this.unsetClass(states);
		return __indexOf.call(states.split(" "), state) >= 0 ? this.setClass(state) : void 0
	};
	NavigationLink.prototype.click = function (event) {
		var appPath, mc, path, title, topLevel, type, _ref;
		KD.utils.stopDOMEvent(event);
		_ref = this.getData(), appPath = _ref.appPath, title = _ref.title, path = _ref.path, type = _ref.type, topLevel = _ref.topLevel;
		if (!path || this.positionChanged()) return !1;
		mc = KD.getSingleton("mainController");
		return mc.emit("NavigationLinkTitleClick", {
			pageName: title,
			appPath: appPath || title,
			path: path,
			topLevel: topLevel,
			navItem: this
		})
	};
	NavigationLink.prototype.contextMenu = function (event) {
		var contextMenu, items, path, type, _ref;
		KD.utils.stopDOMEvent(event);
		_ref = this.getData(), type = _ref.type, path = _ref.path;
		items = {};
		items[this.name] = {
			disabled: !0
		};
		this.hasClass("running") ? items.Close = {
			callback: function (_this) {
				return function () {
					contextMenu.destroy();
					return _this.closeApp()
				}
			}(this)
		} : items.Open = {
			callback: function () {
				contextMenu.destroy();
				return KD.singletons.router.handleRoute(path)
			}
		};
		"persistent" !== type && (items.Remove = {
			callback: function (_this) {
				return function () {
					contextMenu.destroy();
					return _this.getDelegate().removeApp(_this)
				}
			}(this)
		});
		return contextMenu = new KDContextMenu({
			cssClass: "dock",
			delegate: this,
			menuWidth: "auto",
			menuMinWidth: 100,
			y: this.getY() + 57,
			x: this.getX() - 25,
			arrow: {
				margin: 35,
				placement: "top"
			}
		}, items)
	};
	NavigationLink.prototype.closeApp = function () {
		var appManager, name, router;
		appManager = KD.singleton("appManager");
		router = KD.singleton("router");
		name = NAMES[this.name] || this.name;
		appManager.quitByName(name);
		return appManager.getFrontApp().getOptions().name === name ? router.back() : void 0
	};
	NavigationLink.prototype.viewAppended = function () {
		JView.prototype.viewAppended.call(this);
		return this.keepCurrentPosition()
	};
	NavigationLink.prototype.pistachio = function () {
		return "{{> this.icon}}\n<span class='icon'></span>\n<cite>" + this.name + "</cite>"
	};
	NavigationLink.prototype.dragStarted = function () {
		this.keepCurrentPosition();
		return this.setClass("no-anim on-top")
	};
	NavigationLink.prototype.keepCurrentPosition = function () {
		this._x = this.getX();
		this._y = this.getY();
		this._rx = this.getRelativeX();
		return this._ry = this.getRelativeY()
	};
	NavigationLink.prototype.restoreLastPosition = function () {
		this.setX(this._rx);
		return this.setY(this._ry)
	};
	NavigationLink.prototype.positionChanged = function () {
		return this.getRelativeY() !== this._ry || this.getRelativeX() !== this._rx
	};
	return NavigationLink
}(KDListItemView);
var NavigationSeparator, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NavigationSeparator = function (_super) {
	function NavigationSeparator(options, data) {
		null == options && (options = {});
		options.tagName = "hr";
		NavigationSeparator.__super__.constructor.call(this, options, data)
	}
	__extends(NavigationSeparator, _super);
	return NavigationSeparator
}(KDCustomHTMLView);
var AdminNavigationLink, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AdminNavigationLink = function (_super) {
	function AdminNavigationLink() {
		return AdminNavigationLink.__super__.constructor.apply(this, arguments)
	}
	__extends(AdminNavigationLink, _super);
	AdminNavigationLink.prototype.click = function () {
		var cb;
		cb = this.getData().callback;
		return cb ? cb.call(this) : void 0
	};
	return AdminNavigationLink
}(NavigationLink);
var NavigationInviteLink, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NavigationInviteLink = function (_super) {
	function NavigationInviteLink(options, data) {
		var _ref;
		null == options && (options = {});
		options.tagName = "a";
		options.cssClass = "title";
		NavigationInviteLink.__super__.constructor.call(this, options, data);
		this.icon = new KDCustomHTMLView({
			tagName: "span",
			cssClass: "main-nav-icon " + utils.slugify(this.getData().title)
		});
		(null != (_ref = KD.config.entryPoint) ? _ref.slug : void 0) && this.hide()
	}
	__extends(NavigationInviteLink, _super);
	JView.mixin(NavigationInviteLink.prototype);
	NavigationInviteLink.prototype.sendInvite = function (formData, modal) {
		return KD.remote.api.JInvitation.inviteFriend(formData, function () {
			return function (err) {
				var message;
				modal.modalTabs.forms["Invite Friends"].buttons.Send.hideLoader();
				if (err) {
					11e3 === err.code && (message = "This e-mail is already invited!");
					return new KDNotificationView({
						title: message || err.message || "Sorry, something bad happened.",
						content: message ? void 0 : "Please try again later!"
					})
				}
				new KDNotificationView({
					title: "Success!"
				});
				modal.destroy();
				return KD.mixpanel("Invite friend, success")
			}
		}(this))
	};
	NavigationInviteLink.prototype.pistachio = function () {
		return "{{> this.icon}} " + this.getData().title
	};
	NavigationInviteLink.prototype.click = function (event) {
		var inviteForm, inviteHint, modal, modalHint;
		event.stopPropagation();
		event.preventDefault();
		modal = new KDModalViewWithForms({
			title: "<span class='invite-icon'></span>Invite Friends to Koding",
			width: 500,
			height: "auto",
			cssClass: "invitation-modal",
			tabs: {
				forms: {
					"Invite Friends": {
						callback: function (_this) {
							return function (formData) {
								return _this.sendInvite(formData, modal)
							}
						}(this),
						fields: {
							email: {
								label: "Send To:",
								placeholder: "Enter your friend's email address...",
								validate: {
									rules: {
										required: !0,
										email: !0
									},
									messages: {
										required: "An email address is required!",
										email: "That does not not seem to be a valid email address!"
									}
								}
							},
							customMessage: {
								label: "Message:",
								type: "textarea",
								placeholder: "Hi! You're invited to try out Koding, a new way for developers to work.",
								defaultValue: "Hi! You're invited to try out Koding, a new way for developers to work."
							}
						},
						buttons: {
							Send: {
								style: "modal-clean-gray",
								type: "submit",
								loader: {
									color: "#444444",
									diameter: 12
								}
							},
							cancel: {
								style: "modal-cancel",
								callback: function () {
									return modal.destroy()
								}
							}
						}
					}
				}
			}
		});
		inviteForm = modal.modalTabs.forms["Invite Friends"];
		inviteForm.on("FormValidationFailed", function () {
			return function () {
				return inviteForm.buttons.Send.hideLoader()
			}
		}(this));
		modalHint = new KDView({
			cssClass: "modal-hint",
			partial: "<p>Your friend will receive an invitation email from Koding.</p> <p><cite>* We take privacy seriously, we will not share any personal information.</cite></p>"
		});
		modal.modalTabs.addSubView(modalHint, null, !0);
		inviteHint = new JView({
			cssClass: "invite-hint fl",
			pistachio: "{{#(quota) - #(usage)}} Invites remaining"
		}, this.count.getData());
		modal.modalTabs.panes[0].form.buttonField.addSubView(inviteHint, null, !0);
		return !1
	};
	return NavigationInviteLink
}(KDCustomHTMLView);
var NavigationActivityLink, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NavigationActivityLink = function (_super) {
	function NavigationActivityLink(options, data) {
		var appManager, mainController;
		null == options && (options = {});
		options.tagName = "a";
		options.cssClass = "title";
		NavigationActivityLink.__super__.constructor.call(this, options, data);
		appManager = KD.getSingleton("appManager");
		this.count = new KDCustomHTMLView({
			tagName: "span",
			cssClass: "main-nav-icon transparent",
			partial: "",
			click: function (_this) {
				return function () {
					return _this.setActivityLinkToDefaultState()
				}
			}(this)
		});
		this.count.hide();
		this.icon = new KDCustomHTMLView({
			tagName: "span",
			cssClass: "main-nav-icon " + utils.slugify(this.getData().title)
		});
		mainController = KD.getSingleton("mainController");
		mainController.ready(function (_this) {
			return function () {
				var activityController;
				activityController = KD.getSingleton("activityController");
				return activityController.on("ActivitiesArrived", function () {
					var newItemsCount;
					if ("/Activity" !== KD.getSingleton("router").currentPath) {
						newItemsCount = activityController.getNewItemsCount();
						newItemsCount > 0 && _this.updateNewItemsCount(newItemsCount);
						return activityController.on("NewItemsCounterCleared", _this.bound("setActivityLinkToDefaultState"))
					}
				})
			}
		}(this));
		mainController.on("NavigationLinkTitleClick", function () {
			return function (options) {
				return "Activity" === options.appPath ? KD.getSingleton("activityController").clearNewItemsCount() : void 0
			}
		}(this))
	}
	__extends(NavigationActivityLink, _super);
	JView.mixin(NavigationActivityLink.prototype);
	NavigationActivityLink.prototype.updateNewItemsCount = function (itemCount) {
		if (0 !== itemCount) {
			this.count.updatePartial(itemCount);
			this.count.show();
			return this.icon.hide()
		}
	};
	NavigationActivityLink.prototype.setActivityLinkToDefaultState = function () {
		this.icon.show();
		return this.count.hide()
	};
	NavigationActivityLink.prototype.pistachio = function () {
		return "{{> this.count}} {{> this.icon}} " + this.getData().title
	};
	return NavigationActivityLink
}(KDCustomHTMLView);
var NavigationAppsLink, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NavigationAppsLink = function (_super) {
	function NavigationAppsLink(options, data) {
		null == options && (options = {});
		options.tagName = "a";
		options.cssClass = "title";
		NavigationAppsLink.__super__.constructor.call(this, options, data);
		this.counter = 0;
		this.appsController = KD.getSingleton("kodingAppsController");
		this.count = new KDCustomHTMLView({
			tagName: "span",
			cssClass: "icon-top-badge",
			partial: "",
			click: function () {
				return function (e) {
					e.preventDefault();
					e.stopPropagation();
					return KD.getSingleton("router").handleRoute("/Apps?filter=updates")
				}
			}(this)
		});
		this.count.hide();
		this.icon = new KDCustomHTMLView({
			tagName: "span",
			cssClass: "main-nav-icon " + utils.slugify(this.getData().title)
		});
		this.getUpdateRequiredAppsCount();
		this.appsController.on("AnAppHasBeenUpdated", function (_this) {
			return function () {
				if (0 !== _this.counter) {
					_this.counter--;
					return 0 === _this.counter ? _this.count.hide() : _this.count.updatePartial(_this.counter)
				}
			}
		}(this));
		this.appsController.on("AppsRefreshed", function (_this) {
			return function () {
				return _this.setCounter(!0)
			}
		}(this))
	}
	__extends(NavigationAppsLink, _super);
	NavigationAppsLink.prototype.getUpdateRequiredAppsCount = function () {
		return Object.keys(this.appsController.publishedApps).length ? this.setCounter() : this.appsController.on("UserAppModelsFetched", function (_this) {
			return function () {
				return _this.setCounter()
			}
		}(this))
	};
	NavigationAppsLink.prototype.setCounter = function (useTheForce) {
		null == useTheForce && (useTheForce = !1);
		return this.appsController.fetchUpdateAvailableApps(function (_this) {
			return function (err, availables) {
				_this.counter = availables.length;
				_this.count.updatePartial(_this.counter);
				return _this.counter > 0 ? _this.count.show() : _this.count.hide()
			}
		}(this), useTheForce)
	};
	NavigationAppsLink.prototype.pistachio = function () {
		return "{{> this.count}} {{> this.icon}} " + this.getData().title
	};
	return NavigationAppsLink
}(JView);
var NavigationDocsJobsLink, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NavigationDocsJobsLink = function (_super) {
	function NavigationDocsJobsLink(options, data) {
		null == options && (options = {});
		options.tagName = "span";
		options.cssClass = "title";
		NavigationDocsJobsLink.__super__.constructor.call(this, options, data);
		this.icon = new KDCustomHTMLView({
			tagName: "span",
			cssClass: "main-nav-icon " + utils.slugify(this.getData().title)
		});
		this.docsLink = new KDCustomHTMLView({
			tagName: "a",
			partial: "Docs",
			cssClass: "ext",
			attributes: {
				href: "http://learn.koding.com",
				target: "_blank"
			}
		});
		this.jobsLink = new KDCustomHTMLView({
			tagName: "a",
			partial: "Jobs",
			cssClass: "ext",
			attributes: {
				href: "http://koding.github.io/jobs/",
				target: "_blank"
			}
		})
	}
	__extends(NavigationDocsJobsLink, _super);
	JView.mixin(NavigationDocsJobsLink.prototype);
	NavigationDocsJobsLink.prototype.click = function () {};
	NavigationDocsJobsLink.prototype.pistachio = function () {
		return "{{> this.icon}} {{> this.docsLink}} / {{> this.jobsLink}}"
	};
	return NavigationDocsJobsLink
}(KDCustomHTMLView);
var NavigationPromoteLink, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NavigationPromoteLink = function (_super) {
	function NavigationPromoteLink(options, data) {
		null == options && (options = {});
		options.tagName = "a";
		options.cssClass = "title";
		options.tooltip = {
			placement: "right",
			title: "Only this week, share your link, they get 5GB instead\nof 4GB, and you get 1GB extra!"
		};
		NavigationPromoteLink.__super__.constructor.call(this, options, data);
		this.icon = new KDCustomHTMLView({
			tagName: "span",
			cssClass: "main-nav-icon promote"
		})
	}
	__extends(NavigationPromoteLink, _super);
	NavigationPromoteLink.prototype.click = function (event) {
		var appManager;
		KD.utils.stopDOMEvent(event);
		appManager = KD.getSingleton("appManager");
		return appManager.tell("Account", "showReferrerModal")
	};
	NavigationPromoteLink.prototype.pistachio = function () {
		return "{{> this.icon}} {{#(title)}}"
	};
	return NavigationPromoteLink
}(JView);
var LocationController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LocationController = function (_super) {
	function LocationController() {
		return LocationController.__super__.constructor.apply(this, arguments)
	}
	__extends(LocationController, _super);
	LocationController.prototype.fetchCountryData = function (callback) {
		var JPayment, ip;
		JPayment = KD.remote.api.JPayment;
		if (this.countries || this.countryOfIp) return this.utils.defer(function (_this) {
			return function () {
				return callback(null, {
					countries: _this.countries,
					countryOfIp: _this.countryOfIp
				})
			}
		}(this));
		ip = Cookies.get("clientIPAddress");
		return JPayment.fetchCountryDataByIp(ip, function (_this) {
			return function (err, _arg) {
				_this.countries = _arg.countries, _this.countryOfIp = _arg.countryOfIp;
				return callback(err, {
					countries: _this.countries,
					countryOfIp: _this.countryOfIp
				})
			}
		}(this))
	};
	LocationController.prototype.createLocationForm = function (options, data) {
		var form;
		form = new LocationForm(options, data);
		this.fetchCountryData(function (err, _arg) {
			var countries, countryOfIp;
			countries = _arg.countries, countryOfIp = _arg.countryOfIp;
			return KD.showError(err) ? void 0 : form.setCountryData({
				countries: countries,
				countryOfIp: countryOfIp
			})
		});
		return form
	};
	return LocationController
}(KDController);
var LocationForm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LocationForm = function (_super) {
	function LocationForm(options, data) {
		null == options && (options = {});
		null == data && (data = {});
		options.cssClass = KD.utils.curry("location-form", options.cssClass);
		LocationForm.__super__.constructor.call(this, this.prepareOptions(options, data), data);
		this.countryLoader = new KDLoaderView({
			size: {
				width: 14
			},
			showLoader: !0
		});
		this.on("FormValidationFailed", function (_this) {
			return function () {
				return _this.buttons.Save.hideLoader()
			}
		}(this))
	}
	__extends(LocationForm, _super);
	LocationForm.prototype.prepareOptions = function (options, data) {
		var requirePhone, _base, _base1, _base2, _base3, _base4, _base5, _ref, _ref1;
		null == options.fields && (options.fields = {});
		null == (_base = options.fields).company && (_base.company = {
			label: "Company & VAT",
			placeholder: "Company (optional)",
			defaultValue: data.company,
			nextElementFlat: {
				vatNumber: {
					placeholder: "VAT Number (optional)",
					defaultValue: data.vatNumber
				}
			}
		});
		null == (_base1 = options.fields).address1 && (_base1.address1 = {
			label: "Address & ZIP",
			placeholder: "Address",
			required: "Address is required",
			defaultValue: data.address1,
			nextElementFlat: {
				zip: {
					placeholder: "ZIP",
					defaultValue: data.zip,
					keyup: this.bound("handleZipCode"),
					required: "Zip is required"
				}
			}
		});
		null == (_base2 = options.fields).city && (_base2.city = {
			label: "City & State",
			placeholder: "City",
			defaultValue: data.city,
			required: "City is required",
			nextElementFlat: {
				state: {
					placeholder: "State",
					itemClass: KDSelectBox,
					defaultValue: data.state,
					required: "State is required"
				}
			}
		});
		null == (_base3 = options.fields).country && (_base3.country = {
			label: "Country",
			itemClass: KDSelectBox,
			defaultValue: data.country || "US"
		});
		if ((null != (_ref = options.phone) ? _ref.show : void 0) || (null != (_ref1 = options.phone) ? _ref1.required : void 0)) {
			requirePhone = options.phone.required;
			null == (_base4 = options.fields).phone && (_base4.phone = {
				label: "Phone",
				placeholder: requirePhone ? "" : "(optional)",
				defaultValue: data.phone
			});
			requirePhone && (options.fields.phone.required = "Phone number is required.")
		}
		if (options.buttons === !1) delete options.buttons;
		else {
			null == options.buttons && (options.buttons = {});
			null == (_base5 = options.buttons).Save && (_base5.Save = {
				style: "modal-clean-green",
				type: "submit",
				loader: {
					color: "#fff",
					diameter: 12
				}
			})
		}
		return options
	};
	LocationForm.prototype.handleZipCode = function () {
		var JLocation, city, country, locationSelector, state, zip, _ref;
		JLocation = KD.remote.api.JLocation;
		_ref = this.inputs, city = _ref.city, state = _ref.state, country = _ref.country, zip = _ref.zip;
		locationSelector = {
			zip: zip.getValue(),
			countryCode: country.getValue()
		};
		return JLocation.one(locationSelector, function (_this) {
			return function (err, location) {
				return location ? _this.setLocation(location) : void 0
			}
		}(this))
	};
	LocationForm.prototype.handleCountryCode = function () {
		var JLocation, actualState, country, countryCode, state, _ref, _ref1;
		JLocation = KD.remote.api.JLocation;
		_ref = this.inputs, country = _ref.country, state = _ref.state;
		_ref1 = this.getData(), actualState = _ref1.actualState, countryCode = _ref1.country;
		if (this.countryCode !== countryCode) {
			this.countryCode = countryCode;
			return JLocation.fetchStatesByCountryCode(countryCode, function (err, states) {
				state.setSelectOptions(_.values(states));
				return state.setValue(actualState)
			})
		}
	};
	LocationForm.prototype.setLocation = function (location) {
		return ["city", "stateCode", "countryCode"].forEach(function (_this) {
			return function (field) {
				var input, inputName, value;
				value = location[field];
				inputName = function () {
					switch (field) {
					case "city":
						return "city";
					case "stateCode":
						this.addCustomData("actualState", value);
						return "state";
					case "countryCode":
						return "country"
					}
				}.call(_this);
				input = _this.inputs[inputName];
				return null != input ? input.setValue(value) : void 0
			}
		}(this))
	};
	LocationForm.prototype.setCountryData = function (_arg) {
		var countries, country, countryOfIp;
		countries = _arg.countries, countryOfIp = _arg.countryOfIp;
		country = this.inputs.country;
		country.setSelectOptions(_.values(countries));
		country.setValue(countries[countryOfIp] ? countryOfIp : "US");
		this.handleCountryCode();
		return this.emit("CountryDataPopulated")
	};
	return LocationForm
}(KDFormViewWithFields);
var BadgeController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
BadgeController = function (_super) {
	function BadgeController() {
		return BadgeController.__super__.constructor.apply(this, arguments)
	}
	__extends(BadgeController, _super);
	BadgeController.prototype.checkBadge = function (options) {
		var client;
		client = KD.whoami();
		return client.updateCountAndCheckBadge(options, function (err, badges) {
			var badge, _i, _len, _results;
			err && warn(err);
			_results = [];
			for (_i = 0, _len = badges.length; _len > _i; _i++) {
				badge = badges[_i];
				new KDNotificationView({
					title: "Congratz dude you got the " + badge.title + " badge!",
					subtitle: badge.description,
					content: "<img src='" + badge.iconURL + "'/>",
					type: "growl",
					duration: 2e3
				});
				_results.push(KD.mixpanel("Badge Gain, click", badge.title))
			}
			return _results
		})
	};
	return BadgeController
}(KDController);
var PaymentController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__slice = [].slice,
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
PaymentController = function (_super) {
	function PaymentController() {
		return PaymentController.__super__.constructor.apply(this, arguments)
	}
	__extends(PaymentController, _super);
	PaymentController.prototype.fetchPaymentMethods = function (callback) {
		var appStorage, appStorageController, dash, methods, preferredPaymentMethod, queue;
		dash = Bongo.dash;
		methods = null;
		preferredPaymentMethod = null;
		appStorageController = KD.singletons.appStorageController;
		appStorage = appStorageController.storage("Account", "1.0");
		queue = [
			function () {
				return appStorage.fetchStorage(function () {
					preferredPaymentMethod = appStorage.getValue("preferredPaymentMethod");
					return queue.fin()
				})
			},
			function () {
				return function () {
					return KD.whoami().fetchPaymentMethods(function (err, paymentMethods) {
						methods = paymentMethods;
						return queue.fin(err)
					})
				}
			}(this)
		];
		return dash(queue, function (err) {
			return callback(err, {
				preferredPaymentMethod: preferredPaymentMethod,
				methods: methods,
				appStorage: appStorage
			})
		})
	};
	PaymentController.prototype.observePaymentSave = function (modal, callback) {
		return modal.on("PaymentInfoSubmitted", function (_this) {
			return function (paymentMethodId, updatedPaymentInfo) {
				return _this.updatePaymentInfo(paymentMethodId, updatedPaymentInfo, function (err, savedPaymentInfo) {
					if (err) {
						modal.emit("FormValidationFailed", err);
						return callback(err)
					}
					callback(null, savedPaymentInfo);
					return _this.emit("PaymentDataChanged")
				})
			}
		}(this))
	};
	PaymentController.prototype.removePaymentMethod = function (paymentMethodId, callback) {
		var JPayment;
		JPayment = KD.remote.api.JPayment;
		return JPayment.removePaymentMethod(paymentMethodId, function (_this) {
			return function (err) {
				return err ? callback(err) : _this.emit("PaymentDataChanged")
			}
		}(this))
	};
	PaymentController.prototype.fetchSubscription = function () {
		var fetchSubscription, findActiveSubscription;
		findActiveSubscription = function (subscriptions, planCode, callback) {
			var paymentMethodId, sub, subs, _i, _len, _ref;
			for (paymentMethodId in subscriptions)
				if (__hasProp.call(subscriptions, paymentMethodId)) {
					subs = subscriptions[paymentMethodId];
					for (_i = 0, _len = subscriptions.length; _len > _i; _i++) {
						sub = subscriptions[_i];
						if (sub.planCode === planCode && ("canceled" === (_ref = sub.status) || "active" === _ref)) return callback(null, sub)
					}
				}
			return callback(null)
		};
		return fetchSubscription = function (type, planCode, callback) {
			var JPaymentSubscription;
			JPaymentSubscription = KD.remote.api.JPaymentSubscription;
			return "group" === type ? KD.getGroup().checkPayment(function () {
				return function (err, subs) {
					return findActiveSubscription(subs, planCode, callback)
				}
			}(this)) : JPaymentSubscription.fetchUserSubscriptions(function (err, subs) {
				return findActiveSubscription(subs, planCode, callback)
			})
		}
	}();
	PaymentController.prototype.fetchPlanByCode = function (planCode, callback) {
		var JPaymentPlan;
		JPaymentPlan = KD.remote.api.JPaymentPlan;
		return JPaymentPlan.fetchPlanByCode(planCode, callback)
	};
	PaymentController.prototype.fetchPaymentInfo = function (type, callback) {
		var JPaymentPlan;
		JPaymentPlan = KD.remote.api.JPaymentPlan;
		switch (type) {
		case "group":
		case "expensed":
			return KD.getGroup().fetchPaymentInfo(callback);
		case "user":
			return JPaymentPlan.fetchAccountDetails(callback)
		}
	};
	PaymentController.prototype.updatePaymentInfo = function (paymentMethodId, paymentMethod, callback) {
		var JPayment, key, value;
		null == paymentMethodId && (paymentMethodId = null);
		JPayment = KD.remote.api.JPayment;
		for (key in paymentMethod)
			if (__hasProp.call(paymentMethod, key)) {
				value = paymentMethod[key];
				paymentMethod[key] = value.trim()
			}
		return JPayment.setPaymentInfo(paymentMethodId, paymentMethod, callback)
	};
	PaymentController.prototype.createPaymentInfoModal = function () {
		return new PaymentFormModal
	};
	PaymentController.prototype.createUpgradeForm = function (parent) {
		var buyPacksButton;
		buyPacksButton = new KDButtonView({
			cssClass: "buy-packs",
			style: "solid green medium",
			title: "Buy Resource Packs",
			callback: function () {
				parent || (parent = this.parent);
				parent.emit("Cancel");
				return KD.singleton("router").handleRoute("/Pricing")
			}
		});
		return new JView({
			pistachioParams: {
				button: buyPacksButton
			},
			pistachio: '<h2>\n  You do not have enough resources, you need to buy at least one "Resource Pack" to be able to create an extra VM.\n</h2>\n{{> button}}'
		})
	};
	PaymentController.prototype.createUpgradeWorkflow = function (options) {
		var confirmForm, productForm, tag, workflow;
		null == options && (options = {});
		tag = options.tag, productForm = options.productForm, confirmForm = options.confirmForm;
		productForm || (productForm = this.createUpgradeForm());
		confirmForm || (confirmForm = new PlanUpgradeConfirmForm({
			name: "overview"
		}));
		workflow = new PaymentWorkflow({
			productForm: productForm,
			confirmForm: confirmForm
		});
		productForm.on("PlanSelected", function (plan, planOptions) {
			var callback, oldSubscription, usage, _ref;
			callback = function () {
				return workflow.collectData({
					productData: {
						plan: plan,
						planOptions: planOptions
					}
				})
			};
			oldSubscription = workflow.collector.data.oldSubscription;
			if (oldSubscription) {
				usage = null != (_ref = null != oldSubscription ? oldSubscription.usage : void 0) ? _ref : {};
				return plan.checkQuota({
					usage: usage
				}, function (err) {
					return KD.showError(err) ? void 0 : callback()
				})
			}
			return callback()
		}).on("CurrentSubscriptionSet", function (oldSubscription) {
			return workflow.collectData({
				oldSubscription: oldSubscription
			})
		});
		workflow.on("DataCollected", function (_this) {
			return function (data) {
				return _this.transitionSubscription(data, function () {
					var err, rest, subscription;
					err = arguments[0], subscription = arguments[1], rest = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
					if (err) return workflow.emit("Failed", err);
					err || workflow.emit("SubscriptionTransitionCompleted", subscription);
					return workflow.emit.apply(workflow, ["Finished", data, err, subscription].concat(__slice.call(rest)))
				})
			}
		}(this)).on("Finished", function (_this) {
			return function () {
				var JUser, billing, createAccount, data, email, err, existingSubscription, firstName, lastName, plan, rest, subscription, _ref;
				data = arguments[0], err = arguments[1], subscription = arguments[2], rest = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
				plan = data.plan, email = data.email, createAccount = data.createAccount, _ref = data.paymentMethod, billing = _ref.billing;
				if ("existing_subscription" === (null != err ? err.short : void 0)) {
					existingSubscription = err.existingSubscription;
					if ("active" === existingSubscription.status) {
						new KDNotificationView({
							title: "You are already subscribed to this plan!"
						});
						KD.getSingleton("router").handleRoute("/Account/Subscriptions")
					} else {
						existingSubscription.plan = plan;
						_this.confirmReactivation(existingSubscription, function (err, subscription) {
							return err ? KD.showError(err) : _this.emit("SubscriptionReactivated", subscription)
						})
					}
				} else if (createAccount) {
					firstName = billing.cardFirstName, lastName = billing.cardLastName;
					JUser = KD.remote.api.JUser;
					JUser.convert({
						firstName: firstName,
						lastName: lastName,
						email: email
					}, function (err) {
						return err ? KD.showError(err) : JUser.logout(function () {})
					})
				} else _this.emit("SubscriptionCompleted");
				return KD.singletons.dock.getView().show()
			}
		}(this)).enter();
		return workflow
	};
	PaymentController.prototype.confirmReactivation = function (subscription, callback) {
		var modal;
		return modal = KDModalView.confirm({
			title: "Inactive subscription",
			description: "Your existing subscription for this plan has been canceled.  Would\nyou like to reactivate it?",
			subView: new SubscriptionView({}, subscription),
			ok: {
				title: "Reactivate",
				callback: function () {
					return subscription.resume(function (err) {
						if (err) return callback(err);
						modal.destroy();
						return callback(null, subscription)
					})
				}
			}
		})
	};
	PaymentController.prototype.createSubscription = function (options, callback) {
		var paymentMethod, paymentMethodId, plan, planApi, planOptions, promotionType;
		plan = options.plan, planOptions = options.planOptions, promotionType = options.promotionType, paymentMethod = options.paymentMethod;
		paymentMethodId = paymentMethod.paymentMethodId;
		null == planOptions && (planOptions = {});
		planApi = planOptions.planApi;
		options = {
			planOptions: planOptions,
			promotionType: promotionType,
			paymentMethodId: paymentMethodId,
			planCode: plan.planCode
		};
		return planApi ? planApi.subscribe(options, callback) : plan.subscribe(paymentMethodId, planOptions, callback)
	};
	PaymentController.prototype.transitionSubscription = function (formData, callback) {
		var createAccount, email, oldSubscription, paymentMethod, paymentMethodId, plan, planCode, planOptions, productData, promotionType;
		productData = formData.productData, oldSubscription = formData.oldSubscription, promotionType = formData.promotionType, paymentMethod = formData.paymentMethod, createAccount = formData.createAccount, email = formData.email;
		plan = productData.plan, planOptions = productData.planOptions;
		planCode = plan.planCode;
		paymentMethodId = paymentMethod.paymentMethodId;
		return oldSubscription ? oldSubscription.transitionTo({
			planCode: planCode,
			paymentMethodId: paymentMethodId
		}, callback) : this.createSubscription({
			plan: plan,
			planOptions: planOptions,
			promotionType: promotionType,
			email: email,
			paymentMethod: paymentMethod,
			createAccount: createAccount
		}, callback)
	};
	PaymentController.prototype.debitSubscription = function (subscription, pack, callback) {
		return subscription.debit({
			pack: pack
		}, function (_this) {
			return function (err, nonce) {
				if (err) return callback(err);
				_this.emit("SubscriptionDebited", subscription);
				return callback(null, nonce)
			}
		}(this))
	};
	PaymentController.prototype.creditSubscription = function (subscription, pack, callback) {
		return subscription.credit({
			pack: pack
		}, function (_this) {
			return function (err) {
				if (err) return callback(err);
				_this.emit("SubscriptionCredited", subscription);
				return callback()
			}
		}(this))
	};
	PaymentController.prototype.fetchActiveSubscription = function (tags, callback) {
		var status, _ref;
		if ("koding" === (null != (_ref = KD.getGroup()) ? _ref.slug : void 0)) {
			if ("registered" !== KD.whoami().type) return callback();
			status = {
				$in: ["active", "canceled"]
			};
			return this.fetchSubscriptionsWithPlans({
				tags: tags,
				status: status
			}, function (err, subscriptions) {
				var active, noSync, subscription, _i, _len;
				if (err) return callback(err);
				noSync = null;
				active = null;
				for (_i = 0, _len = subscriptions.length; _len > _i; _i++) {
					subscription = subscriptions[_i];
					__indexOf.call(subscription.tags, "nosync") >= 0 ? noSync = subscription : active = subscription
				}
				subscription = active || noSync;
				return subscription ? callback(null, subscription) : callback({
					message: "Subscription not found",
					code: "no subscription"
				})
			})
		}
		return this.fetchGroupSubscription(callback)
	};
	PaymentController.prototype.fetchGroupSubscription = function (callback) {
		return KD.getGroup().fetchSubscription(callback)
	};
	PaymentController.prototype.fetchSubscriptionsWithPlans = function (options, callback) {
		var _ref;
		callback || (_ref = [options, callback], callback = _ref[0], options = _ref[1]);
		null == options && (options = {});
		return KD.whoami().fetchPlansAndSubscriptions(options, function (_this) {
			return function (err, plansAndSubs) {
				var subscriptions;
				if (err) return callback(err);
				subscriptions = _this.groupPlansBySubscription(plansAndSubs).subscriptions;
				return callback(null, subscriptions)
			}
		}(this))
	};
	PaymentController.prototype.groupPlansBySubscription = function (plansAndSubscriptions) {
		var plans, plansByCode, subscription, subscriptions, _i, _len;
		null == plansAndSubscriptions && (plansAndSubscriptions = {});
		plans = plansAndSubscriptions.plans, subscriptions = plansAndSubscriptions.subscriptions;
		plansByCode = plans.reduce(function (memo, plan) {
			memo[plan.planCode] = plan;
			return memo
		}, {});
		for (_i = 0, _len = subscriptions.length; _len > _i; _i++) {
			subscription = subscriptions[_i];
			subscription.plan = plansByCode[subscription.planCode]
		}
		return {
			plans: plans,
			subscriptions: subscriptions
		}
	};
	PaymentController.prototype.canDebitPack = function (options, callback) {
		var multiplyFactor, packTag, subscriptionTag;
		null == options && (options = {});
		null == callback && (callback = noop);
		subscriptionTag = options.subscriptionTag, packTag = options.packTag, multiplyFactor = options.multiplyFactor;
		null == multiplyFactor && (multiplyFactor = 1);
		return subscriptionTag || packTag ? this.fetchActiveSubscription({
			tags: subscriptionTag
		}, function (err, subscription) {
			return KD.remote.api.JPaymentPack.one({
				tags: packTag
			}, function (err, pack) {
				return subscription.checkUsage(pack, multiplyFactor, callback)
			})
		}) : warn("missing parameters")
	};
	return PaymentController
}(KDController);
var PaymentMethodView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
PaymentMethodView = function (_super) {
	function PaymentMethodView(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("payment-method", options.cssClass);
		PaymentMethodView.__super__.constructor.call(this, options, data);
		this.loader = new KDLoaderView({
			size: {
				width: 14
			},
			showLoader: null == data
		});
		this.paymentMethodInfo = new KDCustomHTMLView({
			cssClass: "billing-link"
		});
		this.paymentMethodInfo.hide();
		this.setPaymentInfo(data)
	}
	__extends(PaymentMethodView, _super);
	PaymentMethodView.prototype.click = function () {
		return this.emit("PaymentMethodChosen", this.getData())
	};
	PaymentMethodView.prototype.getCardInfoPartial = function (paymentMethod) {
		var address, address1, address2, cardFirstName, cardLastName, cardMonth, cardNumber, cardType, cardYear, city, description, numberPrefix, postal, state, type, zip;
		if (!paymentMethod) return "Enter billing information";
		description = paymentMethod.description, cardFirstName = paymentMethod.cardFirstName, cardLastName = paymentMethod.cardLastName, cardNumber = paymentMethod.cardNumber, cardType = paymentMethod.cardType, cardYear = paymentMethod.cardYear, cardMonth = paymentMethod.cardMonth, address1 = paymentMethod.address1, address2 = paymentMethod.address2, city = paymentMethod.city, state = paymentMethod.state, zip = paymentMethod.zip;
		type = KD.utils.slugify(cardType).toLowerCase();
		this.setClass(type);
		address = [address1, address2].filter(Boolean).join("<br>");
		null == description && (description = "" + cardFirstName + "'s " + cardType);
		postal = [city, state, zip].filter(Boolean).join(" ");
		cardMonth = ("0" + cardMonth).slice(-2);
		cardYear = ("" + cardYear).slice(-2);
		numberPrefix = "american-express" === type ? "**** ****** *" : "**** **** **** ";
		return "<pre>" + numberPrefix + cardNumber.slice(-4) + "</pre>\n<pre>" + cardFirstName + " " + cardLastName + "</pre>\n<pre>" + cardMonth + "/" + cardYear + "</pre>"
	};
	PaymentMethodView.prototype.setPaymentInfo = function (paymentMethod) {
		this.loader.hide();
		paymentMethod && this.setData(paymentMethod);
		this.paymentMethodInfo.updatePartial(this.getCardInfoPartial(null != paymentMethod ? paymentMethod.billing : void 0));
		return this.paymentMethodInfo.show()
	};
	PaymentMethodView.prototype.pistachio = function () {
		return "{{> this.loader}}\n{{> this.paymentMethodInfo}}"
	};
	return PaymentMethodView
}(JView);
var SubscriptionView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
SubscriptionView = function (_super) {
	function SubscriptionView() {
		return SubscriptionView.__super__.constructor.apply(this, arguments)
	}
	var datePattern, describeSubscription;
	__extends(SubscriptionView, _super);
	describeSubscription = function (quantity, verbPhrase) {
		return "Subscription for " + KD.utils.formatPlural(quantity, "plan") + " " + verbPhrase
	};
	datePattern = "mmmm dS, yyyy, h:MM TT";
	SubscriptionView.prototype.pistachio = function () {
		var dateNotice, displayAmount, expires, feeAmount, plan, quantity, renewAt, startsAt, status, statusNotice, _ref;
		_ref = this.getData(), feeAmount = _ref.feeAmount, quantity = _ref.quantity, plan = _ref.plan, status = _ref.status, renewAt = _ref.renewAt, expires = _ref.expires, startsAt = _ref.startsAt;
		feeAmount || (feeAmount = plan.feeAmount);
		statusNotice = function () {
			switch (status) {
			case "active":
			case "modified":
				return describeSubscription(quantity, "is active");
			case "canceled":
				return describeSubscription(quantity, "will end soon");
			case "future":
				return describeSubscription(quantity, "will begin soon");
			default:
				return ""
			}
		}();
		dateNotice = __indexOf.call(plan.tags, "nosync") >= 0 ? "" : function () {
			if ("single" === plan.type) return "";
			switch (status) {
			case "active":
				return "Will renew on " + dateFormat(renewAt, datePattern);
			case "canceled":
				return "Will be available till " + dateFormat(expires || renewAt, datePattern);
			case "future":
				return "Will become available on " + dateFormat(startsAt, datePattern)
			}
		}();
		displayAmount = KD.utils.formatMoney(feeAmount / 100);
		return '<h4>{{#(plan.title)}}</h4>\n<span class="price">' + displayAmount + "</span>\n<p>" + dateNotice + "</p>"
	};
	return SubscriptionView
}(JView);
var SubscriptionUsageView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
SubscriptionUsageView = function (_super) {
	function SubscriptionUsageView() {
		return SubscriptionUsageView.__super__.constructor.apply(this, arguments)
	}
	__extends(SubscriptionUsageView, _super);
	SubscriptionUsageView.prototype.fetchProductList = function (callback) {
		var list, options, plan, subscription;
		subscription = this.getData();
		plan = subscription.plan;
		list = [];
		options = {
			targetOptions: {
				selector: {
					planCode: {
						$in: Object.keys(plan.quantities)
					},
					tags: {
						$in: ["vm"]
					}
				}
			}
		};
		return plan.fetchProducts(null, options, function (err, products) {
			var product, _i, _len;
			if (!KD.showError(err)) {
				for (_i = 0, _len = products.length; _len > _i; _i++) {
					product = products[_i];
					list.push({
						product: product,
						subscription: subscription
					})
				}
				return callback(list)
			}
		})
	};
	SubscriptionUsageView.prototype.viewAppended = function () {
		var controller, title;
		this.setClass("subscription-gauges");
		title = __indexOf.call(this.getData().tags, "custom-plan") >= 0 ? "Group resources" : "Your resource packs";
		this.addSubView(new KDCustomHTMLView({
			tagName: "span",
			cssClass: "title",
			partial: title
		}));
		controller = new KDListViewController({
			itemClass: SubscriptionGaugeItem
		});
		this.addSubView(controller.getView());
		return this.fetchProductList(function (list) {
			return controller.instantiateListItems(list)
		})
	};
	return SubscriptionUsageView
}(KDView);
var SubscriptionGaugeItem, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
SubscriptionGaugeItem = function (_super) {
	function SubscriptionGaugeItem(options, data) {
		var product;
		null == options && (options = {});
		SubscriptionGaugeItem.__super__.constructor.call(this, options, data);
		product = data.product, this.subscription = data.subscription;
		this.productKey = product.planCode;
		this.progressBar = new KDProgressBarView({
			determinate: !0,
			initial: this.calculateUsageRatio(),
			title: this.getProgressBarTitle()
		});
		this.subscription.on("update", this.bound("updateProgressBar"))
	}
	__extends(SubscriptionGaugeItem, _super);
	SubscriptionGaugeItem.prototype.updateProgressBar = function () {
		return this.progressBar.updateBar(this.calculateUsageRatio(), "%", this.getProgressBarTitle())
	};
	SubscriptionGaugeItem.prototype.getProgressBarTitle = function () {
		var quantities, usage, _ref;
		_ref = this.subscription, usage = _ref.usage, quantities = _ref.quantities;
		return "" + (usage[this.productKey] || 0) + " / " + quantities[this.productKey]
	};
	SubscriptionGaugeItem.prototype.calculateUsageRatio = function () {
		var quantities, ratio, usage, _ref;
		_ref = this.subscription, usage = _ref.usage, quantities = _ref.quantities;
		ratio = usage[this.productKey] / quantities[this.productKey];
		isNaN(ratio) && (ratio = 0);
		return 100 * ratio
	};
	SubscriptionGaugeItem.prototype.viewAppended = function () {
		var title;
		title = this.getData().product.title;
		this.setClass(KD.utils.slugify(title));
		this.addSubView(new KDLabelView({
			title: title
		}));
		return this.addSubView(this.progressBar)
	};
	return SubscriptionGaugeItem
}(KDListItemView);
var PaymentMethodEntryForm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
PaymentMethodEntryForm = function (_super) {
	function PaymentMethodEntryForm(options) {
		var expiresMonth, expiresYear, fields, thisYear, twoDigitsYear;
		null == options && (options = {});
		thisYear = expiresYear = (new Date).getFullYear();
		expiresMonth = (new Date).getMonth() + 2;
		if (expiresMonth > 12) {
			expiresYear += 1;
			expiresMonth %= 12
		}
		fields = {
			cardFirstName: {
				placeholder: "First name",
				defaultValue: KD.whoami().profile.firstName,
				validate: {
					notifications: !0,
					event: "blur",
					rules: {
						required: !0
					},
					messages: {
						required: "First name is required!"
					}
				},
				keyup: this.bound("updateDescription"),
				cssClass: "card-name",
				nextElementFlat: {
					cardLastName: {
						placeholder: "Last name",
						defaultValue: KD.whoami().profile.lastName,
						validate: {
							notifications: !0,
							event: "blur",
							rules: {
								required: !0
							},
							messages: {
								required: "Last name is required!"
							}
						}
					}
				}
			},
			cardNumber: {
				placeholder: "Credit card number",
				blur: function () {
					this.oldValue = this.getValue();
					return this.setValue(this.oldValue.replace(/\s|-/g, ""))
				},
				focus: function () {
					return this.oldValue ? this.setValue(this.oldValue) : void 0
				},
				validate: {
					notifications: !0,
					event: "blur",
					rules: {
						creditCard: !0,
						maxLength: 16
					},
					messages: {
						maxLength: "Credit card number should be 12 to 16 digits long!"
					}
				}
			},
			cardMonth: {
				placeholder: "MM",
				maxLength: 2,
				validate: {
					notifications: !0,
					event: "blur",
					rules: {
						maxLength: 2
					},
					messages: {
						regExp: "Expiration month should be 2 digits and between 01 to 12"
					}
				},
				nextElementFlat: {
					cardYear: {
						placeholder: "YY",
						maxLength: 2,
						validate: {
							notifications: !0,
							event: "blur",
							rules: {
								regExp: function () {
									var twoDigitsYear, yearOptions, _results;
									twoDigitsYear = (new Date).getFullYear() % 100;
									yearOptions = function () {
										_results = [];
										for (var _i = twoDigitsYear, _ref = twoDigitsYear + 15; _ref >= twoDigitsYear ? _ref > _i : _i > _ref; _ref >= twoDigitsYear ? _i++ : _i--) _results.push(_i);
										return _results
									}.apply(this).join("|");
									return RegExp("" + yearOptions)
								}()
							},
							messages: {
								regExp: "Expiration year should be between " + (twoDigitsYear = (new Date).getFullYear() % 100) + " to " + (twoDigitsYear + 14)
							}
						}
					}
				}
			},
			cardCV: {
				placeholder: "CVC",
				validate: {
					notifications: !0,
					event: "blur",
					rules: {
						regExp: /^[0-9]{3,4}$/
					},
					messages: {
						regExp: "Card verification code (CVC) should be a 3 or 4-digit number!"
					}
				}
			}
		};
		PaymentMethodEntryForm.__super__.constructor.call(this, {
			cssClass: KD.utils.curry("payment-method-entry-form", options.cssClass),
			name: "method",
			fields: fields,
			callback: function (_this) {
				return function (formData) {
					return _this.emit("PaymentInfoSubmitted", _this.paymentMethodId, formData)
				}
			}(this),
			buttons: {
				Save: {
					title: "ADD CARD",
					style: "solid medium green",
					type: "submit",
					loader: !0
				},
				BACK: {
					style: "medium solid light-gray to-left",
					callback: function (_this) {
						return function () {
							return _this.parent.showForm("choice")
						}
					}(this)
				}
			}
		})
	}
	__extends(PaymentMethodEntryForm, _super);
	PaymentMethodEntryForm.prototype.viewAppended = function () {
		var cardNumberInput;
		PaymentMethodEntryForm.__super__.viewAppended.call(this);
		cardNumberInput = this.inputs.cardNumber;
		cardNumberInput.on("keyup", this.bound("handleCardKeyup"));
		this.on("FormValidationFailed", function (_this) {
			return function () {
				KD.utils.wait(500, function () {
					return _this.unsetClass("animate shake")
				});
				_this.setClass("animate shake");
				return _this.buttons.Save.hideLoader()
			}
		}(this));
		cardNumberInput.on("ValidationError", function () {
			return this.parent.unsetClass("visa mastercard amex diners discover jcb")
		});
		cardNumberInput.on("CreditCardTypeIdentified", function (type) {
			var cardType;
			this.parent.unsetClass("visa mastercard amex diners discover jcb");
			cardType = type.toLowerCase();
			return this.parent.setClass(cardType)
		});
		this.fields.cardNumber.addSubView(this.icon = new KDCustomHTMLView({
			tagName: "span",
			cssClass: "icon"
		}));
		return this.updateDescription()
	};
	PaymentMethodEntryForm.prototype.activate = function () {
		var cardFirstName, cardLastName, cardNumber, input, _i, _len, _ref, _ref1;
		_ref = this.inputs, cardFirstName = _ref.cardFirstName, cardLastName = _ref.cardLastName, cardNumber = _ref.cardNumber;
		_ref1 = [cardFirstName, cardLastName, cardNumber];
		for (_i = 0, _len = _ref1.length; _len > _i; _i++) {
			input = _ref1[_i];
			if (!input.getValue()) return input.setFocus()
		}
	};
	PaymentMethodEntryForm.prototype.getCardInputValue = function () {
		return this.inputs.cardNumber.getValue().replace(/-|\s/g, "")
	};
	PaymentMethodEntryForm.prototype.getCardType = function (value) {
		null == value && (value = this.getCardInputValue());
		switch (!1) {
		case !/^4/.test(value):
			return "Visa";
		case !/^5[1-5]/.test(value):
			return "MasterCard";
		case !/^3[47]/.test(value):
			return "Amex";
		case !/^6(?:011|5[0-9]{2})/.test(value):
			return "Discover";
		default:
			return "Unknown"
		}
	};
	PaymentMethodEntryForm.prototype.updateCardTypeDisplay = function (cardType) {
		var $icon;
		null == cardType && (cardType = this.getCardType());
		this.addCustomData("cardType", cardType);
		cardType = cardType.toLowerCase();
		$icon = this.icon.$();
		if (!$icon.hasClass(cardType)) {
			$icon.removeClass("visa mastercard discover amex unknown");
			cardType && $icon.addClass(cardType)
		}
		return this.updateDescription()
	};
	PaymentMethodEntryForm.prototype.updateDescription = function () {
		var cardFirstName, cardOwner, cardType, formData, inputs;
		inputs = this.inputs;
		formData = this.getData();
		cardFirstName = inputs.cardFirstName.getValue();
		cardType = function () {
			switch (formData.cardType) {
			case "Unknown":
			case void 0:
				return "credit card";
			default:
				return formData.cardType
			}
		}();
		return cardOwner = cardFirstName ? "" + cardFirstName + "'s " : ""
	};
	PaymentMethodEntryForm.prototype.handleCardKeyup = function () {
		return this.updateCardTypeDisplay()
	};
	PaymentMethodEntryForm.prototype.setPaymentInfo = function (paymentMethod) {
		var key, value, _ref, _ref1, _ref2, _results;
		this.paymentMethodId = paymentMethod.paymentMethodId;
		_ref = paymentMethod.billing;
		_results = [];
		for (key in _ref)
			if (__hasProp.call(_ref, key)) {
				value = _ref[key];
				switch (key) {
				case "state":
					_results.push(this.addCustomData("actualState", value));
					break;
				case "cardType":
					_results.push(this.updateCardTypeDisplay(value));
					break;
				case "cardNumber":
				case "cardCV":
					_results.push(null != (_ref1 = this.inputs[key]) ? _ref1.setPlaceHolder(value) : void 0);
					break;
				case "address2":
					break;
				default:
					_results.push(null != (_ref2 = this.inputs[key]) ? _ref2.setValue(value) : void 0)
				}
			}
		return _results
	};
	PaymentMethodEntryForm.prototype.clearValidation = function () {
		var input, inputs, _i, _len, _results;
		inputs = KDFormView.findChildInputs(this);
		_results = [];
		for (_i = 0, _len = inputs.length; _len > _i; _i++) {
			input = inputs[_i];
			_results.push(input.clearValidationFeedback())
		}
		return _results
	};
	return PaymentMethodEntryForm
}(KDFormViewWithFields);
var PaymentChoiceForm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
PaymentChoiceForm = function (_super) {
	function PaymentChoiceForm(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("pricing-payment-choice clearfix", options.cssClass);
		options.name = "method";
		PaymentChoiceForm.__super__.constructor.call(this, options, data)
	}
	__extends(PaymentChoiceForm, _super);
	PaymentChoiceForm.prototype.activate = function (activator) {
		return this.emit("Activated", activator)
	};
	PaymentChoiceForm.prototype.setPaymentMethods = function (paymentMethods) {
		var appStorage, method, methods, preferredPaymentMethod, view, _i, _len;
		this.paymentMethodsContainer.addSubView(new KDCustomHTMLView({
			cssClass: "new payment-method",
			partial: "Add a Payment method",
			click: this.lazyBound("emit", "PaymentMethodNotChosen")
		}));
		preferredPaymentMethod = paymentMethods.preferredPaymentMethod, methods = paymentMethods.methods, appStorage = paymentMethods.appStorage;
		for (_i = 0, _len = methods.length; _len > _i; _i++) {
			method = methods[_i];
			this.paymentMethodsContainer.addSubView(view = new PaymentMethodView(null, method));
			this.forwardEvent(view, "PaymentMethodChosen")
		}
		return this
	};
	PaymentChoiceForm.prototype.viewAppended = function () {
		this.addSubView(new KDCustomHTMLView({
			tagName: "h3",
			cssClass: "pricing-title",
			partial: "Choose a payment method"
		}));
		this.addSubView(new KDCustomHTMLView({
			tagName: "h6",
			cssClass: "pricing-subtitle",
			partial: "Click on one of your credit cards to use it or add a new one"
		}));
		return this.addSubView(this.paymentMethodsContainer = new KDCustomHTMLView({
			cssClass: "payment-methods"
		}))
	};
	return PaymentChoiceForm
}(KDView);
var PaymentFormModal, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
PaymentFormModal = function (_super) {
	function PaymentFormModal(options, data) {
		null == options && (options = {});
		null == data && (data = {});
		options.title || (options.title = "Billing information");
		options.width || (options.width = 779);
		options.height || (options.height = "auto");
		options.cssClass || (options.cssClass = "payments-modal");
		null == options.overlay && (options.overlay = !0);
		PaymentFormModal.__super__.constructor.call(this, options, data)
	}
	__extends(PaymentFormModal, _super);
	PaymentFormModal.prototype.viewAppended = function () {
		this.mainLoader = new KDLoaderView({
			showLoader: !0,
			size: {
				width: 14
			}
		});
		this.addSubView(this.mainLoader);
		this.useExistingView = new PaymentChoiceForm;
		this.useExistingView.hide();
		this.addSubView(this.useExistingView);
		this.useExistingView.on("PaymentMethodNotChosen", function (_this) {
			return function () {
				_this.useExistingView.hide();
				return _this.paymentForm.show()
			}
		}(this));
		this.forwardEvent(this.useExistingView, "PaymentMethodChosen");
		this.paymentForm = new PaymentMethodEntryForm;
		this.paymentForm.hide();
		this.addSubView(this.paymentForm);
		this.forwardEvent(this.paymentForm, "PaymentInfoSubmitted");
		return PaymentFormModal.__super__.viewAppended.call(this)
	};
	PaymentFormModal.prototype.setState = function (state, data) {
		this.mainLoader.hide();
		switch (state) {
		case "editExisting":
			this.paymentForm.setPaymentInfo(data);
			return this.paymentForm.show();
		case "selectPersonal":
			this.useExistingView.setPaymentMethods(data);
			return this.useExistingView.show();
		default:
			return this.paymentForm.show()
		}
	};
	PaymentFormModal.prototype.setPaymentInfo = function (paymentMethod) {
		return this.paymentForm.setPaymentInfo(paymentMethod)
	};
	PaymentFormModal.prototype.handleRecurlyResponse = function (callback, err) {
		var e, input, recurlyFieldMap, _i, _len, _ref, _results;
		this.paymentForm.buttons.Save.hideLoader();
		recurlyFieldMap = {
			first_name: "cardFirstName",
			last_name: "cardLastName",
			number: "cardNumber",
			verification_value: "cardCV"
		};
		_results = [];
		for (_i = 0, _len = err.length; _len > _i; _i++) {
			e = err[_i];
			if (recurlyFieldMap[e.field]) {
				input = this.paymentForm.inputs[recurlyFieldMap[e.field]];
				input.giveValidationFeedback(!0);
				_results.push(input.showValidationError("" + (null != (_ref = input.inputLabel) ? _ref.getTitle() : void 0) + " " + e.message))
			} else {
				input = this.paymentForm.inputs.cardNumber;
				input.showValidationError(e.message);
				_results.push(e.message.indexOf("card") > -1 ? input.giveValidationFeedback(!0) : void 0)
			}
		}
		return _results
	};
	PaymentFormModal.prototype.updateCardTypeDisplay = function (cardType) {
		return this.paymentForm.updateCardTypeDisplay(cardType)
	};
	return PaymentFormModal
}(KDModalView);
var VmProductView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
VmProductView = function (_super) {
	function VmProductView(options, data) {
		null == options && (options = {});
		VmProductView.__super__.constructor.call(this, options, data)
	}
	__extends(VmProductView, _super);
	VmProductView.prototype.pistachio = function () {
		return '<h3>{{#(title)}}</h3>\n<div>\n  {span{this.utils.formatMoney(#(feeAmount) / 100)}}\n  <span class="per-month">/ mo</span>\n</div>'
	};
	return VmProductView
}(JView);
var PaymentWorkflow, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
PaymentWorkflow = function (_super) {
	function PaymentWorkflow(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("payment-workflow", options.cssClass);
		if (!options.confirmForm) throw new Error("You must provide a confirmForm option!");
		PaymentWorkflow.__super__.constructor.call(this, options, data)
	}
	__extends(PaymentWorkflow, _super);
	PaymentWorkflow.prototype.preparePaymentMethods = function () {
		var paymentController;
		paymentController = KD.getSingleton("paymentController");
		this.showLoader();
		return paymentController.fetchPaymentMethods(function (_this) {
			return function (err, paymentMethods) {
				_this.hideLoader();
				return KD.showError(err) ? void 0 : paymentMethods.methods.length > 0 ? _this.getForm("choice").setPaymentMethods(paymentMethods) : _this.clearData("paymentMethod")
			}
		}(this))
	};
	PaymentWorkflow.prototype.createChoiceForm = function (options, data) {
		var form;
		form = new PaymentChoiceForm(options, data);
		form.once("Activated", function (_this) {
			return function () {
				return _this.preparePaymentMethods()
			}
		}(this));
		form.on("PaymentMethodChosen", function (_this) {
			return function (paymentMethod) {
				return _this.collectData({
					paymentMethod: paymentMethod
				})
			}
		}(this));
		form.on("PaymentMethodNotChosen", function (_this) {
			return function () {
				return _this.clearData("paymentMethod")
			}
		}(this));
		return form
	};
	PaymentWorkflow.prototype.createEntryForm = function (options, data) {
		var form, payment;
		form = new PaymentMethodEntryForm(options, data);
		payment = KD.getSingleton("paymentController");
		payment.observePaymentSave(form, function (_this) {
			return function (err, paymentMethod) {
				return KD.showError(err) ? void 0 : _this.collectData({
					paymentMethod: paymentMethod
				})
			}
		}(this));
		return form
	};
	PaymentWorkflow.prototype.prepareWorkflow = function () {
		var all, any, confirmForm, existingAccountWorkflow, productForm, _ref;
		all = Junction.all, any = Junction.any;
		this.requireData(["productData", any("createAccount", "loggedIn"), any("paymentMethod", "subscription"), "userConfirmation"]);
		if ("unregistered" === KD.whoami().type) {
			existingAccountWorkflow = new ExistingAccountWorkflow({
				name: "login"
			});
			existingAccountWorkflow.on("DataCollected", this.bound("collectData"));
			this.addForm("createAccount", existingAccountWorkflow, ["createAccount", "loggedIn"])
		} else this.addForm("existingAccount", this.skip({
			loggedIn: !0
		}), ["createAccount", "loggedIn"]);
		_ref = this.getOptions(), productForm = _ref.productForm, confirmForm = _ref.confirmForm;
		if (null != productForm) {
			this.addForm("product", productForm, ["productData", "subscription"]);
			productForm.on("DataCollected", function (_this) {
				return function (productData) {
					var oldSubscription, subscription;
					_this.collectData({
						productData: productData
					});
					subscription = productData.subscription, oldSubscription = productData.oldSubscription;
					subscription && _this.collectData({
						subscription: subscription
					});
					return oldSubscription ? _this.collectData({
						oldSubscription: oldSubscription
					}) : void 0
				}
			}(this))
		}
		this.addForm("choice", this.createChoiceForm(), ["paymentMethod"]);
		this.addForm("entry", this.createEntryForm(), ["paymentMethod"]);
		this.addForm("confirm", confirmForm, ["userConfirmation"]);
		confirmForm.on("CouponOptionChanged", function (_this) {
			return function (name) {
				return _this.collectData({
					promotionType: name
				})
			}
		}(this));
		confirmForm.on("PaymentConfirmed", function (_this) {
			return function () {
				return _this.collectData({
					userConfirmation: !0
				})
			}
		}(this));
		this.forwardEvent(confirmForm, "Cancel");
		return this
	};
	return PaymentWorkflow
}(FormWorkflow);
var PaymentConfirmForm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
PaymentConfirmForm = function (_super) {
	function PaymentConfirmForm(options, data) {
		null == options && (options = {});
		PaymentConfirmForm.__super__.constructor.call(this, options, data);
		this.buttonBar = new KDButtonBar({
			buttons: {
				Buy: {
					title: "PLACE YOUR ORDER",
					style: "solid medium green",
					loader: !0,
					callback: function (_this) {
						return function () {
							_this.buttonBar.buttons.Buy.showLoader();
							return _this.emit("PaymentConfirmed")
						}
					}(this)
				},
				cancel: {
					title: "CANCEL",
					style: "solid medium light-gray",
					callback: function (_this) {
						return function () {
							return _this.emit("Cancel")
						}
					}(this)
				}
			}
		})
	}
	__extends(PaymentConfirmForm, _super);
	PaymentConfirmForm.prototype.getExplanation = function () {};
	return PaymentConfirmForm
}(JView);
var GenericPlanView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
GenericPlanView = function (_super) {
	function GenericPlanView(options, data) {
		null == options && (options = {});
		null == data && (data = {});
		options.cssClass = KD.utils.curry("generic-plan-view", options.cssClass);
		null == options.hiddenPrice && (options.hiddenPrice = !1);
		GenericPlanView.__super__.constructor.call(this, options, data)
	}
	__extends(GenericPlanView, _super);
	GenericPlanView.prototype.pistachio = function () {
		var data, hiddenPrice, planOptions, total, _ref;
		data = this.getData();
		_ref = this.getOptions(), planOptions = _ref.planOptions, hiddenPrice = _ref.hiddenPrice;
		total = (null != planOptions ? planOptions.total : void 0) ? planOptions.total : data.feeAmount;
		total = KD.utils.formatMoney(total / 100);
		this.productList = new PlanProductListView({
			planOptions: planOptions
		}, data);
		return '{h4{#(description) || #(plan.description)}}\n{{> this.productList}}\n<span class="price' + (hiddenPrice ? " hidden" : "") + '">' + total + "</span>"
	};
	return GenericPlanView
}(JView);
var PlanUpgradeForm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
PlanUpgradeForm = function (_super) {
	function PlanUpgradeForm() {
		return PlanUpgradeForm.__super__.constructor.apply(this, arguments)
	}
	__extends(PlanUpgradeForm, _super);
	PlanUpgradeForm.prototype.setPlans = function (plans) {
		this.listController.instantiateListItems(plans);
		return this
	};
	PlanUpgradeForm.prototype.setCurrentSubscription = function (subscription, options) {
		var code, lowerTier, view, _ref;
		null == options && (options = {});
		lowerTier = !0;
		_ref = this.planViewsByCode;
		for (code in _ref)
			if (__hasProp.call(_ref, code)) {
				view = _ref[code];
				if (code === subscription.planCode) {
					"function" == typeof view.activate && view.activate();
					"function" == typeof view.disable && view.disable();
					lowerTier = !1
				} else options.forceUpgrade && lowerTier && "function" == typeof view.disable && view.disable()
			}
		this.emit("CurrentSubscriptionSet", subscription);
		return this
	};
	PlanUpgradeForm.prototype.viewAppended = function () {
		this.listController = new KDListViewController({
			itemClass: GroupPlanListItem
		});
		this.listView = this.listController.getListView();
		this.planViewsByCode = {};
		this.listView.on("ItemWasAdded", function (_this) {
			return function (item) {
				var plan;
				plan = item.getData();
				_this.planViewsByCode[plan.planCode] = item;
				return item.setControls(new KDButtonView({
					title: "Upgrade",
					style: "small solid green",
					callback: function () {
						return _this.emit("PlanSelected", plan)
					}
				}))
			}
		}(this));
		return PlanUpgradeForm.__super__.viewAppended.call(this)
	};
	PlanUpgradeForm.prototype.pistachio = function () {
		return "<h2>\n  Upgrade your plan:\n</h2>\n{{> this.listView}}"
	};
	return PlanUpgradeForm
}(JView);
var PlanUpgradeConfirmForm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
PlanUpgradeConfirmForm = function (_super) {
	function PlanUpgradeConfirmForm(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("plan-upgrade-confirm-form", options.cssClass);
		PlanUpgradeConfirmForm.__super__.constructor.call(this, options, data);
		this.coupons = {};
		this.buttonBar = new KDButtonBar({
			buttons: {
				Buy: {
					title: "PLACE YOUR ORDER",
					style: "solid medium green",
					loader: !0,
					callback: function (_this) {
						return function () {
							_this.buttonBar.buttons.Buy.showLoader();
							return _this.emit("PaymentConfirmed")
						}
					}(this)
				},
				cancel: {
					title: "CANCEL",
					style: "solid medium light-gray",
					callback: function (_this) {
						return function () {
							return _this.emit("Cancel")
						}
					}(this)
				}
			}
		})
	}
	__extends(PlanUpgradeConfirmForm, _super);
	PlanUpgradeConfirmForm.prototype.viewAppended = function () {
		var data;
		this.unsetClass("kdview");
		data = this.getData();
		this.plan = new KDView({
			partial: '<h3 class="pricing-title">' + this.getExplanation("plan") + '</h3>\n<h6 class="pricing-subtitle">Almost there, review your purchase and get going</h6>'
		});
		return PlanUpgradeConfirmForm.__super__.viewAppended.call(this)
	};
	PlanUpgradeConfirmForm.prototype.getExplanation = function (key) {
		switch (key) {
		case "plan":
			return "You selected this plan";
		case "payment":
			return "This payment method will be charged";
		default:
			return PlanUpgradeConfirmForm.__super__.getExplanation.call(this, key)
		}
	};
	PlanUpgradeConfirmForm.prototype.activate = function (activator) {
		return this.setData(activator.getData())
	};
	PlanUpgradeConfirmForm.prototype.setData = function (data) {
		var couponCodes, oldSubscription, plan, planOptions, _ref, _ref1;
		if (null != (_ref = data.productData) ? _ref.plan : void 0) {
			_ref1 = data.productData, plan = _ref1.plan, planOptions = _ref1.planOptions, oldSubscription = data.oldSubscription;
			if (oldSubscription) {
				this.plan.addSubView(new KDCustomHTMLView({
					tagName: "h6",
					cssClass: "mini-title",
					partial: "Your current plan"
				}));
				this.plan.addSubView(new GenericPlanView({
					cssClass: "old-plan"
				}, oldSubscription.plan));
				this.plan.addSubView(new KDCustomHTMLView({
					tagName: "h6",
					cssClass: "mini-title",
					partial: "Upgrading to"
				}))
			}
			this.plan.addSubView(new GenericPlanView({
				planOptions: planOptions
			}, plan));
			couponCodes = plan.couponCodes;
			if (couponCodes && couponCodes.discount && couponCodes.vm) {
				this.plan.addSubView(this.giftWrapper = new KDCustomHTMLView({
					cssClass: "coupon-options clearfix hidden"
				}));
				this.giftWrapper.addSubView(new KDLabelView({
					title: "Select your gift",
					cssClass: "select-gift"
				}));
				this.fetchCoupons(plan, ["discount", "vm"], this.bound("addCouponOptions"))
			}
		} else this.plan.hide();
		return PlanUpgradeConfirmForm.__super__.setData.call(this, data)
	};
	PlanUpgradeConfirmForm.prototype.addCouponOptions = function () {
		var couponOptions, discount, discountInCents, subtotal, totalWrapper;
		if (Object.keys(this.coupons).length) {
			discountInCents = this.coupons.discount.discountInCents;
			this.giftWrapper.show();
			this.giftWrapper.addSubView(couponOptions = new KDInputRadioGroup({
				name: "coupon-options",
				radios: [{
					title: "" + this.coupons.discount.name,
					value: "discount"
				}, {
					title: "" + this.coupons.vm.name,
					value: "vm"
				}]
			}));
			couponOptions.on("change", this.bound("changeCouponOption"));
			this.plan.addSubView(totalWrapper = new KDCustomHTMLView({
				cssClass: "total-wrapper"
			}));
			totalWrapper.addSubView(discount = new KDCustomHTMLView({
				cssClass: "discount"
			}));
			discount.addSubView(new KDLabelView({
				title: "Discount"
			}));
			discount.addSubView(this.discount = new KDCustomHTMLView({
				tagName: "span",
				partial: this.utils.formatMoney(discountInCents / 100)
			}));
			totalWrapper.addSubView(subtotal = new KDCustomHTMLView({
				cssClass: "subtotal"
			}));
			subtotal.addSubView(new KDLabelView({
				title: "Subtotal"
			}));
			subtotal.addSubView(this.subtotal = new KDCustomHTMLView({
				tagName: "span",
				partial: (this.getData().productData.plan.feeAmount - this.utils.formatMoney(discountInCents)) / 100
			}));
			couponOptions.setDefaultValue("discount");
			this.changeCouponOption("discount");
			return this.updateTotals(couponOptions.getValue())
		}
	};
	PlanUpgradeConfirmForm.prototype.changeCouponOption = function (name) {
		this.emit("CouponOptionChanged", name);
		return this.updateTotals(name)
	};
	PlanUpgradeConfirmForm.prototype.updateTotals = function (code) {
		var discountInCents, discountType, _ref;
		_ref = this.coupons[code], discountType = _ref.discountType, discountInCents = _ref.discountInCents;
		switch (discountType) {
		case "dollars":
			this.discount.updatePartial(this.utils.formatMoney(discountInCents / 100));
			return this.subtotal.updatePartial(this.utils.formatMoney((this.getData().productData.plan.feeAmount - discountInCents) / 100))
		}
	};
	PlanUpgradeConfirmForm.prototype.fetchCoupons = function (plan, codes, callback) {
		var dash, queue;
		dash = Bongo.dash;
		queue = codes.map(function (_this) {
			return function (code) {
				return function () {
					return plan.fetchCoupon(code, function (err, coupon) {
						if (!KD.showError(err)) {
							_this.coupons[code] = coupon;
							return queue.fin()
						}
					})
				}
			}
		}(this));
		return dash(queue, callback)
	};
	PlanUpgradeConfirmForm.prototype.pistachio = function () {
		return "{{> this.plan}}\n{{> this.buttonBar}}"
	};
	return PlanUpgradeConfirmForm
}(PaymentConfirmForm);
var PackChoiceForm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
PackChoiceForm = function (_super) {
	function PackChoiceForm() {
		return PackChoiceForm.__super__.constructor.apply(this, arguments)
	}
	__extends(PackChoiceForm, _super);
	PackChoiceForm.prototype.viewAppended = function () {
		var itemClass, title, _ref;
		_ref = this.getOptions(), title = _ref.title, itemClass = _ref.itemClass;
		this.titleView = new KDView({
			tagName: "h2",
			partial: title
		});
		this.listController = new KDListViewController({
			itemClass: itemClass
		});
		this.list = this.listController.getListView();
		this.list.on("ItemWasAdded", function (_this) {
			return function (item) {
				return item.on("PackSelected", function () {
					return _this.emit("PackSelected", item.getData())
				})
			}
		}(this));
		return PackChoiceForm.__super__.viewAppended.call(this)
	};
	PackChoiceForm.prototype.activate = function (activator) {
		return this.emit("Activated", activator)
	};
	PackChoiceForm.prototype.setContents = function (contents) {
		return this.listController.instantiateListItems(contents)
	};
	PackChoiceForm.prototype.pistachio = function () {
		return "{{> this.titleView}}\n{{> this.list}}"
	};
	return PackChoiceForm
}(JView);
var PlanProductListView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
PlanProductListView = function (_super) {
	function PlanProductListView() {
		return PlanProductListView.__super__.constructor.apply(this, arguments)
	}
	__extends(PlanProductListView, _super);
	PlanProductListView.prototype.viewAppended = function () {
		var planOptions, resourceQuantity, userQuantity;
		planOptions = this.getOptions().planOptions;
		if (planOptions) {
			resourceQuantity = planOptions.resourceQuantity, userQuantity = planOptions.userQuantity;
			if (userQuantity) {
				this.addSubView(new KDCustomHTMLView({
					partial: "" + userQuantity + "x User"
				}));
				return this.addSubView(new KDCustomHTMLView({
					partial: "" + resourceQuantity + "x Resource Packs"
				}))
			}
		}
	};
	return PlanProductListView
}(KDView);
var ExistingAccountForm, ExistingAccountWorkflow, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ExistingAccountForm = function (_super) {
	function ExistingAccountForm() {
		return ExistingAccountForm.__super__.constructor.apply(this, arguments)
	}
	__extends(ExistingAccountForm, _super);
	ExistingAccountForm.prototype.viewAppended = function () {
		KD.singletons.dock.getView().hide();
		this.loginForm = new LoginInlineForm({
			cssClass: "login-form clearfix",
			testPath: "login-form",
			callback: function (_this) {
				return function (credentials) {
					return KD.getSingleton("mainController").handleLogin(credentials, function (err) {
						_this.loginForm.button.hideLoader();
						if (!KD.showError(err)) {
							"undefined" != typeof localStorage && null !== localStorage && localStorage.setItem("routeToBeContinued", KD.singleton("router").currentPath);
							return _this.emit("DataCollected", {
								loggedIn: !0
							})
						}
						return (null != err ? err.field : void 0) in _this.loginForm ? _this.loginForm[err.field].decorateValidation(err) : void 0
					})
				}
			}(this)
		});
		this.emailCollectionForm = new KDFormViewWithFields({
			fields: {
				email: {
					cssClass: "thin",
					placeholder: "you@yourdomain.com",
					name: "email",
					testPath: "account-email-input",
					validate: {
						rules: {
							required: !0,
							email: !0
						},
						messages: {
							required: "You should write an email address",
							email: "This is not a valid email address"
						}
					}
				}
			},
			buttons: {
				"SIGN UP": {
					type: "submit",
					style: "solid green fr"
				}
			},
			callback: function (_this) {
				return function (_arg) {
					var email;
					email = _arg.email;
					return KD.remote.api.JUser.changeEmail({
						email: email
					}, function (err) {
						return KD.showError(err) ? void 0 : _this.emit("DataCollected", {
							createAccount: !0,
							email: email
						})
					})
				}
			}(this)
		});
		return ExistingAccountForm.__super__.viewAppended.apply(this, arguments)
	};
	ExistingAccountForm.prototype.pistachio = function () {
		return '<section class="pricing-sign-in clearfix">\n  <h3 class="pricing-title">Sign in or create an account to proceed with your checkout</h3>\n  {{> this.loginForm}}\n  <span class="divider">or</span>\n  {{> this.emailCollectionForm}}\n</section>'
	};
	return ExistingAccountForm
}(JView);
ExistingAccountWorkflow = function (_super) {
	function ExistingAccountWorkflow() {
		return ExistingAccountWorkflow.__super__.constructor.apply(this, arguments)
	}
	__extends(ExistingAccountWorkflow, _super);
	ExistingAccountWorkflow.prototype.prepareWorkflow = function () {
		this.requireData(Junction.any("createAccount", "loggedIn"));
		this.existingAccountForm = new ExistingAccountForm({
			name: "login"
		});
		this.existingAccountForm.on("DataCollected", this.bound("collectData"));
		this.addForm("existingAccount", this.existingAccountForm, ["createAccount", "loggedIn"]);
		return this.enter()
	};
	return ExistingAccountWorkflow
}(FormWorkflow);
var MainTabView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
MainTabView = function (_super) {
	function MainTabView(options, data) {
		options.resizeTabHandles = !0;
		options.lastTabHandleMargin = 40;
		options.sortable = !0;
		this.visibleHandles = [];
		this.totalSize = 0;
		MainTabView.__super__.constructor.call(this, options, data);
		this.router = KD.getSingleton("router");
		this.appManager = KD.getSingleton("appManager");
		this.appManager.on("AppIsBeingShown", function (_this) {
			return function (controller, view, options) {
				return view.parent ? _this.showPane(view.parent) : _this.createTabPane(options, view)
			}
		}(this))
	}
	__extends(MainTabView, _super);
	MainTabView.prototype.handleClicked = function (index, event) {
		var appInstance, appView, options, pane, quitOptions;
		pane = this.getPaneByIndex(index);
		appView = pane.getMainView();
		appInstance = this.appManager.getByView(appView);
		options = appInstance.getOptions();
		if ($(event.target).hasClass("close-tab")) {
			quitOptions = pane.mainView.quitOptions;
			quitOptions ? this.warnClosingMultipleTabs(appInstance, quitOptions) : this.appManager.quit(appInstance);
			return !1
		}
		return this.appManager.showInstance(appInstance)
	};
	MainTabView.prototype.removePane = function (pane) {
		var handle, index, isActivePane;
		index = this.getPaneIndex(pane);
		pane.emit("KDTabPaneDestroy");
		isActivePane = this.getActivePane() === pane;
		this.panes.splice(index, 1);
		pane.destroy();
		handle = this.getHandleByIndex(index);
		this.handles.splice(index, 1);
		null != handle && handle.destroy();
		this.emit("PaneRemoved");
		return this.router.handleRoute(this.router.currentPath)
	};
	MainTabView.prototype.createTabPane = function (options, mainView) {
		var domId, o, paneInstance;
		null == options && (options = {});
		o = {};
		o.cssClass = this.utils.curry("content-area-pane", options.cssClass);
		o["class"] || (o["class"] = KDView);
		domId = "maintabpane-" + this.utils.slugify(options.name);
		document.getElementById(domId) && (o.domId = domId);
		o.name = options.name;
		o.behavior = options.behavior;
		o.hiddenHandle = options.hiddenHandle;
		o.view = mainView;
		paneInstance = new MainTabPane(o);
		paneInstance.once("viewAppended", function (_this) {
			return function () {
				var appController, appInfo;
				_this.applicationPaneReady(paneInstance, mainView);
				appController = _this.appManager.getByView(mainView);
				appInfo = appController.getOptions().appInfo;
				return (null != appInfo ? appInfo.title : void 0) ? paneInstance.setTitle(appInfo.title) : void 0
			}
		}(this));
		this.addPane(paneInstance);
		return paneInstance
	};
	MainTabView.prototype.applicationPaneReady = function (pane, mainView) {
		"application" === pane.getOption("behavior") && mainView.setClass("application-page");
		return mainView.on("KDObjectWillBeDestroyed", this.removePane.bind(this, pane))
	};
	MainTabView.prototype.rearrangeVisibleHandlesArray = function () {
		var handle, _i, _len, _ref, _results;
		this.visibleHandles = [];
		_ref = this.handles;
		_results = [];
		for (_i = 0, _len = _ref.length; _len > _i; _i++) {
			handle = _ref[_i];
			_results.push(handle.getOptions().hidden ? void 0 : this.visibleHandles.push(handle))
		}
		return _results
	};
	MainTabView.prototype.warnClosingMultipleTabs = function (appInstance, quitOptions) {
		var content, modal, title;
		title = quitOptions.title || "Do you want to close multiple tabs?";
		content = quitOptions.message || "Please make sure that you saved all your work.";
		return modal = new KDModalView({
			cssClass: "modal-with-text",
			title: "" + title,
			content: "<p>" + content + "</p>",
			overlay: !0,
			buttons: {
				Close: {
					cssClass: "modal-clean-gray",
					title: "Close",
					callback: function (_this) {
						return function () {
							_this.appManager.quit(appInstance);
							return modal.destroy()
						}
					}(this)
				},
				Cancel: {
					cssClass: "modal-cancel",
					title: "Cancel",
					callback: function () {
						return function () {
							return modal.destroy()
						}
					}(this)
				}
			}
		})
	};
	return MainTabView
}(KDTabView);
var MainTabPane, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
MainTabPane = function (_super) {
	function MainTabPane(options, data) {
		this.id || (this.id = options.id);
		options.type = options.behavior;
		MainTabPane.__super__.constructor.call(this, options, data)
	}
	__extends(MainTabPane, _super);
	MainTabPane.prototype.show = function () {
		MainTabPane.__super__.show.apply(this, arguments);
		return KD.utils.defer(function (_this) {
			return function () {
				var body, documentElement;
				body = document.body, documentElement = document.documentElement;
				documentElement.scrollTop = _this.lastScrollTops.window;
				return body.scrollTop = _this.lastScrollTops.body
			}
		}(this))
	};
	MainTabPane.prototype.hide = function () {
		var body, documentElement;
		if (this.active) {
			body = document.body, documentElement = document.documentElement;
			this.lastScrollTops.window = documentElement.scrollTop;
			this.lastScrollTops.body = body.scrollTop;
			return MainTabPane.__super__.hide.apply(this, arguments)
		}
	};
	return MainTabPane
}(KDTabPaneView);
var MainTabHandleHolder, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
MainTabHandleHolder = function (_super) {
	function MainTabHandleHolder(options, data) {
		null == options && (options = {});
		options.bind = "mouseenter mouseleave";
		MainTabHandleHolder.__super__.constructor.call(this, options, data);
		this.userApps = []
	}
	__extends(MainTabHandleHolder, _super);
	MainTabHandleHolder.prototype.viewAppended = function () {
		var mainView;
		mainView = this.getDelegate();
		this.addPlusHandle();
		mainView.mainTabView.on("PaneDidShow", function (_this) {
			return function (event) {
				return _this._repositionPlusHandle(event)
			}
		}(this));
		mainView.mainTabView.on("PaneRemoved", function (_this) {
			return function () {
				return _this._repositionPlusHandle()
			}
		}(this));
		mainView.mainTabView.on("PaneAdded", function (_this) {
			return function (pane) {
				var tabHandle;
				tabHandle = pane.tabHandle;
				tabHandle.on("DragStarted", function () {
					return tabHandle.dragIsAllowed = _this.subViews.length <= 2 ? !1 : !0
				});
				tabHandle.on("DragInAction", function () {
					return tabHandle.dragIsAllowed ? _this.plusHandle.hide() : void 0
				});
				return tabHandle.on("DragFinished", function () {
					return _this.plusHandle.show()
				})
			}
		}(this));
		return this.listenWindowResize()
	};
	MainTabHandleHolder.prototype._windowDidResize = function () {
		var mainView;
		mainView = this.getDelegate();
		return this.setWidth(mainView.mainTabView.getWidth())
	};
	MainTabHandleHolder.prototype.addPlusHandle = function () {
		return this.addSubView(this.plusHandle = new KDCustomHTMLView({
			cssClass: "kdtabhandle add-editor-menu visible-tab-handle plus first last",
			partial: "<span class='icon'></span><b class='hidden'>Click here to start</b>",
			delegate: this,
			click: this.bound("createPlusHandleDropDown")
		}))
	};
	MainTabHandleHolder.prototype.createPlusHandleDropDown = function (event) {
		var appManager, appsController, contextMenu, index, offset;
		appsController = KD.getSingleton("kodingAppsController");
		appManager = KD.getSingleton("appManager");
		if (this.plusHandle.$().hasClass("first")) return KD.getSingleton("appManager").open("StartTab");
		offset = this.plusHandle.$().offset();
		contextMenu = new KDContextMenu({
			event: event,
			delegate: this.plusHandle,
			x: offset.left - 133,
			y: offset.top + 22,
			arrow: {
				placement: "top",
				margin: -20
			}
		}, {
			"Your Apps": {
				callback: function () {
					appManager.open("StartTab", {
						forceNew: !0
					});
					return contextMenu.destroy()
				},
				separator: !0
			},
			"Ace Editor": {
				callback: function () {
					appManager.open("Ace", {
						forceNew: !0
					});
					return contextMenu.destroy()
				}
			},
			Terminal: {
				callback: function () {
					appManager.open("Terminal", {
						forceNew: !0
					});
					return contextMenu.destroy()
				}
			},
			Teamwork: {
				callback: function () {
					KD.getSingleton("router").handleRoute("/Develop/Teamwork");
					return contextMenu.destroy()
				},
				separator: !0
			},
			"Search the App Store": {
				callback: function () {
					appManager.open("Apps");
					return contextMenu.destroy()
				}
			},
			"Make your own app...": {
				callback: function () {
					return function () {
						return appsController.makeNewApp()
					}
				}(this)
			}
		});
		index = 4;
		return appsController.fetchApps(function () {
			return function (err, apps) {
				var app, name, _results;
				_results = [];
				for (name in apps)
					if (__hasProp.call(apps, name)) {
						app = apps[name];
						app.callback = appManager.open.bind(appManager, name, {
							forceNew: !0
						}, contextMenu.bound("destroy"));
						app.title = name;
						contextMenu.treeController.addNode(app, index);
						_results.push(index++)
					}
				return _results
			}
		}(this))
	};
	MainTabHandleHolder.prototype.removePlusHandle = function () {
		return this.plusHandle.destroy()
	};
	MainTabHandleHolder.prototype._repositionPlusHandle = function () {
		var appTabCount, pane, visibleTabs, _i, _len, _ref;
		appTabCount = 0;
		visibleTabs = [];
		_ref = this.getDelegate().mainTabView.panes;
		for (_i = 0, _len = _ref.length; _len > _i; _i++) {
			pane = _ref[_i];
			if ("application" === pane.options.type) {
				visibleTabs.push(pane);
				pane.tabHandle.unsetClass("first");
				appTabCount++
			}
		}
		if (0 === appTabCount) {
			this.plusHandle.setClass("first last");
			return this.plusHandle.$("b").removeClass("hidden")
		}
		visibleTabs[0].tabHandle.setClass("first");
		this.removePlusHandle();
		this.addPlusHandle();
		this.plusHandle.unsetClass("first");
		return this.plusHandle.setClass("last")
	};
	return MainTabHandleHolder
}(KDView);
var GlobalNotificationView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
GlobalNotificationView = function (_super) {
	function GlobalNotificationView() {
		var closeTimer, scheduledAt, _base, _ref;
		GlobalNotificationView.__super__.constructor.apply(this, arguments);
		this.close = new CustomLinkView({
			title: "",
			icon: {
				cssClass: "close"
			},
			click: function (_this) {
				return function (event) {
					KD.utils.stopDOMEvent(event);
					return _this.hideAndDestroy()
				}
			}(this)
		});
		this.bindTransitionEnd();
		_ref = this.getData(), scheduledAt = _ref.scheduledAt, closeTimer = _ref.closeTimer;
		scheduledAt = new Date(scheduledAt).getTime();
		closeTimer && "number" == typeof closeTimer && KD.utils.wait(closeTimer, this.bound("hideAndDestroy"));
		this.timer = new KDCustomHTMLView({
			tagName: "strong",
			cssClass: this.getOption("showTimer") ? "hidden" : void 0,
			partial: this.timerPartial(scheduledAt)
		});
		this.repeater = KD.utils.repeat(2e3, function (_this) {
			return function () {
				_this.timer.updatePartial(_this.timerPartial(scheduledAt));
				return Date.now() > scheduledAt ? KD.utils.killRepeat(_this.repeater) : void 0
			}
		}(this));
		this.adminClose = __indexOf.call(KD.config.roles, "admin") >= 0 && this.getData().bongo_ ? new KDButtonView({
			tagName: "span",
			cssClass: "solid red mini cancel",
			title: "ADMIN: Cancel Notification",
			callback: function (_this) {
				return function () {
					return _this.getData().cancel(function (err) {
						return err ? KD.notify_(err) : _this.hideAndDestroy()
					})
				}
			}(this)
		}) : new KDCustomHTMLView;
		"function" == typeof (_base = this.getData()).on && _base.on("restartCanceled", function (_this) {
			return function () {
				log("remove active restart message ::realtime::");
				return _this.hideAndDestroy()
			}
		}(this))
	}
	__extends(GlobalNotificationView, _super);
	GlobalNotificationView.prototype.hideAndDestroy = function () {
		this.once("transitionend", this.bound("destroy"));
		return this.hide()
	};
	GlobalNotificationView.prototype.destroy = function () {
		KD.utils.killRepeat(this.repeater);
		return GlobalNotificationView.__super__.destroy.apply(this, arguments)
	};
	GlobalNotificationView.prototype.timerPartial = function (time) {
		return "" + KD.utils.nicetime((time - Date.now()) / 1e3) + "."
	};
	GlobalNotificationView.prototype.show = function () {
		return this.setClass("in")
	};
	GlobalNotificationView.prototype.hide = function () {
		return this.unsetClass("in")
	};
	GlobalNotificationView.prototype.pistachio = function () {
		return "<div>\n{{#(title)}} {{> this.timer}} {cite{#(content)}}\n{{> this.close}}{{> this.adminClose}}\n</div>"
	};
	return GlobalNotificationView
}(JView);
var Troubleshoot, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
KD.extend({
	troubleshoot: function () {
		return KD.singleton("troubleshoot").run()
	}
});
Troubleshoot = function (_super) {
	function Troubleshoot(options) {
		null == options && (options = {});
		null == options.timeout && (options.timeout = 1e4);
		Troubleshoot.__super__.constructor.call(this, options);
		this.items = {};
		this.status = PENDING;
		this.prepareCheckSequence();
		this.brokerRecovery = new BrokerRecovery;
		this.brokerKiteRecovery = new BrokerRecovery({
			type: "kite"
		});
		this.registerItems();
		this.idleUserDetector = new IdleUserDetector({
			threshold: KD.config.troubleshoot.idleTime
		});
		this.forwardEvent(this.idleUserDetector, "userIdle")
	}
	var PENDING, STARTED, checkVersion, _ref;
	__extends(Troubleshoot, _super);
	_ref = [1, 2], PENDING = _ref[0], STARTED = _ref[1];
	Troubleshoot.prototype.prepareCheckSequence = function () {
		return this.checkSequence = {
			connection: {
				webServer: {
					version: 0
				},
				brokerKite: {
					osKite: {
						vm: 0,
						terminal: 0
					}
				},
				bongo: {
					broker: {
						liveUpdate: 0
					}
				},
				newKite: 0
			}
		}
	};
	Troubleshoot.prototype.isSystemOK = function () {
		var item, name, _ref1;
		_ref1 = this.items;
		for (name in _ref1)
			if (__hasProp.call(_ref1, name)) {
				item = _ref1[name];
				if ("fail" === item.status) return !1
			}
		return !0
	};
	Troubleshoot.prototype.reset = function (event) {
		this.status = PENDING;
		KD.utils.killWait(this.timeout);
		return this.emit(event)
	};
	Troubleshoot.prototype.resetAllItems = function () {
		var item, name, _ref1, _results;
		_ref1 = this.items;
		_results = [];
		for (name in _ref1)
			if (__hasProp.call(_ref1, name)) {
				item = _ref1[name];
				_results.push(item.reset())
			}
		return _results
	};
	Troubleshoot.prototype.registerItems = function () {
		var vc, vmChecker;
		this.registerConnections();
		this.registerBrokers();
		"1" === localStorage.useNewKites && this.registerItem("newKite", {
			troubleshoot: function (callback) {
				return KD.singletons.kontrol.fetchKite({
					query: {
						name: "kontrol"
					}
				}).then(callback)["catch"](function (err) {
					return warn(err)
				})
			},
			recover: function () {
				ErrorLog.create("Troubleshoot toggled kite stack");
				return KD.toggleKiteStack()
			}
		});
		vc = KD.singleton("vmController");
		this.registerItem("osKite", {
			troubleshoot: vc.bound("ping"),
			recover: vc.bound("ping")
		});
		KD.remote.once("modelsReady", function (_this) {
			return function () {
				var bongoStatus;
				bongoStatus = KD.remote.api.JSystemStatus;
				return _this.registerItem("bongo", {
					troubleshoot: bongoStatus.healthCheck.bind(bongoStatus),
					recover: bongoStatus.healthCheck.bind(bongoStatus)
				})
			}
		}(this));
		KD.singleton("mainController").on("AccountChanged", function (_this) {
			return function () {
				var liveUpdateChecker;
				liveUpdateChecker = new LiveUpdateChecker;
				return _this.registerItem("liveUpdate", {
					troubleshoot: liveUpdateChecker.bound("healthCheck"),
					recover: liveUpdateChecker.bound("healthCheck")
				})
			}
		}(this));
		this.registerItem("version", {
			speedCheck: !1,
			troubleshoot: checkVersion.bind(this)
		});
		vmChecker = new VMChecker;
		this.registerItem("vm", {
			speedCheck: !1,
			troubleshoot: vmChecker.bound("healthCheck")
		});
		return this.registerItem("terminal", {
			troubleshoot: vmChecker.bound("terminalHealthCheck")
		})
	};
	Troubleshoot.prototype.registerConnections = function () {
		var externalUrl, item, webserverStatus;
		externalUrl = KD.config.troubleshoot.externalUrl;
		item = new ConnectionChecker({
			crossDomain: !0
		}, externalUrl);
		this.registerItem("connection", {
			speedCheck: !1,
			troubleshoot: item.bound("ping")
		});
		webserverStatus = new ConnectionChecker({}, "" + window.location.origin + "/-/healthCheck");
		return this.registerItem("webServer", {
			troubleshoot: webserverStatus.bound("ping")
		})
	};
	Troubleshoot.prototype.registerBrokers = function () {
		var broker, brokerKite;
		broker = KD.remote.mq;
		this.registerItem("broker", {
			troubleshoot: broker.bound("ping"),
			recover: this.brokerRecovery.bound("recover")
		});
		brokerKite = KD.kite.mq;
		return this.registerItem("brokerKite", {
			troubleshoot: brokerKite.bound("ping"),
			recover: this.brokerKiteRecovery.bound("recover")
		})
	};
	Troubleshoot.prototype.registerItem = function (name, options) {
		options.name = name;
		return this.items[name] = new HealthChecker(options)
	};
	checkVersion = function (callback) {
		return $.ajax({
			url: "" + window.location.origin + "/-/version",
			success: function (_this) {
				return function (data) {
					data.version !== KD.config.version && (_this.status = "fail");
					return callback(null)
				}
			}(this),
			timeout: 5e3,
			dataType: "jsonp",
			error: function (_this) {
				return function () {
					_this.items.version.status = "fail";
					_this.status = "fail";
					return callback(null)
				}
			}(this)
		})
	};
	Troubleshoot.prototype.getFailureFeedback = function () {
		var item, name, premium, result, _ref1;
		result = "";
		_ref1 = this.items;
		for (name in _ref1)
			if (__hasProp.call(_ref1, name)) {
				item = _ref1[name];
				premium = "broker" !== name && "brokerKite" !== name || !KD.config.usePremiumBroker ? "" : "premium";
				"fail" === item.status && (result = "" + result + " " + premium + name)
			}
		return result
	};
	Troubleshoot.prototype.healthChecker = function (root) {
		var children, item, name, _results;
		_results = [];
		for (name in root)
			if (__hasProp.call(root, name)) {
				children = root[name];
				item = this.items[name];
				_results.push(function (_this) {
					return function (name, children, item) {
						if (!item) {
							_this.waitingResponse -= _this.getSuccessorCount(children);
							return warn("" + name + " is not registered for health checking")
						}
						item.once("healthCheckCompleted", function () {
							var _ref1;
							_this.waitingResponse -= 1;
							"fail" === item.status && (_this.waitingResponse -= _this.getSuccessorCount(children));
							!children || "success" !== (_ref1 = item.status) && "slow" !== _ref1 || _this.healthChecker(children);
							return _this.waitingResponse ? void 0 : _this.reset("troubleshootCompleted")
						});
						return item.run()
					}
				}(this)(name, children, item))
			}
		return _results
	};
	Troubleshoot.prototype.getSuccessorCount = function (root) {
		var child, count, name;
		count = 0;
		for (name in root)
			if (__hasProp.call(root, name)) {
				child = root[name];
				count += this.getSuccessorCount(child);
				count += 1
			}
		return count
	};
	Troubleshoot.prototype.recover = function () {
		var item, name, waitingRecovery, _fn, _ref1;
		waitingRecovery = 0;
		_ref1 = this.items;
		_fn = function (_this) {
			return function (item) {
				item.once("recoveryCompleted", function () {
					waitingRecovery--;
					return waitingRecovery ? void 0 : _this.reset("recoveryCompleted")
				});
				if ("fail" === item.status && item.canBeRecovered()) {
					waitingRecovery++;
					return item.recover()
				}
			}
		}(this);
		for (name in _ref1)
			if (__hasProp.call(_ref1, name)) {
				item = _ref1[name];
				_fn(item)
			}
		return waitingRecovery
	};
	Troubleshoot.prototype.canBeRecovered = function () {
		var item, name, _ref1;
		_ref1 = this.items;
		for (name in _ref1)
			if (__hasProp.call(_ref1, name)) {
				item = _ref1[name];
				if ("fail" === item.status && item.canBeRecovered()) return !0
			}
		return !1
	};
	Troubleshoot.prototype.run = function () {
		if (this.status === STARTED) return warn("there is an ongoing troubleshooting");
		this.timeout = KD.utils.wait(this.getOptions().timeout, function (_this) {
			return function () {
				return _this.status = PENDING
			}
		}(this));
		this.resetAllItems();
		this.status = STARTED;
		this.result = {};
		this.waitingResponse = Object.keys(this.items).length;
		return this.healthChecker(this.checkSequence)
	};
	Troubleshoot.prototype.sendFeedback = function (feedback, callback) {
		var JSystemStatus;
		KD.logToExternal("troubleshoot feedback", {
			failure: this.getFailureFeedback(),
			feedback: feedback
		});
		JSystemStatus = KD.remote.api.JSystemStatus;
		return JSystemStatus.sendFeedback({
			feedback: feedback,
			status: this.getFailureFeedback(),
			userAgent: navigator.userAgent
		}, callback)
	};
	return Troubleshoot
}(KDObject);
var HealthChecker, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
HealthChecker = function (_super) {
	function HealthChecker(options) {
		var _ref;
		null == options && (options = {});
		null == options.slownessIndicator && (options.slownessIndicator = 350);
		null == options.speedCheck && (options.speedCheck = !0);
		null == options.timeout && (options.timeout = 5e3);
		HealthChecker.__super__.constructor.call(this, options);
		_ref = this.getOptions(), this.name = _ref.name, this.identifier = _ref.identifier;
		this.identifier || (this.identifier = Date.now());
		this.status = "not started";
		this.completeEvent = "healthCheckCompleted"
	}
	__extends(HealthChecker, _super);
	HealthChecker.prototype.run = function () {
		var troubleshoot;
		this.emit("healthCheckStarted");
		troubleshoot = this.getOptions().troubleshoot;
		if (!troubleshoot) return this.forceComplete("undefined callback");
		this.completeEvent = "healthCheckCompleted";
		this.startCheck();
		return troubleshoot(this.finish.bind(this))
	};
	HealthChecker.prototype.setPingTimeout = function () {
		return this.pingTimeout = KD.utils.wait(this.getOptions().timeout, function (_this) {
			return function () {
				_this.status = "fail";
				return _this.emit(_this.completeEvent)
			}
		}(this))
	};
	HealthChecker.prototype.finish = function (data) {
		var slownessIndicator, speedCheck, _ref;
		if ("fail" !== this.status) {
			_ref = this.getOptions(), slownessIndicator = _ref.slownessIndicator, speedCheck = _ref.speedCheck;
			this.finishTime = Date.now();
			this.status = speedCheck && this.getResponseTime() > slownessIndicator ? "slow" : "success";
			(null != data ? data.status : void 0) && (this.status = data.status);
			KD.utils.killWait(this.pingTimeout);
			return this.emit(this.completeEvent)
		}
	};
	HealthChecker.prototype.startCheck = function () {
		this.status = "waiting";
		this.startTime = Date.now();
		return this.setPingTimeout(this.completeEvent)
	};
	HealthChecker.prototype.reset = function () {
		this.status = "waiting";
		this.finishTime = null;
		return this.startTime = null
	};
	HealthChecker.prototype.getResponseTime = function () {
		return this.finishTime - this.startTime
	};
	HealthChecker.prototype.forceComplete = function (err) {
		err && warn(err);
		this.status = "fail";
		return this.emit("healthCheckCompleted")
	};
	HealthChecker.prototype.recover = function () {
		var recover;
		this.completeEvent = "recoveryCompleted";
		this.startCheck();
		this.emit("recoveryStarted");
		recover = this.getOptions().recover;
		return recover(this.finish.bind(this))
	};
	HealthChecker.prototype.canBeRecovered = function () {
		return null != this.getOptions().recover
	};
	return HealthChecker
}(KDObject);
var ConnectionChecker, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ConnectionChecker = function (_super) {
	function ConnectionChecker(options, data) {
		var _ref;
		ConnectionChecker.__super__.constructor.call(this, options, data);
		this.url = this.getData();
		_ref = this.getOptions(), this.fail = _ref.fail, this.jsonp = _ref.jsonp
	}
	__extends(ConnectionChecker, _super);
	ConnectionChecker.prototype.ping = function (callback) {
		var crossDomain;
		crossDomain = this.getOptions().crossDomain;
		crossDomain && (ConnectionChecker.jsonp = callback);
		return $.ajax({
			url: this.url,
			success: function () {
				return callback.apply(null, arguments)
			},
			jsonpCallback: this.jsonp ? this.jsonp : void 0,
			timeout: 5e3,
			dataType: "jsonp",
			error: function (_this) {
				return function () {
					return "function" == typeof _this.fail ? _this.fail.apply(_this, arguments) : void 0
				}
			}(this)
		})
	};
	return ConnectionChecker
}(KDObject);
var TroubleshootModal, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
TroubleshootModal = function (_super) {
	function TroubleshootModal(options, data) {
		var troubleshoot;
		null == options && (options = {});
		troubleshoot = KD.singleton("troubleshoot");
		options = {
			title: "Checking Koding status",
			overlay: !0,
			cssClass: "troubleshoot-modal",
			cancelable: !1,
			tabs: {
				forms: {
					Troubleshoot: {
						callback: function (_this) {
							return function () {
								var feedback;
								feedback = _this.modalTabs.forms.Troubleshoot.customData.feedback;
								troubleshoot.sendFeedback(feedback, function (err) {
									return err ? warn("an error occured while sending feedback") : _this.showFeedbackSentModal()
								});
								return _this.destroy()
							}
						}(this),
						buttons: {
							sendFeedback: {
								title: "Send Feedback",
								style: "modal-clean-green",
								type: "submit",
								loader: {
									color: "#444444",
									diameter: 12
								},
								callback: function () {
									return this.hideLoader()
								}
							},
							recover: {
								title: "Recover",
								style: "modal-clean-red",
								callback: function () {
									return troubleshoot.recover()
								}
							},
							close: {
								title: "Close",
								style: "modal-cancel",
								callback: function (_this) {
									return function () {
										return _this.destroy()
									}
								}(this)
							}
						},
						fields: {
							check: {
								label: "System Status",
								itemClass: TroubleshootStatusView
							},
							result: {
								itemClass: KDCustomHTMLView,
								cssClass: "troubleshoot-result",
								partial: "Troubleshooting Completed"
							},
							errors: {
								itemClass: TroubleshootResultView
							},
							feedback: {
								label: "Feedback",
								name: "feedback",
								placeholder: "Please tell us about the problems you were having and describe the situation",
								type: "textarea",
								autogrow: !0
							}
						}
					}
				}
			}
		};
		TroubleshootModal.__super__.constructor.call(this, options, data);
		this.overlay.off("click");
		this.hideFeedback();
		this.modalTabs.forms.Troubleshoot.buttons.close.hide();
		this.modalTabs.forms.Troubleshoot.fields.result.hide();
		troubleshoot.on("recoveryCompleted", function (_this) {
			return function () {
				return troubleshoot.isSystemOK() ? _this.hideFeedback() : void 0
			}
		}(this));
		troubleshoot.once("troubleshootCompleted", function (_this) {
			return function () {
				var connection;
				_this.modalTabs.forms.Troubleshoot.buttons.close.show();
				if (troubleshoot.isSystemOK()) return _this.modalTabs.forms.Troubleshoot.fields.result.show();
				connection = troubleshoot.items.connection;
				"fail" !== (null != connection ? connection.status : void 0) && _this.showFeedback();
				return KD.utils.defer(function () {
					return _this.setPositions()
				})
			}
		}(this));
		KD.troubleshoot()
	}
	__extends(TroubleshootModal, _super);
	TroubleshootModal.prototype.hideFeedback = function () {
		this.modalTabs.forms.Troubleshoot.fields.feedback.hide();
		this.modalTabs.forms.Troubleshoot.buttons.sendFeedback.hide();
		return this.modalTabs.forms.Troubleshoot.buttons.recover.hide()
	};
	TroubleshootModal.prototype.showFeedback = function () {
		this.modalTabs.forms.Troubleshoot.fields.feedback.show();
		this.modalTabs.forms.Troubleshoot.buttons.sendFeedback.show();
		return KD.singleton("troubleshoot").canBeRecovered() ? this.modalTabs.forms.Troubleshoot.buttons.recover.show() : void 0
	};
	TroubleshootModal.prototype.destroy = function () {
		var item, items, key;
		KD.singleton("troubleshoot").off("recoveryCompleted");
		items = KD.singleton("troubleshoot").items;
		for (key in items)
			if (__hasProp.call(items, key)) {
				item = items[key];
				item.off("recoveryStarted");
				item.off("recoveryCompleted")
			}
		return TroubleshootModal.__super__.destroy.apply(this, arguments)
	};
	TroubleshootModal.prototype.showFeedbackSentModal = function () {
		var modal;
		return modal = new KDModalView({
			title: "Thank you for your support",
			overlay: !0,
			content: "We have received your feedback.",
			buttons: {
				Close: {
					style: "modal-cancel",
					callback: function () {
						return modal.destroy()
					}
				}
			}
		})
	};
	return TroubleshootModal
}(KDModalViewWithForms);
var TroubleshootItemView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
TroubleshootItemView = function (_super) {
	function TroubleshootItemView(options, data) {
		var title;
		null == options.cssClass && (options.cssClass = "hidden troubleshootitem");
		TroubleshootItemView.__super__.constructor.call(this, options, data);
		this.loader = new KDLoaderView({
			size: {
				width: 16
			},
			showLoader: !0
		});
		this.getData().once("healthCheckStarted", this.bound("startCheck"));
		this.getData().once("healthCheckCompleted", this.bound("completeCheck"));
		this.forwardEvent(this.getData(), "recoveryStarted");
		this.on("recoveryStarted", this.bound("startCheck"));
		this.forwardEvent(this.getData(), "recoveryCompleted");
		this.on("recoveryCompleted", this.bound("completeCheck"));
		this.status = new JCustomHTMLView({
			tagName: "strong",
			pistachio: "{{#(status)}}",
			cssClass: "status"
		}, this.getData());
		title = this.getOptions().title;
		this.title = new KDCustomHTMLView({
			tagName: "span",
			partial: "" + title,
			cssClass: "checker-name"
		})
	}
	__extends(TroubleshootItemView, _super);
	TroubleshootItemView.prototype.getResponseTime = function () {
		var responseTime;
		responseTime = this.getData().getResponseTime();
		return 0 === responseTime ? "" : "" + responseTime + " ms"
	};
	TroubleshootItemView.prototype.pistachio = function () {
		return "{{> this.title}}{{> this.status}}{{> this.loader}}"
	};
	TroubleshootItemView.prototype.startCheck = function () {
		this.show();
		this.loader.show();
		this.status.render();
		return this.status.unsetClass("fail success")
	};
	TroubleshootItemView.prototype.completeCheck = function () {
		var status;
		this.loader.hide();
		this.status.render();
		status = this.getData().status;
		this.status.unsetClass("fail success");
		return this.status.setClass("" + status)
	};
	return TroubleshootItemView
}(JCustomHTMLView);
var TroubleshootStatusView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
TroubleshootStatusView = function (_super) {
	function TroubleshootStatusView(options, data) {
		var items, name, title;
		data = KD.singleton("troubleshoot").items;
		options.cssClass = "troubleshoot-status";
		TroubleshootStatusView.__super__.constructor.call(this, options, data);
		items = this.getStatus();
		for (name in items)
			if (__hasProp.call(items, name)) {
				title = items[name];
				this.createItem(name, title)
			}
	}
	__extends(TroubleshootStatusView, _super);
	TroubleshootStatusView.prototype.getStatus = function () {
		var premium;
		premium = KD.config.usePremiumBroker ? "Premium " : "";
		return {
			connection: "Internet connection",
			bongo: "Social server",
			liveUpdate: "Live updates",
			broker: "" + premium + "Messaging server",
			brokerKite: "" + premium + "Kite messaging server",
			newKite: "New Kites",
			osKite: "VM server",
			vm: "Your VMs",
			terminal: "Terminals",
			webServer: "Webserver",
			version: "Latest version"
		}
	};
	TroubleshootStatusView.prototype.createItem = function (name, title) {
		var item;
		if (this.getData()[name]) {
			item = new TroubleshootItemView({
				title: title
			}, this.getData()[name]);
			return this.addSubView(item)
		}
	};
	return TroubleshootStatusView
}(KDCustomHTMLView);
var LiveUpdateChecker, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LiveUpdateChecker = function (_super) {
	function LiveUpdateChecker(options, data) {
		var notificationController;
		LiveUpdateChecker.__super__.constructor.call(this, options, data);
		notificationController = KD.singletons.notificationController;
		notificationController.on("NotificationHasArrived", function (_this) {
			return function (notification) {
				return "healthCheck" === (null != notification ? notification.event : void 0) ? _this.emit("healthCheckReceived") : void 0
			}
		}(this))
	}
	__extends(LiveUpdateChecker, _super);
	LiveUpdateChecker.prototype.healthCheck = function (callback) {
		this.once("healthCheckReceived", callback);
		return KD.remote.api.JSystemStatus.checkRealtimeUpdates(callback)
	};
	return LiveUpdateChecker
}(KDObject);
var BrokerRecovery, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
BrokerRecovery = function (_super) {
	function BrokerRecovery(options, data) {
		null == options && (options = {});
		null == options.timeout && (options.timeout = 1e4);
		BrokerRecovery.__super__.constructor.call(this, options, data);
		this.unsuccessfulAttempt = 0;
		this.broker = "kite" === options.type ? KD.kite.mq : KD.remote.mq;
		KD.utils.repeat(options.timeout, this.bound("checkStatus"));
		this.on("brokerNotResponding", function (_this) {
			return function () {
				return _this.unsuccessfulAttempt > 2 ? _this.changeBroker() : void 0
			}
		}(this));
		this.broker.on("ready", function (_this) {
			return function () {
				return _this.emit("brokerConnected")
			}
		}(this))
	}
	__extends(BrokerRecovery, _super);
	BrokerRecovery.prototype.brokerURL = function () {
		return this.broker.sockURL.replace("/subscribe", "")
	};
	BrokerRecovery.prototype.checkStatus = function () {
		var responseTimeout, timeout;
		timeout = this.getOptions().timeout;
		if (this.broker.lastTo < Date.now() - timeout) {
			responseTimeout = KD.utils.wait(3e3, function (_this) {
				return function () {
					var brokerURL;
					_this.unsuccessfulAttempt++;
					_this.emit("brokerNotResponding");
					brokerURL = _this.brokerURL();
					return KD.utils.warnAndLog("broker not responding", {
						unsuccessfulAttempt: _this.unsuccessfulAttempt,
						brokerURL: brokerURL
					})
				}
			}(this));
			return this.broker.ping(function (_this) {
				return function () {
					_this.unsuccessfulAttempt = 0;
					return KD.utils.killWait(responseTimeout)
				}
			}(this))
		}
	};
	BrokerRecovery.prototype.changeBroker = function () {
		this.unsuccessfulAttempt = 0;
		this.broker.disconnect(!1);
		return this.broker.selectAndConnect([this.brokerURL()])
	};
	BrokerRecovery.prototype.recover = function (callback) {
		this.once("brokerConnected", callback);
		return this.changeBroker()
	};
	return BrokerRecovery
}(KDObject);
var VMChecker, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
VMChecker = function (_super) {
	function VMChecker(options, data) {
		VMChecker.__super__.constructor.call(this, options, data)
	}
	__extends(VMChecker, _super);
	VMChecker.prototype.healthCheck = function (callback) {
		var alias, kite, kites, kontrol, status, vmController, _ref, _ref1;
		status = "pending";
		_ref = KD.singletons, vmController = _ref.vmController, kontrol = _ref.kontrol;
		kites = KD.useNewKites ? kontrol.kites.oskite : vmController.kites;
		for (alias in kites)
			if (__hasProp.call(kites, alias)) {
				kite = kites[alias];
				switch (null != (_ref1 = kite.recentState) ? _ref1.state : void 0) {
				case "RUNNING":
					status = "success";
					break;
				case "FAILED":
					status = "fail";
					return callback({
						status: status
					});
				case "STOPPED":
					status = "pending"
				}
			}
		return callback({
			status: status
		})
	};
	VMChecker.prototype.terminalHealthCheck = function (callback) {
		var failedTerminals, kites, kontrol, promises, terminalKite, vmController, _, _ref;
		_ref = KD.singletons, vmController = _ref.vmController, kontrol = _ref.kontrol;
		kites = KD.useNewKites ? kontrol.kites.terminal : vmController.kites.terminalKites;
		failedTerminals = [];
		promises = function () {
			var _results;
			_results = [];
			for (_ in kites)
				if (__hasProp.call(kites, _)) {
					terminalKite = kites[_];
					_results.push(terminalKite.webtermPing()["catch"](function () {
						return function () {
							var correlationName;
							correlationName = terminalKite.correlationName;
							return failedTerminals.push(correlationName)
						}
					}(this)))
				}
			return _results
		}.call(this);
		return Promise.all(promises).then(function () {
			return function () {
				return failedTerminals.length > 0
			}
		}(this)).nodeify(callback)
	};
	return VMChecker
}(KDObject);
var TroubleshootResultView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
TroubleshootResultView = function (_super) {
	function TroubleshootResultView(options, data) {
		TroubleshootResultView.__super__.constructor.call(this, options, data);
		this.errorView = new TroubleshootMessageView({
			cssClass: "troubleshoot-errors"
		});
		this.warningView = new TroubleshootMessageView({
			cssClass: "troubleshoot-warnings"
		});
		this.hide();
		this.initStatusListener();
		this.addSubView(this.errorView);
		this.addSubView(this.warningView)
	}
	__extends(TroubleshootResultView, _super);
	TroubleshootResultView.prototype.getMessages = function () {
		return {
			bongo: {
				slow: "You will experience slowness with posting status updates and receiving feeds. Generally interacting with social",
				fail: "You will be having problems with posting status updates and receiving feeds. Generally interacting with social"
			},
			broker: {
				slow: "You will experience slowness with live updates",
				fail: "You will not receive live updates, and you wont be able to connect to your vms"
			},
			brokerKite: {
				slow: "You will experience slowness with terminal connection",
				fail: "You will not connect to your terminal"
			},
			newKite: {
				fail: "You are currently testing our new Kite system and experiencing some problems. If you want to return to old system, just press Recover button. Also we would be glad if you share your problem and send feedback to us."
			},
			osKite: {
				slow: "You will experience slowness with terminal connection",
				fail: "You will not connect to your terminal"
			},
			webServer: {
				slow: "Page load time is probably slow",
				fail: "Webserver is not responding now. Please do not refresh your page"
			},
			connection: {
				slow: "Your internet connection is very slow. Your experience with Koding will not be the best one",
				fail: "You do not have internet at the moment. The parts of Koding that supports offline working will continue to work, but you cannot send/receive updates, reach your VMs nor interact with terminal."
			},
			liveUpdate: {
				slow: "You will experience slowness with live updates",
				fail: "You will not receive live updates, and you wont be able to connect to your VMs"
			},
			version: {
				fail: "You are currently running an old version of Koding. Please refresh your page."
			},
			vm: {
				fail: "One or more of your VMs are not accessible right now. Please try refreshing your page.",
				pending: "Some of your VMs are currently offline. If you want to activate them please use Terminal app"
			},
			terminal: {
				fail: "One or more of your Terminals are not accessible right now. Please  try refreshing your page."
			}
		}
	};
	TroubleshootResultView.prototype.initStatusListener = function () {
		var item, items, key, _results;
		items = KD.singleton("troubleshoot").items;
		_results = [];
		for (key in items)
			if (__hasProp.call(items, key)) {
				item = items[key];
				_results.push(function (_this) {
					return function (item) {
						item.once("healthCheckCompleted", function () {
							var message, name, status, view, _ref;
							status = item.status, name = item.name;
							if (null != (_ref = _this.getMessages()[name]) ? _ref[status] : void 0) {
								message = _this.getMessages()[name][status];
								_this.show();
								view = "fail" === status ? _this.errorView : _this.warningView;
								return view.addItem(item, message)
							}
						});
						item.on("recoveryStarted", _this.startRecovery.bind(_this, item));
						return item.on("recoveryCompleted", _this.completeRecovery.bind(_this, item))
					}
				}(this)(item))
			}
		return _results
	};
	TroubleshootResultView.prototype.startRecovery = function (item) {
		return this.errorView.removeItem(item)
	};
	TroubleshootResultView.prototype.completeRecovery = function (item) {
		var name, status, _ref;
		status = item.status, name = item.name;
		return (null != (_ref = this.getMessages()[name]) ? _ref[status] : void 0) ? this.errorView.addItem(item, this.getMessages()[name][status]) : void 0
	};
	return TroubleshootResultView
}(KDCustomHTMLView);
var TroubleshootMessageView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
TroubleshootMessageView = function (_super) {
	function TroubleshootMessageView(options, data) {
		TroubleshootMessageView.__super__.constructor.call(this, options, data);
		this.hide();
		this.views = {};
		this.count = 0
	}
	__extends(TroubleshootMessageView, _super);
	TroubleshootMessageView.prototype.addItem = function (item, message) {
		var name, status;
		this.show();
		this.count++;
		status = item.status, name = item.name;
		return this.addSubView(this.views[name] = new KDCustomHTMLView({
			tagName: "div",
			cssClass: "status-message " + status,
			partial: "* " + message
		}))
	};
	TroubleshootMessageView.prototype.removeItem = function (item) {
		var name, _ref;
		this.count--;
		name = item.name;
		this.count || this.hide();
		null != (_ref = this.views[name]) && _ref.destroy();
		return delete this.views[name]
	};
	return TroubleshootMessageView
}(KDCustomHTMLView);
var AvatarArea, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AvatarArea = function (_super) {
	function AvatarArea(options, data) {
		var account;
		null == options && (options = {});
		options.cssClass || (options.cssClass = "avatar-area");
		AvatarArea.__super__.constructor.call(this, options, data);
		account = this.getData();
		this.avatar = new AvatarView({
			tagName: "div",
			cssClass: "avatar-image-wrapper",
			attributes: {
				title: "View your public profile"
			},
			size: {
				width: 25,
				height: 25
			}
		}, account);
		this.profileLink = new ProfileLinkView({}, account);
		this.groupSwitcherPopup = new AvatarPopupGroupSwitcher({
			cssClass: "group-switcher"
		});
		this.groupsSwitcherIcon = new AvatarAreaIconLink({
			cssClass: "groups acc-dropdown-icon",
			attributes: {
				title: "Your groups"
			},
			delegate: this.groupSwitcherPopup
		});
		this.once("viewAppended", function (_this) {
			return function () {
				var mainView;
				mainView = KD.getSingleton("mainView");
				mainView.addSubView(_this.groupSwitcherPopup);
				return _this.groupSwitcherPopup.listControllerPending.on("PendingGroupsCountDidChange", function (count) {
					count > 0 ? _this.groupSwitcherPopup.invitesHeader.show() : _this.groupSwitcherPopup.invitesHeader.hide();
					return _this.groupsSwitcherIcon.updateCount(count)
				})
			}
		}(this));
		KD.getSingleton("mainController").on("accountChanged", function (_this) {
			return function () {
				_this.groupSwitcherPopup.listController.removeAllItems();
				_this.groupSwitcherPopup.populateGroups();
				return _this.groupSwitcherPopup.populatePendingGroups()
			}
		}(this))
	}
	__extends(AvatarArea, _super);
	JView.mixin(AvatarArea.prototype);
	AvatarArea.prototype.pistachio = function () {
		return "{{> this.avatar}}\n<section>\n  <h2>{{> this.profileLink}}</h2>\n  <h3>@{{#(profile.nickname)}}</h3>\n  {{> this.groupsSwitcherIcon}}\n</section>"
	};
	return AvatarArea
}(KDCustomHTMLView);
var AvatarPopup, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AvatarPopup = function (_super) {
	function AvatarPopup() {
		var mainController;
		AvatarPopup.__super__.constructor.apply(this, arguments);
		mainController = KD.getSingleton("mainController");
		mainController.on("accountChanged.to.loggedIn", this.bound("accountChanged"));
		this._windowController = KD.getSingleton("windowController");
		this.listenWindowResize()
	}
	__extends(AvatarPopup, _super);
	AvatarPopup.prototype.show = function () {
		this.utils.killWait(this.loaderTimeout);
		this._windowDidResize();
		this._windowController.addLayer(this);
		KD.getSingleton("mainController").emit("AvatarPopupIsActive");
		this.setClass("active");
		return this
	};
	AvatarPopup.prototype.hide = function () {
		KD.getSingleton("mainController").emit("AvatarPopupIsInactive");
		this.unsetClass("active");
		return this
	};
	AvatarPopup.prototype.viewAppended = function () {
		this.setClass("avatararea-popup");
		this.addSubView(this.avatarPopupTab = new KDView({
			cssClass: "tab",
			partial: '<span class="avatararea-popup-close"></span>'
		}));
		this.setPopupListener();
		this.addSubView(this.avatarPopupContent = new KDView({
			cssClass: "content hidden"
		}));
		this.addSubView(this.notLoggedInWarning = new KDView({
			height: "auto",
			cssClass: "content sublink",
			partial: this.notLoggedInMessage || "Login required."
		}));
		return KD.isLoggedIn() ? this.accountChanged() : void 0
	};
	AvatarPopup.prototype.setPopupListener = function () {
		return this.avatarPopupTab.on("click", function (_this) {
			return function () {
				return _this.hide()
			}
		}(this))
	};
	AvatarPopup.prototype._windowDidResize = function () {
		var avatarTopOffset, scrollView, windowHeight;
		if (this.listController) {
			scrollView = this.listController.scrollView;
			windowHeight = $(window).height();
			avatarTopOffset = this.$().offset().top;
			return this.listController.scrollView.$().css({
				maxHeight: windowHeight - avatarTopOffset - 80
			})
		}
	};
	AvatarPopup.prototype.accountChanged = function () {
		this.notLoggedInWarning.hide();
		return this.avatarPopupContent.show()
	};
	return AvatarPopup
}(KDView);
var PopupList, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
PopupList = function (_super) {
	function PopupList(options, data) {
		null == options && (options = {});
		options.tagName || (options.tagName = "ul");
		options.cssClass || (options.cssClass = "avatararea-popup-list");
		PopupList.__super__.constructor.call(this, options, data)
	}
	__extends(PopupList, _super);
	return PopupList
}(KDListView);
var AvatarPopupGroupSwitcher, PopupGroupListItem, PopupGroupListItemPending, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
AvatarPopupGroupSwitcher = function (_super) {
	function AvatarPopupGroupSwitcher() {
		this.notLoggedInMessage = "Login required to switch groups";
		AvatarPopupGroupSwitcher.__super__.constructor.apply(this, arguments)
	}
	__extends(AvatarPopupGroupSwitcher, _super);
	AvatarPopupGroupSwitcher.prototype.viewAppended = function () {
		var backToKoding, cookieName, createGroupLink, dashboardLink, entryPoint, groupsController, handleSubMenu, router, submenuShown;
		AvatarPopupGroupSwitcher.__super__.viewAppended.apply(this, arguments);
		this.pending = 0;
		this.notPopulated = !0;
		this.notPopulatedPending = !0;
		groupsController = KD.getSingleton("groupsController");
		router = KD.getSingleton("router");
		this._popupList = new PopupList({
			itemClass: PopupGroupListItem
		});
		this._popupListPending = new PopupList({
			itemClass: PopupGroupListItemPending
		});
		this.listControllerPending = new KDListViewController({
			lazyLoaderOptions: {
				partial: "",
				spinnerOptions: {
					loaderOptions: {
						color: "#6BB197"
					},
					size: {
						width: 32
					}
				}
			},
			view: this._popupListPending
		});
		this.listController = new KDListViewController({
			lazyLoaderOptions: {
				partial: "",
				spinnerOptions: {
					loaderOptions: {
						color: "#6BB197"
					},
					size: {
						width: 32
					}
				}
			},
			view: this._popupList
		});
		this.listController.on("AvatarPopupShouldBeHidden", this.bound("hide"));
		this.avatarPopupContent.addSubView(this.invitesHeader = new KDView({
			height: "auto",
			cssClass: "sublink top hidden",
			partial: "You have pending group invitations:"
		}));
		this.avatarPopupContent.addSubView(new KDCustomHTMLView({
			tagName: "span",
			cssClass: "icon help",
			tooltip: {
				title: "Here you'll find the groups that you are a member of, clicking one of them will take you to a new browser tab."
			}
		}));
		this.addSubView(this.groupSubMenuWrapper = new KDCustomHTMLView({
			partial: '<div class="kdview content"></div>',
			cssClass: "avatararea-popup notifications group-switcher submenu"
		}));
		this.groupSubMenuWrapper.setCss("right", 293);
		entryPoint = KD.config.entryPoint;
		createGroupLink = new KDCustomHTMLView({
			tagName: "a",
			attributes: {
				href: "/Pricing/Team"
			},
			cssClass: "bottom bb hidden",
			partial: "Create a group",
			click: function (_this) {
				return function (event) {
					KD.utils.stopDOMEvent(event);
					router.handleRoute("/Pricing/CreateGroup", {
						entryPoint: "koding"
					});
					return _this.hide()
				}
			}(this)
		});
		KD.singletons.mainController.ready(function () {
			return KD.isLoggedIn() ? KD.singleton("paymentController").fetchSubscriptionsWithPlans({
				tags: ["custom-plan"]
			}, function (err, subscriptions) {
				return err ? KD.showError(err) : subscriptions.length ? void 0 : createGroupLink.show()
			}) : void 0
		});
		backToKoding = new KDCustomHTMLView({
			tagName: "a",
			attributes: {
				href: "/"
			},
			cssClass: "bottom bb",
			partial: "Go back to Koding",
			click: function () {
				return function (event) {
					KD.utils.stopDOMEvent(event);
					return location.href = "/"
				}
			}(this)
		});
		groupsController.ready(function () {
			return "koding" === groupsController.getCurrentGroup().slug ? backToKoding.destroy() : void 0
		});
		this.groupSubMenuWrapper.addSubView(createGroupLink, ".content");
		this.groupSubMenuWrapper.addSubView(backToKoding, ".content");
		this.groupSubMenuWrapper.addSubView(this.listControllerPending.getView(), ".content");
		this.groupSubMenuWrapper.addSubView(this.listController.getView(), ".content");
		submenuShown = !1;
		this.avatarPopupContent.bindEvent("mousemove");
		this.avatarPopupContent.on("mousemove", function (_this) {
			return function (event) {
				return $(event.target).closest().is(".submenu") ? void 0 : _this.groupSubMenuWrapper.unsetClass("active")
			}
		}(this));
		handleSubMenu = function (_this) {
			return function (event) {
				KD.utils.stopDOMEvent(event);
				submenuShown = !0;
				_this.groupSubMenuWrapper.setClass("active");
				return _this.populateGroups()
			}
		}(this);
		this.avatarPopupContent.addSubView(new KDCustomHTMLView({
			tagName: "a",
			attributes: {
				href: "#"
			},
			cssClass: "bottom",
			partial: "Your groups",
			bind: "mouseenter mousemove",
			mouseenter: handleSubMenu,
			click: handleSubMenu,
			mousemove: KD.utils.stopDOMEvent
		}));
		this.avatarPopupContent.addSubView(new KDCustomHTMLView({
			tagName: "a",
			attributes: {
				href: "/Account"
			},
			cssClass: "bottom separator",
			partial: "Account settings",
			click: function (_this) {
				return function (event) {
					KD.utils.stopDOMEvent(event);
					router.handleRoute("/Account");
					return _this.hide()
				}
			}(this)
		}));
		this.avatarPopupContent.addSubView(new KDCustomHTMLView({
			tagName: "a",
			attributes: {
				href: "/Environments"
			},
			cssClass: "bottom",
			partial: "Environments",
			click: function (_this) {
				return function (event) {
					KD.utils.stopDOMEvent(event);
					router.handleRoute("/Environments");
					return _this.hide()
				}
			}(this)
		}));
		this.avatarPopupContent.addSubView(new KDCustomHTMLView({
			tagName: "a",
			cssClass: "bottom",
			partial: "System health check",
			click: function (_this) {
				return function () {
					new TroubleshootModal;
					return _this.hide()
				}
			}(this)
		}));
		this.avatarPopupContent.addSubView(dashboardLink = new KDCustomHTMLView({
			tagName: "a",
			cssClass: "bottom hidden",
			partial: "Group dashboard",
			click: function (_this) {
				return function (event) {
					KD.utils.stopDOMEvent(event);
					KD.getSingleton("router").handleRoute("/Dashboard");
					return _this.hide()
				}
			}(this)
		}));
		groupsController.ready(function () {
			var group;
			group = groupsController.getCurrentGroup();
			return group.canEditGroup(function () {
				return function (err, success) {
					return success ? dashboardLink.show() : void 0
				}
			}(this))
		});
		cookieName = "kdproxy-usehttp";
		"1" === Cookies.get(cookieName) && this.avatarPopupContent.addSubView(new KDCustomHTMLView({
			tagName: "a",
			cssClass: "bottom",
			partial: "Switch back to secure (https) mode",
			click: function () {
				return function (event) {
					KD.utils.stopDOMEvent(event);
					Cookies.expire(cookieName);
					return window.location.reload()
				}
			}(this)
		}));
		return this.avatarPopupContent.addSubView(new KDCustomHTMLView({
			tagName: "a",
			attributes: {
				href: "/Logout"
			},
			cssClass: "bottom",
			partial: "Logout",
			click: function (_this) {
				return function (event) {
					KD.utils.stopDOMEvent(event);
					router.handleRoute("/Logout");
					return _this.hide()
				}
			}(this)
		}))
	};
	AvatarPopupGroupSwitcher.prototype.populatePendingGroups = function () {
		this.listControllerPending.removeAllItems();
		this.listControllerPending.hideLazyLoader();
		return KD.isLoggedIn() ? KD.whoami().fetchGroupsWithPendingInvitations(function (_this) {
			return function (err, groups) {
				var group, _i, _len;
				if (err) return warn(err);
				if (null != groups) {
					_this.pending = 0;
					for (_i = 0, _len = groups.length; _len > _i; _i++) {
						group = groups[_i];
						if (group) {
							_this.listControllerPending.addItem({
								group: group,
								roles: [],
								admin: !1
							});
							_this.pending++
						}
					}
					_this.updatePendingCount();
					return _this.notPopulatedPending = !1
				}
			}
		}(this)) : void 0
	};
	AvatarPopupGroupSwitcher.prototype.populateGroups = function () {
		if (KD.isLoggedIn() && !this.isLoading) {
			this.listController.removeAllItems();
			this.isLoading = !0;
			return KD.whoami().fetchGroups(null, function (_this) {
				return function (err, groups) {
					var promises, results;
					if (err) return warn(err);
					if (null != groups) {
						results = [];
						promises = groups.map(function (group) {
							return new Promise(function (resolve) {
								return group.group.fetchMyRoles(function (err, roles) {
									group.admin = err ? !1 : __indexOf.call(roles, "admin") >= 0;
									results.push(group);
									return resolve()
								})
							})
						});
						return Promise.all(promises).then(function () {
							var index;
							_this.isLoading = !1;
							results.sort(function (a, b) {
								return a.admin === b.admin ? a.group.slug > b.group.slug : !a.admin && b.admin
							});
							index = null;
							results.forEach(function (item, i) {
								return "koding" === item.group.slug ? index = i : void 0
							});
							null != index && results.splice(index, 1);
							_this.listController.hideLazyLoader();
							return _this.listController.instantiateListItems(results)
						})
					}
				}
			}(this))
		}
	};
	AvatarPopupGroupSwitcher.prototype.decreasePendingCount = function () {
		this.pending--;
		return this.updatePendingCount()
	};
	AvatarPopupGroupSwitcher.prototype.updatePendingCount = function () {
		return this.listControllerPending.emit("PendingGroupsCountDidChange", this.pending)
	};
	AvatarPopupGroupSwitcher.prototype.show = function () {
		AvatarPopupGroupSwitcher.__super__.show.apply(this, arguments);
		this.notPopulated && this.populateGroups();
		return this.notPopulatedPending ? this.populatePendingGroups() : void 0
	};
	AvatarPopupGroupSwitcher.prototype.hide = function () {
		AvatarPopupGroupSwitcher.__super__.hide.apply(this, arguments);
		return this.groupSubMenuWrapper.unsetClass("active")
	};
	return AvatarPopupGroupSwitcher
}(AvatarPopup);
PopupGroupListItem = function (_super) {
	function PopupGroupListItem(options) {
		var admin, avatar, customize, defaultLogo, roleClasses, roles, slug, title, _ref, _ref1;
		null == options && (options = {});
		options.tagName || (options.tagName = "li");
		options.type || (options.type = "activity-ticker-item");
		PopupGroupListItem.__super__.constructor.apply(this, arguments);
		_ref = this.getData(), _ref1 = _ref.group, title = _ref1.title, avatar = _ref1.avatar, slug = _ref1.slug, customize = _ref1.customize, roles = _ref.roles, admin = _ref.admin;
		roleClasses = roles.map(function (role) {
			return "role-" + role
		}).join(" ");
		this.setClass("role " + roleClasses);
		defaultLogo = "https://koding.s3.amazonaws.com/grouplogo_.png";
		this.groupLogo = new KDCustomHTMLView({
			tagName: "figure",
			cssClass: "avatararea-group-logo"
		});
		this.switchLink = new CustomLinkView({
			title: title,
			cssClass: "avatararea-group-name",
			href: "/" + (slug === KD.defaultSlug ? "" : slug + "/") + "Activity",
			target: slug
		});
		this.adminLink = admin ? new CustomLinkView({
			title: "",
			href: "/" + (slug === KD.defaultSlug ? "" : slug + "/") + "Dashboard",
			target: slug,
			cssClass: "admin-icon",
			iconOnly: !0,
			icon: {
				cssClass: "dashboard-page",
				placement: "right",
				tooltip: {
					title: "Opens admin dashboard in new browser window.",
					delayIn: 300
				}
			}
		}) : new KDCustomHTMLView
	}
	__extends(PopupGroupListItem, _super);
	JView.mixin(PopupGroupListItem.prototype);
	PopupGroupListItem.prototype.pistachio = function () {
		var customize, group, slug;
		group = this.getData().group;
		slug = group.slug, customize = group.customize;
		(null != customize ? customize.logo : void 0) ? this.groupLogo.setCss("background-image", "url(" + (null != customize ? customize.logo : void 0) + ")"): this.groupLogo.setCss("background-color", KD.utils.stringToColor(slug));
		return "{{> this.groupLogo}}{{> this.switchLink}}{{> this.adminLink}}"
	};
	return PopupGroupListItem
}(KDListItemView);
PopupGroupListItemPending = function (_super) {
	function PopupGroupListItemPending(options) {
		var group;
		null == options && (options = {});
		PopupGroupListItemPending.__super__.constructor.apply(this, arguments);
		group = this.getData().group;
		this.setClass("role pending");
		this.acceptButton = new KDButtonView({
			style: "clean-gray",
			title: "Accept Invitation",
			icon: !0,
			iconOnly: !0,
			iconClass: "accept",
			tooltip: {
				title: "Accept Invitation"
			},
			callback: function (_this) {
				return function () {
					return KD.whoami().acceptInvitation(group, function (err) {
						if (err) return warn(err);
						_this.destroy();
						_this.parent.emit("PendingCountDecreased");
						return _this.parent.emit("UpdateGroupList")
					})
				}
			}(this)
		});
		this.ignoreButton = new KDButtonView({
			style: "clean-gray",
			title: "Ignore Invitation",
			icon: !0,
			iconOnly: !0,
			iconClass: "ignore",
			tooltip: {
				title: "Ignore Invitation"
			},
			callback: function (_this) {
				return function () {
					return KD.whoami().ignoreInvitation(group, function (err) {
						if (err) return warn(err);
						new KDNotificationView({
							title: "Ignored!",
							content: "If you change your mind, you can request access to the group anytime.",
							duration: 2e3
						});
						_this.destroy();
						return _this.parent.emit("PendingCountDecreased")
					})
				}
			}(this)
		})
	}
	__extends(PopupGroupListItemPending, _super);
	JView.mixin(PopupGroupListItemPending.prototype);
	PopupGroupListItemPending.prototype.pistachio = function () {
		return "<div class='right-overflow'>\n  <div class=\"buttons\">\n    {{> this.acceptButton}}\n    {{> this.ignoreButton}}\n  </div>\n  {{> this.switchLink}}\n</div>"
	};
	return PopupGroupListItemPending
}(PopupGroupListItem);
var AvatarAreaIconLink, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AvatarAreaIconLink = function (_super) {
	function AvatarAreaIconLink(options, data) {
		options = $.extend({
			tagName: "a",
			partial: "<span class='count'>\n  <cite></cite>\n</span>\n<span class='icon'></span>",
			attributes: {
				href: "#"
			}
		}, options);
		AvatarAreaIconLink.__super__.constructor.call(this, options, data);
		this.count = 0
	}
	__extends(AvatarAreaIconLink, _super);
	AvatarAreaIconLink.prototype.updateCount = function (newCount) {
		null == newCount && (newCount = 0);
		this.$(".count cite").text(newCount);
		this.count = newCount;
		return 0 === newCount ? this.$(".count").removeClass("in") : this.$(".count").addClass("in")
	};
	AvatarAreaIconLink.prototype.click = function (event) {
		var delegate, windowController;
		windowController = KD.singleton("windowController");
		KD.utils.stopDOMEvent(event);
		delegate = this.getDelegate();
		if (delegate.hasClass("active")) {
			this.delegate.hide();
			return windowController.removeLayer(this.delegate)
		}
		this.delegate.show();
		windowController.addLayer(this.delegate);
		return this.delegate.once("ReceivedClickElsewhere", function (_this) {
			return function () {
				return _this.delegate.hide()
			}
		}(this))
	};
	return AvatarAreaIconLink
}(KDCustomHTMLView);
var AvatarAreaIconMenu, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
AvatarAreaIconMenu = function (_super) {
	function AvatarAreaIconMenu() {
		var mainController, troubleshoot, _ref;
		AvatarAreaIconMenu.__super__.constructor.apply(this, arguments);
		this.setClass("account-menu");
		this.helpIcon = new CustomLinkView({
			title: "",
			cssClass: "help acc-dropdown-icon",
			icon: {
				cssClass: "icon"
			},
			attributes: {
				title: "Help",
				href: "http://learn.koding.com",
				target: "_blank"
			}
		});
		this.notificationsPopup = new AvatarPopupNotifications({
			cssClass: "notifications"
		});
		this.notificationsIcon = new AvatarAreaIconLink({
			cssClass: "notifications acc-dropdown-icon",
			attributes: {
				title: "Notifications"
			},
			delegate: this.notificationsPopup
		});
		_ref = KD.singletons, mainController = _ref.mainController, troubleshoot = _ref.troubleshoot;
		troubleshoot.on("userIdle", function () {
			return function () {
				var idleModal;
				return idleModal = new KDModalView({
					title: "You were away from Koding for a while.",
					content: "Your dev VMs might have been turned off. Before you progress please check system status by clicking Resume.",
					overlay: !0,
					buttons: {
						Resume: {
							style: "modal-clean-green",
							callback: function () {
								idleModal.destroy();
								return new TroubleshootModal
							}
						},
						Close: {
							style: "modal-cancel",
							callback: function () {
								return idleModal.destroy()
							}
						}
					}
				})
			}
		}(this));
		mainController.ready(function (_this) {
			return function () {
				var storage;
				storage = KD.singletons.localStorageController.storage("HelpController");
				return storage.getValue("shown") ? void 0 : _this.helpIcon.addSubView(_this.animation = new KDCustomHTMLView({
					tagName: "span",
					cssClass: "intro-marker in help"
				}))
			}
		}(this))
	}
	var filterNotifications;
	__extends(AvatarAreaIconMenu, _super);
	AvatarAreaIconMenu.prototype.pistachio = function () {
		return "{{> this.helpIcon}}\n{{> this.notificationsIcon}}"
	};
	AvatarAreaIconMenu.prototype.viewAppended = function () {
		var mainView;
		AvatarAreaIconMenu.__super__.viewAppended.apply(this, arguments);
		mainView = KD.getSingleton("mainView");
		mainView.addSubView(this.notificationsPopup);
		this.attachListeners();
		return KD.getSingleton("mainController").on("AccountChanged", function (_this) {
			return function () {
				return _this.attachListeners()
			}
		}(this))
	};
	AvatarAreaIconMenu.prototype.attachListeners = function () {
		var listController, noNotification, _ref;
		_ref = this.notificationsPopup, listController = _ref.listController, noNotification = _ref.noNotification;
		KD.getSingleton("notificationController").on("NotificationHasArrived", function () {
			return function (_arg) {
				var event;
				event = _arg.event;
				return listController.fetchNotificationTeasers(function (notifications) {
					noNotification.hide();
					listController.removeAllItems();
					return listController.instantiateListItems(filterNotifications(notifications))
				})
			}
		}(this));
		return listController.on("NotificationCountDidChange", function (_this) {
			return function (count) {
				_this.utils.killWait(_this.notificationsPopup.loaderTimeout);
				count > 0 ? noNotification.hide() : noNotification.show();
				return _this.notificationsIcon.updateCount(count)
			}
		}(this))
	};
	AvatarAreaIconMenu.prototype.accountChanged = function () {
		var listController;
		listController = this.notificationsPopup.listController;
		listController.removeAllItems();
		return KD.isLoggedIn() ? KD.utils.defer(function () {
			return listController.fetchNotificationTeasers(function (teasers) {
				return listController.instantiateListItems(filterNotifications(teasers))
			})
		}) : void 0
	};
	filterNotifications = function (notifications) {
		var activityNameMap;
		activityNameMap = ["JNewStatusUpdate", "JAccount", "JPrivateMessage", "JComment", "JReview", "JGroup"];
		return notifications.filter(function (notification) {
			var snapshot, _ref;
			if (notification.snapshot) try {
				snapshot = JSON.parse(Encoder.htmlDecode(notification.snapshot));
				return _ref = snapshot.anchor.constructorName, __indexOf.call(activityNameMap, _ref) >= 0
			} catch (_error) {}
		})
	};
	return AvatarAreaIconMenu
}(JView);
var AvatarPopupMessages, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AvatarPopupMessages = function (_super) {
	function AvatarPopupMessages() {
		this.notLoggedInMessage = "Login required to see messages";
		AvatarPopupMessages.__super__.constructor.apply(this, arguments)
	}
	__extends(AvatarPopupMessages, _super);
	AvatarPopupMessages.prototype.viewAppended = function () {
		AvatarPopupMessages.__super__.viewAppended.apply(this, arguments);
		this._popupList = new PopupList({
			itemClass: PopupMessageListItem
		});
		this.listController = new MessagesListController({
			view: this._popupList,
			maxItems: 5
		});
		KD.getSingleton("notificationController").on("NewMessageArrived", function (_this) {
			return function () {
				return _this.listController.fetchMessages()
			}
		}(this));
		this.listController.on("AvatarPopupShouldBeHidden", this.bound("hide"));
		this.avatarPopupContent.addSubView(this.noMessage = new KDView({
			height: "auto",
			cssClass: "sublink top hidden",
			partial: "You have no new messages."
		}));
		this.avatarPopupContent.addSubView(this.listController.getView());
		return this.avatarPopupContent.addSubView(new KDView({
			height: "auto",
			cssClass: "sublink",
			partial: "<a href='#'>See all messages...</a>",
			click: function (_this) {
				return function () {
					var appManager;
					appManager = KD.getSingleton("appManager");
					appManager.open("Inbox");
					appManager.tell("Inbox", "goToMessages");
					return _this.hide()
				}
			}(this)
		}))
	};
	AvatarPopupMessages.prototype.show = function () {
		AvatarPopupMessages.__super__.show.apply(this, arguments);
		return this.listController.fetchMessages()
	};
	return AvatarPopupMessages
}(AvatarPopup);
var AvatarPopupNotifications, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AvatarPopupNotifications = function (_super) {
	function AvatarPopupNotifications() {
		this.notLoggedInMessage = "Login required to see notifications";
		AvatarPopupNotifications.__super__.constructor.apply(this, arguments)
	}
	__extends(AvatarPopupNotifications, _super);
	AvatarPopupNotifications.prototype.viewAppended = function () {
		AvatarPopupNotifications.__super__.viewAppended.apply(this, arguments);
		this._popupList = new PopupList({
			itemClass: PopupNotificationListItem
		});
		this.listController = new MessagesListController({
			view: this._popupList,
			maxItems: 5
		});
		this.listController.on("AvatarPopupShouldBeHidden", this.bound("hide"));
		this.avatarPopupContent.addSubView(this.noNotification = new KDView({
			height: "auto",
			cssClass: "sublink top hidden",
			partial: "You have no new notifications."
		}));
		return this.avatarPopupContent.addSubView(this.listController.getView())
	};
	AvatarPopupNotifications.prototype.hide = function () {
		KD.isLoggedIn() && KD.whoami().glanceActivities(function (_this) {
			return function () {
				var item, _i, _len, _ref;
				_ref = _this.listController.itemsOrdered;
				for (_i = 0, _len = _ref.length; _len > _i; _i++) {
					item = _ref[_i];
					item.unsetClass("unread")
				}
				_this.noNotification.show();
				return _this.listController.emit("NotificationCountDidChange", 0)
			}
		}(this));
		return AvatarPopupNotifications.__super__.hide.apply(this, arguments)
	};
	return AvatarPopupNotifications
}(AvatarPopup);
var PopupMessageListItem, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
PopupMessageListItem = function (_super) {
	function PopupMessageListItem(options, data) {
		var group;
		options = $.extend({
			tagName: "li"
		}, options);
		PopupMessageListItem.__super__.constructor.call(this, options, data);
		this.initializeReadState();
		data.participants || (group = {});
		group || (group = data.participants.map(function (participant) {
			return {
				constructorName: participant.sourceName,
				id: participant.sourceId
			}
		}));
		this.participants = new ProfileTextGroup({
			group: group
		});
		this.avatar = new AvatarStaticView({
			size: {
				width: 40,
				height: 40
			},
			origin: group[0]
		})
	}
	__extends(PopupMessageListItem, _super);
	PopupMessageListItem.prototype.initializeReadState = function () {
		return this.getData().getFlagValue("read") ? this.unsetClass("unread") : this.setClass("unread")
	};
	PopupMessageListItem.prototype.viewAppended = function () {
		this.setTemplate(this.pistachio());
		return this.template.update()
	};
	PopupMessageListItem.prototype.teaser = function (text) {
		return utils.shortenText(text, {
			minLength: 40,
			maxLength: 70
		}) || ""
	};
	PopupMessageListItem.prototype.click = function () {
		var appManager, popupList;
		appManager = KD.getSingleton("appManager");
		appManager.open("Inbox");
		appManager.tell("Inbox", "goToMessages", this);
		popupList = this.getDelegate();
		return popupList.emit("AvatarPopupShouldBeHidden")
	};
	PopupMessageListItem.prototype.pistachio = function () {
		return "<span class='avatar'>{{> this.avatar}}</span>\n<div class='right-overflow'>\n  <a href='#'>{{#(subject) || '(No title)'}}</a><br/>\n  {{this.teaser(#(body))}}\n  <footer>\n    <time>{{> this.participants}} {{$.timeago(#(meta.createdAt))}}</time>\n  </footer>\n</div>"
	};
	return PopupMessageListItem
}(KDListItemView);
var PopupNotificationListItem, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
PopupNotificationListItem = function (_super) {
	function PopupNotificationListItem(options, data) {
		null == options && (options = {});
		options.tagName || (options.tagName = "li");
		options.linkGroupClass || (options.linkGroupClass = LinkGroup);
		options.avatarClass || (options.avatarClass = AvatarView);
		PopupNotificationListItem.__super__.constructor.call(this, options, data);
		this.initializeReadState()
	}
	__extends(PopupNotificationListItem, _super);
	PopupNotificationListItem.prototype.initializeReadState = function () {
		return this.getData().getFlagValue("glanced") ? this.unsetClass("unread") : this.setClass("unread")
	};
	PopupNotificationListItem.prototype.pistachio = function () {
		return '{{> this.avatar}}\n<div class="fr">\n  {{> this.participants}}\n  {{this.getActionPhrase(#(dummy))}}\n  {{> this.activityPlot}}\n  {{> this.interactedGroups}}\n  {time{$.timeago(this.getLatestTimeStamp(#(dummy)))}}\n</div>'
	};
	PopupNotificationListItem.prototype.click = function (event) {
		var popupList;
		popupList = this.getDelegate();
		popupList.emit("AvatarPopupShouldBeHidden");
		return PopupNotificationListItem.__super__.click.call(this, event)
	};
	return PopupNotificationListItem
}(NotificationListItem);
var AvatarPopupShareStatus, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AvatarPopupShareStatus = function (_super) {
	function AvatarPopupShareStatus() {
		return AvatarPopupShareStatus.__super__.constructor.apply(this, arguments)
	}
	__extends(AvatarPopupShareStatus, _super);
	AvatarPopupShareStatus.prototype.viewAppended = function () {
		var name;
		AvatarPopupShareStatus.__super__.viewAppended.call(this);
		this.loader = new KDLoaderView({
			cssClass: "avatar-popup-status-loader",
			size: {
				width: 30
			},
			loaderOptions: {
				color: "#ff9200",
				shape: "spiral",
				diameter: 30,
				density: 30,
				range: .4,
				speed: 1,
				FPS: 24
			}
		});
		this.avatarPopupContent.addSubView(this.loader);
		name = KD.utils.getFullnameFromAccount(KD.whoami(), !0);
		return this.avatarPopupContent.addSubView(this.statusField = new KDHitEnterInputView({
			type: "textarea",
			validate: {
				rules: {
					required: !0
				}
			},
			placeholder: "What's new, " + name + "?",
			callback: function (_this) {
				return function (status) {
					return _this.updateStatus(status)
				}
			}(this)
		}))
	};
	AvatarPopupShareStatus.prototype.updateStatus = function (status) {
		this.loader.show();
		return KD.remote.api.JNewStatusUpdate.create({
			body: status
		}, function (_this) {
			return function (err) {
				if (err) {
					new KDNotificationView({
						type: "mini",
						title: "There was an error, try again later!"
					});
					_this.loader.hide();
					return _this.hide()
				}
				new KDNotificationView({
					type: "growl",
					cssClass: "mini",
					title: "Message posted!",
					duration: 2e3
				});
				_this.statusField.setValue("");
				_this.loader.hide();
				return _this.hide()
			}
		}(this))
	};
	return AvatarPopupShareStatus
}(AvatarPopup);
var GroupData, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
GroupData = function (_super) {
	function GroupData() {
		return GroupData.__super__.constructor.apply(this, arguments)
	}
	__extends(GroupData, _super);
	GroupData.prototype.getAt = function (path) {
		return JsPath.getAt(this.data, path)
	};
	GroupData.prototype.setGroup = function (group) {
		this.data = group;
		return this.emit("update")
	};
	return GroupData
}(KDEventEmitter);
var AppSettingsMenuButton, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AppSettingsMenuButton = function (_super) {
	function AppSettingsMenuButton(options, data) {
		null == options && (options = {});
		options.cssClass = "app-settings-menu";
		options.iconOnly = !0;
		options.callback = function (_this) {
			return function (event) {
				var menu, menuItems;
				menu = _this.getData();
				if (menu.items) {
					_this.menuWidth = menu.width || 172;
					menuItems = menu.items.filter(function (item) {
						var childItems, customView, menuWithoutChilds, parents, response, _ref;
						if (item.parentId) {
							parents = _.filter(menu.items, function (menuItem) {
								return menuItem.id === item.parentId
							});
							parents.forEach(function (parentItem) {
								return parentItem.children || (parentItem.children = [])
							})
						}
						if (item.condition) {
							response = item.condition(getVisibleView());
							if (!response) return
						}
						item.callback = function (contextmenu) {
							var view;
							view = getVisibleView();
							null != view && view.emit("" + item.eventName + "MenuItemClicked", item.eventName, item, contextmenu, _this.offset);
							return item.eventName ? _this.contextMenu.destroy() : void 0
						};
						if (0 === (null != (_ref = item.title) ? _ref.indexOf("customView") : void 0)) {
							customView = getCustomMenuView(item, _this);
							if (!customView) return;
							if (customView instanceof KDView) item.view = customView;
							else {
								childItems = JContextMenuTreeViewController.convertToArray(customView, item.parentId);
								menuWithoutChilds = _.filter(menu.items, function (menuItem) {
									return menuItem.parentId !== item.parentId
								});
								menu.items = menuWithoutChilds.concat(childItems)
							}
						}
						return item
					});
					return menuItems.length > 0 ? _this.createMenu(event, menuItems) : void 0
				}
			}
		}(this);
		AppSettingsMenuButton.__super__.constructor.call(this, options, data)
	}
	var getCustomMenuView, getVisibleView;
	__extends(AppSettingsMenuButton, _super);
	getVisibleView = function () {
		var mainTabView, view, _ref;
		mainTabView = KD.getSingleton("mainView").mainTabView;
		view = null != (_ref = mainTabView.activePane) ? _ref.mainView : void 0;
		return view
	};
	getCustomMenuView = function (item, obj) {
		var customMenu, view, _name;
		view = getVisibleView();
		item.type = "customView";
		return customMenu = "function" == typeof view[_name = "get" + item.title.replace(/^customView/, "") + "MenuView"] ? view[_name](item, obj) : void 0
	};
	AppSettingsMenuButton.prototype.createMenu = function (event, menu) {
		this.offset = this.$().offset();
		this.contextMenu = new KDContextMenu({
			cssClass: "app-settings",
			delegate: this,
			x: this.offset.left - this.menuWidth - 3,
			y: this.offset.top + 8,
			arrow: {
				placement: "right",
				margin: 5
			}
		}, menu);
		return this.contextMenu.on("viewAppended", function (_this) {
			return function () {
				return _this.menuWidth > 172 ? _this.contextMenu.setWidth(_this.menuWidth) : void 0
			}
		}(this))
	};
	return AppSettingsMenuButton
}(KDButtonView);
var MainView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
MainView = function (_super) {
	function MainView() {
		MainView.__super__.constructor.apply(this, arguments);
		this.notifications = []
	}
	var removePulsing;
	__extends(MainView, _super);
	MainView.prototype.viewAppended = function () {
		this.bindPulsingRemove();
		this.bindTransitionEnd();
		this.createHeader();
		this.createMainPanels();
		this.createMainTabView();
		return KD.singletons.mainController.ready(function (_this) {
			return function () {
				_this.createAccountArea();
				_this.setStickyNotification();
				return _this.emit("ready")
			}
		}(this))
	};
	MainView.prototype.createMainPanels = function () {
		return this.addSubView(this.panelWrapper = new KDView({
			tagName: "section",
			domId: "main-panel-wrapper"
		}))
	};
	MainView.prototype.createHeader = function () {
		var entryPoint, groupLogo, _ref, _ref1;
		entryPoint = KD.config.entryPoint;
		this.addSubView(this.header = new KDView({
			tagName: "header",
			domId: "main-header",
			cssClass: KD.isLoggedIn() ? void 0 : "no-dock"
		}));
		this.header.clear();
		this.header.addSubView(this.headerContainer = new KDCustomHTMLView({
			cssClass: "inner-container"
		}));
		this.logo = new KDCustomHTMLView({
			tagName: "a",
			domId: "koding-logo",
			cssClass: "group" === (null != entryPoint ? entryPoint.type : void 0) ? "group" : "",
			partial: "<cite></cite>",
			click: function () {
				return function (event) {
					var router;
					KD.utils.stopDOMEvent(event);
					router = KD.singletons.router;
					return KD.isLoggedIn() ? router.handleRoute("/Activity", {
						entryPoint: entryPoint
					}) : router.handleRoute("/", {
						entryPoint: entryPoint
					})
				}
			}(this)
		});
		this.headerContainer.addSubView(this.logo);
		groupLogo = "";
		if (null != (_ref = KD.currentGroup) && null != (_ref1 = _ref.customize) ? _ref1.logo : void 0) {
			groupLogo = KD.utils.proxifyUrl(KD.currentGroup.logo, {
				crop: !0,
				width: 55,
				height: 55
			});
			this.logo.setCss("background-image", "url(" + groupLogo + ")");
			this.logo.setClass("custom")
		}
		this.logo.setClass(KD.config.environment);
		this.headerContainer.addSubView(this.logotype = new CustomLinkView({
			cssClass: "logotype",
			title: "Koding",
			href: "/Home"
		}));
		this.addDock();
		return this.addLoggedOutNav()
	};
	MainView.prototype.addDock = function () {
		return this.headerContainer.addSubView(KD.singleton("dock").getView())
	};
	MainView.prototype.showDock = function () {
		return this.header.unsetClass("no-dock")
	};
	MainView.prototype.hideDock = function () {
		return this.header.setClass("no-dock")
	};
	MainView.prototype.addLoggedOutNav = function () {
		var appManager, loggedOutNav, navDomElement;
		this.headerContainer.addSubView(loggedOutNav = new KDCustomHTMLView({
			tagName: "nav",
			partial: "<a href='/Education' class='education'>EDUCATION</a>\n<a href='/Business'  class='business'>BUSINESS</a>\n<a href='/About'     class='about'>ABOUT</a>\n<a href='/Pricing'   class='pricing'>PRICING</a>\n<a href='/Login' class='login'>SIGN IN</a>"
		}));
		appManager = KD.singleton("appManager");
		navDomElement = loggedOutNav.domElement.context;
		return appManager.on("AppIsBeingShown", function (instance, view, options) {
			var appName, child, target, _i, _len, _ref;
			appName = options.name.toLowerCase();
			_ref = navDomElement.children;
			for (_i = 0, _len = _ref.length; _len > _i; _i++) {
				child = _ref[_i];
				child.classList.remove("active")
			}
			target = navDomElement.getElementsByClassName(appName)[0];
			return null != target ? target.classList.add("active") : void 0
		})
	};
	MainView.prototype.createAccountArea = function () {
		var mc;
		this.accountArea = new KDCustomHTMLView({
			cssClass: "account-area"
		});
		this.headerContainer.addSubView(this.accountArea);
		if (KD.isLoggedIn()) return this.createLoggedInAccountArea();
		mc = KD.getSingleton("mainController");
		return mc.once("accountChanged.to.loggedIn", this.bound("createLoggedInAccountArea"))
	};
	MainView.prototype.createLoggedInAccountArea = function () {
		var handleRoute, search;
		KDView.setElementClass(document.body, "add", "logged-in");
		this.accountArea.destroySubViews();
		this.accountArea.addSubView(this.accountMenu = new AvatarAreaIconMenu);
		KD.utils.defer(function (_this) {
			return function () {
				return _this.accountMenu.accountChanged(KD.whoami())
			}
		}(this));
		this.accountArea.addSubView(this.avatarArea = new AvatarArea({}, KD.whoami()));
		this.accountArea.addSubView(this.searchIcon = new KDCustomHTMLView({
			domId: "fatih-launcher",
			cssClass: "search acc-dropdown-icon",
			tagName: "a",
			attributes: {
				title: "Search",
				href: "#"
			},
			click: function (_this) {
				return function (event) {
					KD.utils.stopDOMEvent(event);
					_this.accountArea.setClass("search-open");
					_this.searchInput.setFocus();
					KD.getSingleton("windowController").addLayer(_this.searchInput);
					return _this.searchInput.once("ReceivedClickElsewhere", function () {
						return _this.accountArea.unsetClass("search-open")
					})
				}
			}(this),
			partial: "<span class='icon'></span>"
		}));
		this.accountArea.addSubView(this.searchForm = new KDCustomHTMLView({
			cssClass: "search-form-container"
		}));
		handleRoute = function (searchRoute, text) {
			var group, groupSlug, toBeReplaced;
			groupSlug = (group = KD.getSingleton("groupsController").getCurrentGroup()) ? "koding" === group.slug ? "" : "/" + group.slug : "";
			toBeReplaced = "" === text ? "?q=:text:" : ":text:";
			searchRoute = searchRoute.replace(toBeReplaced, text);
			searchRoute = "" + groupSlug + searchRoute;
			return KD.getSingleton("router").handleRoute(searchRoute)
		};
		search = function (text) {
			var currentApp, searchRoute;
			currentApp = KD.getSingleton("appManager").getFrontApp();
			return currentApp && (searchRoute = currentApp.options.searchRoute) ? handleRoute(searchRoute, text) : handleRoute("/Activity?q=:text:", text)
		};
		return this.searchForm.addSubView(this.searchInput = new KDInputView({
			placeholder: "Search here...",
			keyup: function (_this) {
				return function (event) {
					var text;
					text = _this.searchInput.getValue();
					if ("" === text && _this.searchInput.searched) {
						search("");
						_this.searchInput.searched = !1
					}
					if (13 === event.keyCode) {
						search(text);
						_this.searchInput.searched = !0
					}
					if (27 === event.keyCode) {
						_this.accountArea.unsetClass("search-open");
						_this.searchInput.setValue("");
						return _this.searchInput.searched = !1
					}
				}
			}(this)
		}))
	};
	MainView.prototype.createMainTabView = function () {
		this.appSettingsMenuButton = new AppSettingsMenuButton;
		this.appSettingsMenuButton.hide();
		this.mainTabView = new MainTabView({
			domId: "main-tab-view",
			listenToFinder: !0,
			delegate: this,
			slidingPanes: !1,
			hideHandleContainer: !0
		});
		this.mainTabView.on("PaneDidShow", function (_this) {
			return function (pane) {
				var appManager, appManifest, forntAppName, menu, _ref, _ref1;
				appManager = KD.getSingleton("appManager");
				if (appManager.getFrontApp()) {
					appManifest = appManager.getFrontAppManifest();
					forntAppName = appManager.getFrontApp().getOptions().name;
					menu = (null != appManifest ? appManifest.menu : void 0) || (null != (_ref = KD.getAppOptions(forntAppName)) ? _ref.menu : void 0);
					Array.isArray(menu) && (menu = {
						items: menu
					});
					_this.appSettingsMenuButton.hide();
					if (null != menu && null != (_ref1 = menu.items) ? _ref1.length : void 0) {
						_this.appSettingsMenuButton.setData(menu);
						menu.hiddenOnStart || _this.appSettingsMenuButton.show()
					}
					return _this.emit("MainTabPaneShown", pane)
				}
			}
		}(this));
		this.mainTabView.on("AllPanesClosed", function () {
			return KD.getSingleton("router").handleRoute("/Activity")
		});
		this.panelWrapper.addSubView(this.mainTabView);
		return this.panelWrapper.addSubView(this.appSettingsMenuButton)
	};
	MainView.prototype.setStickyNotification = function () {
		var JSystemStatus;
		if (KD.isLoggedIn()) {
			JSystemStatus = KD.remote.api.JSystemStatus;
			JSystemStatus.on("restartScheduled", this.bound("handleSystemMessage"));
			return KD.utils.wait(2e3, function (_this) {
				return function () {
					return KD.remote.api.JSystemStatus.getCurrentSystemStatuses(function (err, statuses) {
						var daisy, queue;
						if (err) return log("current system status:", err);
						if (statuses && Array.isArray(statuses)) {
							daisy = Bongo.daisy;
							queue = statuses.map(function (status) {
								return function () {
									_this.createGlobalNotification(status);
									return KD.utils.wait(500, function () {
										return queue.next()
									})
								}
							});
							return daisy(queue.reverse())
						}
					})
				}
			}(this))
		}
	};
	MainView.prototype.handleSystemMessage = function (message) {
		return "active" === message.status ? this.createGlobalNotification(message) : void 0
	};
	MainView.prototype.hideAllNotifications = function () {
		var notification, _i, _len, _ref, _results;
		_ref = this.notifications;
		_results = [];
		for (_i = 0, _len = _ref.length; _len > _i; _i++) {
			notification = _ref[_i];
			_results.push(notification.hide())
		}
		return _results
	};
	MainView.prototype.createGlobalNotification = function (message, options) {
		var container, notification, typeMap;
		null == options && (options = {});
		typeMap = {
			restart: "warn",
			reload: "",
			info: "",
			red: "err",
			yellow: "warn",
			green: ""
		};
		options.type || (options.type = typeMap[message.type]);
		null == options.showTimer && (options.showTimer = "restart" !== message.type);
		options.cssClass = KD.utils.curry("header-notification", options.type);
		options.animated && (options.cssClass = KD.utils.curry(options.cssClass, "fx"));
		this.notifications.push(notification = new GlobalNotificationView(options, message));
		container = message.container || this.header;
		container.addSubView(notification);
		this.hideAllNotifications();
		notification.once("KDObjectWillBeDestroyed", function (_this) {
			return function () {
				var i, n, _i, _len, _ref, _ref1, _results;
				_ref = _this.notifications;
				_results = [];
				for (i = _i = 0, _len = _ref.length; _len > _i; i = ++_i) {
					n = _ref[i];
					if (n.getId() === notification.getId()) {
						null != (_ref1 = _this.notifications[i - 1]) && _ref1.show();
						break
					}
					_results.push(void 0)
				}
				return _results
			}
		}(this));
		KD.utils.wait(177, notification.bound("show"));
		return notification
	};
	MainView.prototype.enableFullscreen = function () {
		this.setClass("fullscreen no-anim");
		this.emit("fullscreen", !0);
		return KD.getSingleton("windowController").notifyWindowResizeListeners()
	};
	MainView.prototype.disableFullscreen = function () {
		this.unsetClass("fullscreen no-anim");
		this.emit("fullscreen", !1);
		return KD.getSingleton("windowController").notifyWindowResizeListeners()
	};
	MainView.prototype.isFullscreen = function () {
		return this.hasClass("fullscreen")
	};
	MainView.prototype.toggleFullscreen = function () {
		return this.isFullscreen() ? this.disableFullscreen() : this.enableFullscreen()
	};
	MainView.prototype.bindPulsingRemove = function () {
		var appManager, router;
		router = KD.getSingleton("router");
		appManager = KD.getSingleton("appManager");
		appManager.once("AppCouldntBeCreated", removePulsing);
		return appManager.on("AppCreated", function (appInstance) {
			var appEmitsReady, appView, checkedRoute, name, options, routeArr, title;
			options = appInstance.getOptions();
			title = options.title, name = options.name, appEmitsReady = options.appEmitsReady;
			routeArr = location.pathname.split("/");
			routeArr.shift();
			checkedRoute = "Develop" === routeArr.first ? routeArr.last : routeArr.first;
			if (checkedRoute === name || checkedRoute === title) {
				if (appEmitsReady) {
					appView = appInstance.getView();
					return appView.ready(removePulsing)
				}
				return removePulsing()
			}
		})
	};
	MainView.prototype._logoutAnimation = function () {
		var body, turnOffDot, turnOffLine;
		body = document.body;
		turnOffLine = new KDCustomHTMLView({
			cssClass: "turn-off-line"
		});
		turnOffDot = new KDCustomHTMLView({
			cssClass: "turn-off-dot"
		});
		turnOffLine.appendToDomBody();
		turnOffDot.appendToDomBody();
		body.style.background = "#000";
		return this.setClass("logout-tv")
	};
	removePulsing = function () {
		var loadingScreen, logo;
		loadingScreen = document.getElementById("main-loading");
		if (loadingScreen) {
			logo = loadingScreen.children[0];
			logo.classList.add("out");
			return KD.utils.wait(750, function () {
				loadingScreen.classList.add("out");
				return KD.utils.wait(750, function () {
					var cdc, display, duration, id, mainView, top, _ref, _results;
					loadingScreen.parentElement.removeChild(loadingScreen);
					if (!KD.isLoggedIn()) {
						cdc = KD.singleton("display");
						mainView = KD.getSingleton("mainView");
						if (Object.keys(cdc.displays).length) {
							_ref = cdc.displays;
							_results = [];
							for (id in _ref)
								if (__hasProp.call(_ref, id)) {
									display = _ref[id];
									top = display.$().offset().top;
									duration = 400;
									KDScrollView.prototype.scrollTo.call(mainView, {
										top: top,
										duration: duration
									});
									break
								}
							return _results
						}
					}
				})
			})
		}
	};
	return MainView
}(KDView);
var MainViewController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
MainViewController = function (_super) {
	function MainViewController() {
		var appManager, display, killRepeat, mainView, repeat, windowController, _ref;
		MainViewController.__super__.constructor.apply(this, arguments);
		_ref = KD.utils, repeat = _ref.repeat, killRepeat = _ref.killRepeat;
		mainView = this.getView();
		appManager = KD.singleton("appManager");
		windowController = KD.singleton("windowController");
		display = KD.singleton("display");
		mainView.on("MainTabPaneShown", function (_this) {
			return function (pane) {
				return _this.mainTabPaneChanged(mainView, pane)
			}
		}(this));
		appManager.on("AppIsBeingShown", function (_this) {
			return function (controller) {
				return _this.setBodyClass(KD.utils.slugify(controller.getOption("name")))
			}
		}(this));
		display.on("ContentDisplayWantsToBeShown", function (_this) {
			return function () {
				var type;
				type = null;
				return function (view) {
					return (type = view.getOption("type")) ? _this.setBodyClass(type) : void 0
				}
			}
		}(this)());
		windowController.on("ScrollHappened", function () {
			var currentHeight, lastScroll, threshold;
			threshold = 50;
			lastScroll = 0;
			currentHeight = 0;
			return _.throttle(function () {
				var current, el, scrollHeight, scrollTop, _ref1;
				el = document.body;
				scrollHeight = el.scrollHeight, scrollTop = el.scrollTop;
				if (!(scrollHeight <= window.innerHeight || 0 >= scrollTop)) {
					current = scrollTop + window.innerHeight;
					if (current > scrollHeight - threshold) {
						if (lastScroll > 0) return;
						null != (_ref1 = appManager.getFrontApp()) && _ref1.emit("LazyLoadThresholdReached");
						lastScroll = current;
						currentHeight = scrollHeight
					} else lastScroll > current && (lastScroll = 0);
					return scrollHeight !== currentHeight ? lastScroll = 0 : void 0
				}
			}, 200)
		}())
	}
	__extends(MainViewController, _super);
	MainViewController.prototype.setBodyClass = function () {
		var previousClass;
		previousClass = null;
		return function (name) {
			var body;
			body = document.body;
			previousClass && KDView.setElementClass(body, "remove", previousClass);
			KDView.setElementClass(body, "add", name);
			return previousClass = name
		}
	}();
	MainViewController.prototype.loadView = function (mainView) {
		return mainView.ready(function () {
			return function () {
				var body;
				body = document.body;
				return KD.checkFlag("super-admin") ? KDView.setElementClass(body, "add", "super") : KDView.setElementClass(body, "remove", "super")
			}
		}(this))
	};
	MainViewController.prototype.mainTabPaneChanged = function (mainView, pane) {
		var app, appManager, mainTabView, navController, title;
		appManager = KD.getSingleton("appManager");
		app = appManager.getFrontApp();
		mainTabView = mainView.mainTabView;
		navController = KD.singleton("dock").navController;
		pane ? this.setViewState(pane.getOptions()) : mainTabView.getActivePane().show();
		title = null != app ? app.getOption("navItem").title : void 0;
		return title ? navController.selectItemByName(title) : navController.deselectAllItems()
	};
	MainViewController.prototype.setViewState = function (options) {
		var appsWithDock, behavior, fullSizeApps, html, isApp, mainView, name;
		null == options && (options = {});
		behavior = options.behavior, name = options.name;
		html = document.documentElement;
		mainView = this.getView();
		fullSizeApps = ["Login"];
		appsWithDock = ["Activity", "Topics", "Members", "content-display", "Apps", "Dashboard", "Account", "Environments", "Bugs"];
		(isApp = "application" === behavior) || __indexOf.call(fullSizeApps, name) >= 0 ? KDView.setElementClass(html, "add", "app") : KDView.setElementClass(html, "remove", "app");
		return isApp || __indexOf.call(appsWithDock, name) >= 0 ? this.getView().showDock() : this.getView().hideDock()
	};
	return MainViewController
}(KDViewController);
var DockController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
DockController = function (_super) {
	function DockController(options, data) {
		var mainController;
		null == options && (options = {});
		options.view || (options.view = new KDCustomHTMLView({
			domId: "dock"
		}));
		DockController.__super__.constructor.call(this, options, data);
		this.storage = new AppStorage("Dock", "1.0.3");
		this.navController = new MainNavController({
			view: new NavigationList({
				domId: "main-nav",
				testPath: "navigation-list",
				type: "navigation",
				itemClass: NavigationLink,
				testPath: "navigation-list"
			}),
			wrapper: !1,
			scrollView: !1
		}, {
			id: "navigation",
			title: "navigation",
			items: []
		});
		mainController = KD.getSingleton("mainController");
		mainController.ready(this.bound("accountChanged"));
		this.trackStateTransitions();
		this.bindKeyCombos()
	}
	var defaultItems, isRunning;
	__extends(DockController, _super);
	defaultItems = [{
		title: "Activity",
		path: "/Activity",
		order: 10,
		type: "persistent"
	}, {
		title: "Teamwork",
		path: "/Teamwork",
		order: 20,
		type: "persistent"
	}, {
		title: "Terminal",
		path: "/Terminal",
		order: 30,
		type: "persistent"
	}, {
		title: "Editor",
		path: "/Ace",
		order: 40,
		type: "persistent"
	}, {
		title: "Apps",
		path: "/Apps",
		order: 50,
		type: "persistent"
	}, {
		title: "DevTools",
		path: "/DevTools",
		order: 60,
		type: "persistent"
	}];
	DockController.prototype.buildNavItems = function (sourceItems) {
		var defaultItem, finalItems, sourceItem, _defaults, _i, _j, _len, _len1, _sources;
		finalItems = [];
		_sources = KD.utils.arrayToObject(sourceItems, "title");
		for (_i = 0, _len = defaultItems.length; _len > _i; _i++) {
			defaultItem = defaultItems[_i];
			sourceItem = _sources[defaultItem.title];
			if (sourceItem) {
				if (sourceItem.deleted) continue;
				sourceItem.type = defaultItem.type;
				finalItems.push(sourceItem)
			} else finalItems.push(defaultItem)
		}
		_defaults = KD.utils.arrayToObject(defaultItems, "title");
		for (_j = 0, _len1 = sourceItems.length; _len1 > _j; _j++) {
			sourceItem = sourceItems[_j];
			defaultItem = _defaults[sourceItem.title];
			defaultItem || finalItems.push(sourceItem)
		}
		return finalItems
	};
	DockController.prototype.saveItemOrders = function (items) {
		var data, index, item, navItems;
		items || (items = this.getItems());
		navItems = [];
		for (index in items)
			if (__hasProp.call(items, index)) {
				item = items[index];
				data = item.data;
				data.order = index;
				navItems.push(data)
			}
		return this.storage.setValue("navItems", navItems, function (err) {
			return err ? warn("Failed to save navItems order", err) : void 0
		})
	};
	DockController.prototype.resetItemSettings = function () {
		var index, item;
		for (index in defaultItems)
			if (__hasProp.call(defaultItems, index)) {
				item = defaultItems[index];
				item.order = index
			}
		return this.storage.unsetKey("navItems", function (_this) {
			return function (err) {
				err && warn("Failed to reset navItems", err);
				KD.resetNavItems(defaultItems);
				_this.navController.reset();
				return "Navigation items has been reset."
			}
		}(this))
	};
	DockController.prototype.setNavItems = function (items) {
		KD.setNavItems(items);
		return this.navController.reset()
	};
	DockController.prototype.addItem = function (item) {
		if (__indexOf.call(this.getItems(), item) < 0) {
			KD.registerNavItem(item);
			this.navController.addItem(item);
			return this.saveItemOrders()
		}
	};
	DockController.prototype.removeItem = function (item) {
		var appManager, router, _ref;
		if ("persistent" !== item.data.type) {
			_ref = KD.singletons, appManager = _ref.appManager, router = _ref.router;
			appManager.quitByName(item.name);
			item.hasClass("running") && item.hasClass("selected") && (router.visitedRoutes.length > 1 ? router.back() : router.handleRoute("/Activity"));
			this.navController.removeItem(item);
			return this.saveItemOrders()
		}
	};
	DockController.prototype.accountChanged = function () {
		this.navController.reset();
		return this.storage.fetchValue("navItems", function (_this) {
			return function (usersNavItems) {
				if (!usersNavItems) {
					_this.setNavItems(defaultItems);
					return _this.emit("ready")
				}
				_this.setNavItems(_this.buildNavItems(usersNavItems));
				return _this.emit("ready")
			}
		}(this))
	};
	DockController.prototype.getItems = function () {
		return this.navController.getView().items
	};
	DockController.prototype.setNavItemState = function (_arg, state) {
		var name, options, route;
		name = _arg.name, route = _arg.route, options = _arg.options;
		return this.ready(function (_this) {
			return function () {
				var dockPath, hasNav, i, nav, path, select, _i, _len, _ref, _ref1;
				if ("active" === state) {
					state = "running";
					select = !0
				}
				options || (options = {});
				dockPath = options.dockPath;
				route || (route = (null != (_ref = options.navItem) ? _ref.path : void 0) || "-");
				_ref1 = _this.getItems();
				for (i = _i = 0, _len = _ref1.length; _len > _i; i = ++_i) {
					nav = _ref1[i];
					if (RegExp("^" + route).test(nav.data.path) || dockPath === nav.data.path || nav.data.path === "/" + name || "/" + name === nav.data.path || nav.name === name) {
						nav.setState(state);
						select && _this.navController.selectItem(nav);
						hasNav = !0;
						_this.emit("NavItemStateChanged", {
							item: nav,
							index: i,
							state: state
						})
					}
				}
				if (!hasNav && "initial" !== state && __indexOf.call(Object.keys(KD.config.apps), name) < 0) {
					path = dockPath ? dockPath : "/" + name;
					return _this.addItem({
						title: name,
						path: path,
						order: 60 + KD.utils.uniqueId(),
						type: ""
					})
				}
			}
		}(this))
	};
	DockController.prototype.loadView = function (dock) {
		return this.ready(function (_this) {
			return function () {
				var appManager, kodingAppsController, name, _ref, _ref1;
				_this.scrollView = new KDCustomScrollView;
				dock.addSubView(_this.scrollView);
				_this.scrollView.wrapper.addSubView(_this.navController.getView());
				_ref = KD.singletons, appManager = _ref.appManager, kodingAppsController = _ref.kodingAppsController;
				for (name in appManager.appControllers) _this.setNavItemState({
					name: name
				}, "active");
				_ref1 = KD.singletons, appManager = _ref1.appManager, kodingAppsController = _ref1.kodingAppsController;
				appManager.on("AppRegistered", function (name, options) {
					return _this.setNavItemState({
						name: name,
						options: options
					}, "running")
				});
				appManager.on("AppUnregistered", function (name, options) {
					return _this.setNavItemState({
						name: name,
						options: options
					}, "initial")
				});
				return appManager.on("AppIsBeingShown", function (instance, view, options) {
					return _this.setNavItemState({
						name: options.name,
						options: options
					}, "active")
				})
			}
		}(this))
	};
	isRunning = function (item) {
		return "running" === (null != item ? item.state : void 0)
	};
	DockController.prototype.getRelativeItem = function (increment, predicate) {
		var i, item, len;
		i = this.activeIndex;
		len = this.navController.itemsOrdered.length;
		for (;;) {
			i += increment;
			0 > i ? i += len : i >= len && (i -= len);
			item = this.itemStates[i];
			if (item === this || predicate(item)) return item
		}
	};
	DockController.prototype.activatePreviousApp = function (e) {
		var item;
		e.preventDefault();
		item = this.getRelativeItem(-1, isRunning);
		return this.setActiveItem(item.item)
	};
	DockController.prototype.activateNextApp = function (e) {
		var item;
		e.preventDefault();
		item = this.getRelativeItem(1, isRunning);
		return this.setActiveItem(item.item)
	};
	DockController.prototype.setActiveItem = function (item) {
		return KD.singletons.router.handleRoute(item.getData().path)
	};
	DockController.prototype.trackStateTransitions = function () {
		this.itemStates = [];
		this.activeIndex = null;
		return this.on("NavItemStateChanged", function (info) {
			var index, item, state;
			index = info.index, item = info.item, state = info.state;
			this.itemStates[index] = info;
			return "running" === state ? this.activeIndex = index : void 0
		})
	};
	DockController.prototype.openApp = function (index) {
		var item, len, path;
		len = this.navController.itemsOrdered.length;
		0 > index && (index += len);
		item = this.navController.itemsOrdered[index];
		if (null != item) {
			path = item.getData().path;
			return KD.singletons.router.handleRoute(path)
		}
	};
	DockController.prototype.bindKeyCombos = function () {
		var globalKeyCombos;
		globalKeyCombos = KD.singletons.globalKeyCombos;
		return globalKeyCombos.addCombo("command+option+[", this.bound("activatePreviousApp")).addCombo("command+option+]", this.bound("activateNextApp")).addCombo("command+option+1", function (_this) {
			return function () {
				return _this.openApp(0)
			}
		}(this)).addCombo("command+option+2", function (_this) {
			return function () {
				return _this.openApp(1)
			}
		}(this)).addCombo("command+option+3", function (_this) {
			return function () {
				return _this.openApp(2)
			}
		}(this)).addCombo("command+option+4", function (_this) {
			return function () {
				return _this.openApp(3)
			}
		}(this)).addCombo("command+option+5", function (_this) {
			return function () {
				return _this.openApp(4)
			}
		}(this)).addCombo("command+option+6", function (_this) {
			return function () {
				return _this.openApp(5)
			}
		}(this)).addCombo("command+option+7", function (_this) {
			return function () {
				return _this.openApp(6)
			}
		}(this)).addCombo("command+option+8", function (_this) {
			return function () {
				return _this.openApp(7)
			}
		}(this)).addCombo("command+option+9", function (_this) {
			return function () {
				return _this.openApp(-1)
			}
		}(this))
	};
	return DockController
}(KDViewController);
var GroupsController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__slice = [].slice;
GroupsController = function (_super) {
	function GroupsController(options, data) {
		null == options && (options = {});
		GroupsController.__super__.constructor.call(this, options, data);
		this.isReady = !1;
		this.utils.defer(this.bound("init"))
	}
	__extends(GroupsController, _super);
	GroupsController.prototype.init = function () {
		var entryPoint, mainController, router;
		mainController = KD.getSingleton("mainController");
		router = KD.getSingleton("router");
		entryPoint = KD.config.entryPoint;
		this.groups = {};
		this.currentGroupData = new GroupData;
		mainController.on("NavigationLinkTitleClick", function () {
			return function (pageInfo) {
				return pageInfo.path ? pageInfo.topLevel ? router.handleRoute("" + pageInfo.path) : router.handleRoute("" + pageInfo.path, {
					entryPoint: entryPoint
				}) : void 0
			}
		}(this));
		return mainController.ready(function (_this) {
			return function () {
				var slug;
				"group" === (null != entryPoint ? entryPoint.type : void 0) && (slug = entryPoint.slug);
				return _this.changeGroup(slug)
			}
		}(this))
	};
	GroupsController.prototype.getCurrentGroup = function () {
		if (Array.isArray(this.currentGroupData.data)) throw "FIXME: array should never be passed";
		return this.currentGroupData.data
	};
	GroupsController.prototype.filterXssAndForwardEvents = function (target, events) {
		return events.forEach(function (_this) {
			return function (event) {
				return target.on(event, function () {
					var rest;
					rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
					rest = KD.remote.revive(rest);
					return _this.emit.apply(_this, [event].concat(__slice.call(rest)))
				})
			}
		}(this))
	};
	GroupsController.prototype.openGroupChannel = function (group, callback) {
		null == callback && (callback = function () {});
		this.groupChannel = KD.remote.subscribe("group." + group.slug, {
			serviceType: "group",
			group: group.slug,
			isExclusive: !0
		});
		this.filterXssAndForwardEvents(this.groupChannel, ["MemberJoinedGroup", "FollowHappened", "LikeIsAdded", "PostIsCreated", "ReplyIsAdded", "PostIsDeleted", "LikeIsRemoved"]);
		return this.groupChannel.once("setSecretNames", callback)
	};
	GroupsController.prototype.changeGroup = function (groupName, callback) {
		var oldGroupName;
		null == groupName && (groupName = "koding");
		null == callback && (callback = function () {});
		if (this.currentGroupName === groupName) return callback();
		oldGroupName = this.currentGroupName;
		this.currentGroupName = groupName;
		return KD.remote.cacheable(groupName, function (_this) {
			return function (err, models) {
				var group;
				if (err) return callback(err);
				if (null != models) {
					group = models[0];
					if ("JGroup" !== group.bongo_.constructorName) return _this.changeGroup("koding");
					_this.setGroup(groupName);
					_this.currentGroupData.setGroup(group);
					callback(null, groupName, group);
					_this.openGroupChannel(KD.getGroup());
					return _this.emit("ready")
				}
			}
		}(this))
	};
	GroupsController.prototype.getUserArea = function () {
		var _ref, _ref1;
		return null != (_ref = this.userArea) ? _ref : {
			group: "group" === (null != (_ref1 = KD.config.entryPoint) ? _ref1.type : void 0) ? KD.config.entryPoint.slug : KD.getSingleton("groupsController").currentGroupName
		}
	};
	GroupsController.prototype.setUserArea = function (userArea) {
		return this.userArea = userArea
	};
	GroupsController.prototype.getGroupSlug = function () {
		return this.currentGroupName
	};
	GroupsController.prototype.setGroup = function (groupName) {
		this.currentGroupName = groupName;
		return this.setUserArea({
			group: groupName,
			user: KD.whoami().profile.nickname
		})
	};
	GroupsController.prototype.joinGroup = function (group, callback) {
		return group.join(function () {
			return function (err, response) {
				if (null != err) return KD.showError(err);
				callback(err, response);
				KD.getSingleton("mainController").emit("JoinedGroup");
				return KD.mixpanel("Join group, success", {
					slug: group.slug
				})
			}
		}(this))
	};
	GroupsController.prototype.acceptInvitation = function (group, callback) {
		return KD.whoami().acceptInvitation(group, function (_this) {
			return function (err, res) {
				var mainController;
				mainController = KD.getSingleton("mainController");
				mainController.once("AccountChanged", callback.bind(_this, err, res));
				return mainController.accountChanged(KD.whoami())
			}
		}(this))
	};
	GroupsController.prototype.ignoreInvitation = function (group, callback) {
		return KD.whoami().ignoreInvitation(group, callback)
	};
	GroupsController.prototype.cancelGroupRequest = function (group, callback) {
		return KD.whoami().cancelRequest(group.slug, callback)
	};
	GroupsController.prototype.cancelMembershipPolicyChange = function (policy, membershipPolicyView) {
		return membershipPolicyView.enableInvitations.setValue(policy.invitationsEnabled)
	};
	GroupsController.prototype.updateMembershipPolicy = function (group, policy, formData) {
		return group.modifyMembershipPolicy(formData, function (err) {
			if (!err) {
				policy.emit("MembershipPolicyChangeSaved");
				new KDNotificationView({
					title: "Membership policy has been updated."
				})
			}
			return KD.showError(err)
		})
	};
	return GroupsController
}(KDController);
var MainController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
MainController = function (_super) {
	function MainController(options, data) {
		null == options && (options = {});
		options.failWait = 1e4;
		MainController.__super__.constructor.call(this, options, data);
		this.appStorages = {};
		this.createSingletons();
		this.setFailTimer();
		this.attachListeners();
		this.detectIdleUser();
		KD.isLoggedIn() || this.startCachingAssets()
	}
	var connectedState;
	__extends(MainController, _super);
	Promise.longStackTraces();
	connectedState = {
		connected: !1
	};
	MainController.prototype.createSingletons = function () {
		var appManager, combos, mv, mvc, router;
		KD.registerSingleton("mainController", this);
		KD.registerSingleton("kontrol", new KodingKontrol);
		KD.registerSingleton("appManager", appManager = new ApplicationManager);
		KD.registerSingleton("globalKeyCombos", combos = new KDKeyboardMap({
			priority: 0
		}));
		KD.registerSingleton("notificationController", new NotificationController);
		KD.registerSingleton("linkController", new LinkController);
		KD.registerSingleton("display", new ContentDisplayController);
		KD.registerSingleton("kiteController", new KiteController);
		KD.registerSingleton("router", router = new KodingRouter);
		KD.registerSingleton("localStorageController", new LocalStorageController);
		KD.registerSingleton("oauthController", new OAuthController);
		KD.registerSingleton("groupsController", new GroupsController);
		KD.registerSingleton("activityController", new ActivityController);
		KD.registerSingleton("paymentController", new PaymentController);
		KD.registerSingleton("vmController", new VirtualizationController);
		KD.registerSingleton("locationController", new LocationController);
		KD.registerSingleton("badgeController", new BadgeController);
		KD.registerSingleton("helpController", new HelpController);
		KD.registerSingleton("troubleshoot", new Troubleshoot);
		KD.registerSingleton("appStorageController", new AppStorageController);
		KD.registerSingleton("localSync", new LocalSyncController);
		KD.registerSingleton("dock", new DockController);
		KD.registerSingleton("mainView", mv = new MainView({
			domId: "kdmaincontainer"
		}));
		KD.registerSingleton("mainViewController", mvc = new MainViewController({
			view: mv
		}));
		KD.registerSingleton("kodingAppsController", new KodingAppsController);
		router.listen();
		this.mainViewController = mvc;
		mv.appendToDomBody();
		this.ready(function (_this) {
			return function () {
				KD.registerSingleton("widgetController", new WidgetController);
				KD.registerSingleton("onboardingController", new OnboardingController);
				KD.registerSingleton("socialapi", new SocialApiController);
				_this.emit("AppIsReady");
				return console.timeEnd("Koding.com loaded")
			}
		}(this));
		return this.forwardEvents(KD.remote, ["disconnected", "reconnected"])
	};
	MainController.prototype.accountChanged = function (account, firstLoad) {
		null == firstLoad && (firstLoad = !1);
		account instanceof KD.remote.api.JAccount || (account = KD.remote.revive(account));
		KD.userAccount = account;
		connectedState.connected = !0;
		this.on("pageLoaded.as.loggedIn", function (account) {
			return account ? KD.utils.setPreferredDomain(account) : void 0
		});
		KD.useNewKites && KD.getSingleton("kontrol").reauthenticate();
		return account.fetchMyPermissionsAndRoles(function (_this) {
			return function (err, _arg) {
				var eventPrefix, eventSuffix, permissions, roles;
				permissions = _arg.permissions, roles = _arg.roles;
				if (err) return warn(err);
				KD.config.roles = roles;
				KD.config.permissions = permissions;
				_this.ready(_this.emit.bind(_this, "AccountChanged", account, firstLoad));
				_this.emit("ready");
				eventPrefix = firstLoad ? "pageLoaded.as" : "accountChanged.to";
				eventSuffix = KD.isLoggedIn() ? "loggedIn" : "loggedOut";
				return _this.emit("" + eventPrefix + "." + eventSuffix, account, connectedState, firstLoad)
			}
		}(this))
	};
	MainController.prototype.doLogout = function () {
		var mainView, storage;
		mainView = KD.getSingleton("mainView");
		KD.logout();
		storage = new LocalStorage("Koding");
		return KD.remote.api.JUser.logout(function (_this) {
			return function () {
				var wc;
				mainView._logoutAnimation();
				KD.singletons.localSync.removeLocalContents();
				wc = KD.singleton("windowController");
				wc.clearUnloadListeners();
				return KD.utils.wait(1e3, function () {
					_this.swapAccount({
						replacementAccount: null
					});
					storage.setValue("loggingOut", "1");
					return location.reload()
				})
			}
		}(this))
	};
	MainController.prototype.attachListeners = function () {
		var cookieChangeHandler, wc;
		wc = KD.singleton("windowController");
		this.utils.wait(15e3, function () {
			var _ref;
			return null != (_ref = KD.remote.api) ? _ref.JSystemStatus.on("forceReload", function () {
				window.removeEventListener("beforeunload", wc.bound("beforeUnload"));
				return location.reload()
			}) : void 0
		});
		cookieChangeHandler = function (_this) {
			return function (cookie) {
				return function () {
					var cookieExists, cookieMatches;
					cookieExists = null != cookie;
					cookieMatches = cookie === Cookies.get("clientId");
					cookie = Cookies.get("clientId");
					if (cookieExists && !cookieMatches) {
						if (_this.isLoggingIn() === !0) return _this.isLoggingIn(!1);
						window.removeEventListener("beforeunload", wc.bound("beforeUnload"));
						_this.emit("clientIdChanged");
						_this.utils.defer(function () {
							var entryPoint, lastRoute;
							lastRoute = ("undefined" != typeof localStorage && null !== localStorage ? localStorage.routeToBeContinued : void 0) || KD.getSingleton("router").visitedRoutes.last;
							lastRoute && /^\/(?:Reset|Register|Verify|Confirm)\//.test(lastRoute) && (lastRoute = "/Activity");
							entryPoint = KD.config.entryPoint;
							KD.getSingleton("router").handleRoute(lastRoute || "/Activity", {
								replaceState: !0,
								entryPoint: entryPoint
							});
							return "undefined" != typeof localStorage && null !== localStorage ? localStorage.removeItem("routeToBeContinued") : void 0
						});
						return _this.utils.wait(3e3, cookieChangeHandler)
					}
				}
			}
		}(this)(Cookies.get("clientId"));
		return this.utils.wait(3e3, cookieChangeHandler)
	};
	MainController.prototype.swapAccount = function (options, callback) {
		var account, maxAge, replacementToken, secure, _ref;
		if (!options) return {
			message: "Login failed!"
		};
		account = options.account, replacementToken = options.replacementToken;
		_ref = KD.config.sessionCookie, maxAge = _ref.maxAge, secure = _ref.secure;
		replacementToken && replacementToken !== Cookies.get("clientId") && Cookies.set("clientId", replacementToken, {
			maxAge: maxAge,
			secure: secure
		});
		if (account) {
			this.accountChanged(account);
			if (callback) return this.once("AccountChanged", function () {
				return callback(null, options)
			})
		}
	};
	MainController.prototype.handleLogin = function (credentials, callback) {
		var JUser;
		JUser = KD.remote.api.JUser;
		this.isLoggingIn(!0);
		credentials.username = credentials.username.toLowerCase().trim();
		return JUser.login(credentials, function (_this) {
			return function (err, result) {
				return err ? callback(err) : _this.swapAccount(result, callback)
			}
		}(this))
	};
	MainController.prototype.handleFinishRegistration = function (formData, callback) {
		var JUser;
		JUser = KD.remote.api.JUser;
		this.isLoggingIn(!0);
		return JUser.finishRegistration(formData, function (_this) {
			return function (err, result) {
				return err ? callback(err) : _this.swapAccount(result, callback)
			}
		}(this))
	};
	MainController.prototype.handleOauthAuth = function (formData, callback) {
		var JUser;
		JUser = KD.remote.api.JUser;
		this.isLoggingIn(!0);
		return JUser.authenticateWithOauth(formData, function (_this) {
			return function (err, result) {
				return err ? callback(err) : result.isNewUser ? callback(err, result) : formData.isUserLoggedIn ? callback(err, result) : _this.swapAccount(result, callback)
			}
		}(this))
	};
	MainController.prototype.isLoggingIn = function (isLoggingIn) {
		var storage, _ref;
		storage = new LocalStorage("Koding");
		if ("1" === storage.getValue("loggingOut")) {
			storage.unsetKey("loggingOut");
			return !0
		}
		return null != isLoggingIn ? this._isLoggingIn = isLoggingIn : null != (_ref = this._isLoggingIn) ? _ref : !1
	};
	MainController.prototype.setFailTimer = function () {
		var checkConnectionState, fail, notification;
		notification = null;
		fail = function () {
			return notification = new KDNotificationView({
				title: "Couldn't connect to backend!",
				type: "tray",
				closeManually: !1,
				content: "We don't know why, but your browser couldn't reach our server.\n<br>Still trying but if you want you can click here to refresh the page.",
				duration: 0,
				click: function () {
					return location.reload(!0)
				}
			})
		};
		checkConnectionState = function () {
			if (!connectedState.connected) {
				KD.logToExternalWithTime("Connect to backend");
				return fail()
			}
		};
		return function () {
			this.utils.wait(this.getOptions().failWait, checkConnectionState);
			return this.on("AccountChanged", function () {
				return notification ? notification.destroy() : void 0
			})
		}
	}();
	MainController.prototype.detectIdleUser = function (threshold) {
		var idleDetector;
		null == threshold && (threshold = KD.config.userIdleMs);
		idleDetector = new IdleUserDetector({
			threshold: threshold
		});
		return this.forwardEvents(idleDetector, ["userIdle", "userBack"])
	};
	MainController.prototype.startCachingAssets = function () {
		return KD.utils.defer(function () {
			var image, images, src, _i, _len, _results;
			images = ["/a/images/city.jpg", "/a/images/home-pat.png", "/a/images/edu-pat.png", "/a/images/biz-pat.png", "/a/images/pricing-pat.png", "/a/images/ss-activity.jpg", "/a/images/ss-terminal.jpg", "/a/images/ss-teamwork.jpg", "/a/images/ss-environments.jpg", "/a/images/unsplash/" + LoginView.backgroundImageNr + ".jpg"];
			_results = [];
			for (_i = 0, _len = images.length; _len > _i; _i++) {
				src = images[_i];
				image = new Image;
				_results.push(image.src = src)
			}
			return _results
		})
	};
	return MainController
}(KDController);
var HelpController, HelpModal, HelpPage, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
HelpController = function (_super) {
	function HelpController() {
		return HelpController.__super__.constructor.apply(this, arguments)
	}
	var name, version;
	__extends(HelpController, _super);
	name = "HelpController";
	version = "0.1";
	KD.registerAppClass(HelpController, {
		name: name,
		version: version,
		background: !0
	});
	HelpController.prototype.showHelp = function (delegate) {
		var storage, _ref;
		KD.mixpanel("Help modal show, success");
		null != (_ref = this._modal) && "function" == typeof _ref.destroy && _ref.destroy();
		this._modal = new HelpModal({
			delegate: delegate
		});
		storage = KD.singletons.localStorageController.storage("HelpController");
		return storage.setValue("shown", !0)
	};
	return HelpController
}(KDController);
HelpPage = function (_super) {
	function HelpPage(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("help-page", options.cssClass);
		HelpPage.__super__.constructor.call(this, options, data)
	}
	__extends(HelpPage, _super);
	JView.mixin(HelpPage.prototype);
	HelpPage.prototype.addLinks = function (links) {
		return links.forEach(function (_this) {
			return function (link) {
				var options, target;
				target = link.command ? "" : " target='_blank'";
				options = {
					tagName: "li",
					partial: "<a href='" + link.url + "'" + target + ">" + link.title + "</a>"
				};
				options.click = link.command ? function (event) {
					KD.utils.stopDOMEvent(event);
					KD.mixpanel("Help modal link, click", {
						title: link.title
					});
					return KD.singletons.appManager.require("Terminal", function () {
						_this.getDelegate().emit("InternalLinkClicked", link);
						return KD.utils.wait(500, function () {
							KD.singletons.router.handleRoute(link.url);
							return KD.singletons.appManager.tell("Terminal", "runCommand", link.command)
						})
					})
				} : function () {
					return KD.mixpanel("Help modal link, click", {
						title: link.title
					})
				};
				return _this.addSubView(new KDCustomHTMLView(options), "ul")
			}
		}(this))
	};
	HelpPage.prototype.pistachio = function () {
		return "{h3{#(title)}}\n<ul></ul>"
	};
	return HelpPage
}(KDSlidePageView);
HelpModal = function (_super) {
	function HelpModal(options, data) {
		var advanced, buttonContainer, experienced, noob, slider;
		options.cssClass = "kdhelp-modal";
		options.overlay = !0;
		options.overlayClick = !0;
		HelpModal.__super__.constructor.call(this, options, data);
		this.slider = new KDSlideShowView({
			cssClass: "help-content",
			direction: "leftToRight",
			touchEnabled: !1
		});
		this.addSubView(new KDCustomHTMLView({
			partial: "<h2>Welcome on board!</h2>\n<p>Let us try to help you find your way in Koding. Are you:</p>"
		}));
		this.addSubView(buttonContainer = new KDCustomHTMLView({
			cssClass: "button-container"
		}));
		buttonContainer.on("deselectAll", function () {
			return this.$("a").removeClass("active")
		});
		this.on("InternalLinkClicked", function (_this) {
			return function () {
				return KD.utils.defer(function () {
					return _this.destroy()
				})
			}
		}(this));
		slider = this.slider;
		buttonContainer.addSubView(new KDCustomHTMLView({
			tagName: "a",
			cssClass: "active",
			attributes: {
				href: "#"
			},
			partial: "new to<br/>programming",
			click: function (event) {
				KD.mixpanel("Help modal subsection, click", {
					title: "new"
				});
				KD.utils.stopDOMEvent(event);
				buttonContainer.emit("deselectAll");
				this.setClass("active");
				return slider.jump(0)
			}
		}));
		buttonContainer.addSubView(new KDCustomHTMLView({
			tagName: "a",
			attributes: {
				href: "#"
			},
			partial: "an experienced<br/>developer",
			click: function (event) {
				KD.mixpanel("Help modal subsection, click", {
					title: "experienced"
				});
				KD.utils.stopDOMEvent(event);
				buttonContainer.emit("deselectAll");
				this.setClass("active");
				return slider.jump(1)
			}
		}));
		buttonContainer.addSubView(new KDCustomHTMLView({
			tagName: "a",
			attributes: {
				href: "#"
			},
			partial: "an advanced<br/>programmer",
			click: function (event) {
				KD.mixpanel("Help modal subsection, click", {
					title: "advanced"
				});
				KD.utils.stopDOMEvent(event);
				buttonContainer.emit("deselectAll");
				this.setClass("active");
				return slider.jump(2)
			}
		}));
		this.addSubView(this.slider);
		this.slider.addPage(noob = new HelpPage({
			delegate: this
		}, {
			title: "New to programming? No worries we got you covered!"
		}));
		noob.addLinks(links.noob);
		noob.addLinks(links.commons);
		this.slider.addPage(experienced = new HelpPage({
			delegate: this
		}, {
			title: "You may find these topics below helpful:"
		}));
		experienced.addLinks(links.experienced);
		experienced.addLinks(links.commons);
		this.slider.addPage(advanced = new HelpPage({
			delegate: this
		}, {
			title: "Welcome to <code>$ sudo su</code> world in the cloud"
		}));
		advanced.addLinks(links.advanced);
		advanced.addLinks(links.commons);
		this.addSubView(new KDCustomHTMLView({
			tagName: "footer",
			partial: "<h4>Find more at <a href='http://learn.koding.com'>Koding University</a>, also we would love to hear your <a href='https://docs.google.com/forms/d/1jxdnXLm-cgHDpokzKIJSaShEirb66huoEMhPkQF5f_I/viewform'target='_blank'>feedback</a>.</h4>"
		}))
	}
	var links;
	__extends(HelpModal, _super);
	links = {
		noob: [{
			title: "What is Koding?",
			url: "http://learn.koding.com/what-is-koding/"
		}, {
			title: "Getting Started",
			url: "http://learn.koding.com/gettingstarted/"
		}, {
			title: "Development on Koding",
			url: "http://learn.koding.com/development-on-koding/"
		}, {
			title: "<i>Tutorial:</i> EmberJS",
			url: "http://learn.koding.com/emberjs-starting-kit/"
		}, {
			title: "<i>Tutorial:</i> Octopress",
			url: "http://learn.koding.com/octopress-installation-beginners/"
		}, {
			title: "<i>Tutorial:</i> Ghost Blog",
			url: "http://learn.koding.com/developing-ghost-blog-koding/"
		}, {
			title: "<i>Tutorial:</i> Bootstrap 3",
			url: "http://learn.koding.com/bootstrap-3-quick-tip/"
		}, {
			title: "Terminal",
			url: "/Terminal",
			command: "help this"
		}],
		experienced: [{
			title: "Koding subdomains and Vhosts",
			url: "http://learn.koding.com/koding-subdomains-and-vhosts/"
		}, {
			title: "How to setup Octopress",
			url: "http://learn.koding.com/63/"
		}, {
			title: "Codeigniter Installation",
			url: "http://learn.koding.com/codeigniter-beginners/"
		}, {
			title: "Firebase setup and usage",
			url: "http://learn.koding.com/getting-started-firebase/"
		}, {
			title: "Getting started with Facebook Application Development",
			url: "http://learn.koding.com/getting-started-with-facebook-application-development/"
		}, {
			title: "sudo password",
			url: "/Terminal",
			command: "help sudo"
		}],
		advanced: [{
			title: "Terminal and custom ports",
			url: "http://learn.koding.com/terminal-and-custom-ports/"
		}, {
			title: "Using Tmux on Koding",
			url: "http://learn.koding.com/using-tmux-on-koding/"
		}, {
			title: "sudo password",
			url: "/Terminal",
			command: "help sudo"
		}],
		commons: [{
			title: "FAQ",
			url: "http://learn.koding.com/faq/"
		}, {
			title: "FTP",
			url: "/Terminal",
			command: "help ftp"
		}, {
			title: "MySQL",
			url: "/Terminal",
			command: "help mysql"
		}, {
			title: "phpMyAdmin",
			url: "/Terminal",
			command: "help phpmyadmin"
		}, {
			title: "MongoDB",
			url: "/Terminal",
			command: "help mongodb"
		}, {
			title: "VM Specs",
			url: "/Terminal",
			command: "help specs"
		}, {
			title: "Preinstalled packages",
			url: "/Terminal",
			command: "help programs"
		}]
	};
	return HelpModal
}(AnimatedModalView);
var KiteChannel;
KiteChannel = function () {
	function KiteChannel(kiteName) {
		return KD.remote.mq.subscribe(this.getName(kiteName))
	}
	KiteChannel.prototype.getName = function (kiteName) {
		var nickname, _ref, _ref1, _ref2;
		nickname = null != (_ref = null != (_ref1 = KD.whoami()) && null != (_ref2 = _ref1.profile) ? _ref2.nickname : void 0) ? _ref : "unknown";
		return "" + Bongo.createId(128) + "." + nickname + ".kite-" + kiteName
	};
	return KiteChannel
}();
window.KiteChannel = KiteChannel;
var ApplicationManager, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	},
	__slice = [].slice;
ApplicationManager = function (_super) {
	function ApplicationManager() {
		var wc;
		ApplicationManager.__super__.constructor.apply(this, arguments);
		this.appControllers = {};
		this.frontApp = null;
		this.defaultApps = {
			text: "Ace",
			video: "Viewer",
			image: "Viewer",
			sound: "Viewer"
		};
		this.on("AppIsBeingShown", this.bound("setFrontApp"));
		wc = KD.singleton("windowController");
		wc.addUnloadListener("window", function (_this) {
			return function () {
				var app, safeToUnload, _ref;
				_ref = _this.appControllers;
				for (app in _ref)
					if (__hasProp.call(_ref, app) && ("Ace" === app || "Terminal" === app || "Teamwork" === app)) {
						safeToUnload = !1;
						break
					}
				return null != safeToUnload ? safeToUnload : !0
			}
		}(this))
	}
	var notification;
	__extends(ApplicationManager, _super);
	ApplicationManager.prototype.isAppInternal = function (name) {
		null == name && (name = "");
		return KD.config.apps[name] && __indexOf.call(Object.keys(KD.appClasses), name) < 0
	};
	ApplicationManager.prototype.open = function () {
		var createOrShow;
		createOrShow = function (appOptions, appParams, callback) {
			var appInstance, cb, name;
			null == appOptions && (appOptions = {});
			null == callback && (callback = noop);
			name = null != appOptions ? appOptions.name : void 0;
			if (!name) return this.handleAppNotFound();
			appInstance = this.get(name);
			cb = appParams.background || appOptions.background ? function (appInst) {
				return KD.utils.defer(function () {
					return callback(appInst)
				})
			} : this.show.bind(this, name, appParams, callback);
			return appInstance ? cb(appInstance) : this.create(name, appParams, cb)
		};
		return function (name, options, callback) {
			var appOptions, appParams, defaultCallback, _ref;
			if (!name) return warn("ApplicationManager::open called without an app name!");
			"function" == typeof options && (_ref = [options, callback], callback = _ref[0], options = _ref[1]);
			options || (options = {});
			appOptions = KD.getAppOptions(name);
			appParams = options.params || {};
			defaultCallback = createOrShow.bind(this, appOptions, appParams, callback);
			if (null == (null != appOptions ? appOptions.preCondition : void 0) || options.conditionPassed) {
				if (null == appOptions && null == options.avoidRecursion) {
					if (this.isAppInternal(name)) return KodingAppsController.loadInternalApp(name, function (_this) {
						return function (err) {
							return err ? warn(err) : KD.utils.defer(function () {
								return _this.open(name, options, callback)
							})
						}
					}(this));
					options.avoidRecursion = !0;
					return defaultCallback()
				}
				appParams = options.params || {};
				if (null != appOptions ? !appOptions.multiple : !0) return defaultCallback();
				if (options.forceNew || "forceNew" === appOptions.openWith) return this.create(name, appParams, function (_this) {
					return function (appInstance) {
						return _this.showInstance(appInstance, callback)
					}
				}(this));
				switch (appOptions.openWith) {
				case "lastActive":
					return defaultCallback();
				case "prompt":
					return defaultCallback()
				}
			} else appOptions.preCondition.condition(appParams, function (_this) {
				return function (state, newParams) {
					var params, _base;
					if (state) {
						options.conditionPassed = !0;
						newParams && (options.params = newParams);
						return _this.open(name, options, callback)
					}
					params = newParams || appParams;
					return "function" == typeof (_base = appOptions.preCondition).failure ? _base.failure(params, callback) : void 0
				}
			}(this))
		}
	}();
	ApplicationManager.prototype.openFileWithApplication = function (appName, file) {
		return this.open(appName, function (_this) {
			return function () {
				return _this.utils.defer(function () {
					return _this.getFrontApp().openFile(file)
				})
			}
		}(this))
	};
	ApplicationManager.prototype.promptOpenFileWith = function (file) {
		var finderController, treeController, view;
		finderController = KD.getSingleton("finderController");
		treeController = finderController.treeController;
		view = new KDView({}, file);
		return treeController.showOpenWithModal(view)
	};
	ApplicationManager.prototype.openFile = function (file) {
		var defaultApp, extension, type;
		extension = file.getExtension();
		type = FSItem.getFileType(extension);
		defaultApp = this.defaultApps[extension];
		if (defaultApp) return this.openFileWithApplication(defaultApp, file);
		switch (type) {
		case "unknown":
			return this.promptOpenFileWith(file);
		case "code":
		case "text":
			log("open with a text editor");
			return this.open(this.defaultApps.text, function (appController) {
				return appController.openFile(file)
			});
		case "image":
			return log("open with an image processing app");
		case "video":
			return log("open with a video app");
		case "sound":
			return log("open with a sound app");
		case "archive":
			return log("extract the thing.")
		}
	};
	ApplicationManager.prototype.tell = function () {
		var app, cb, command, name, rest;
		name = arguments[0], command = arguments[1], rest = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
		if (!name) return warn("ApplicationManager::tell called without an app name!");
		app = this.get(name);
		cb = function (appInstance) {
			return null != appInstance && "function" == typeof appInstance[command] ? appInstance[command].apply(appInstance, rest) : void 0
		};
		return app ? this.utils.defer(function () {
			return cb(app)
		}) : this.create(name, cb)
	};
	ApplicationManager.prototype.require = function (name, params, callback) {
		var app, _ref;
		log("AppManager: requiring an app", name);
		callback || (_ref = [params, callback], callback = _ref[0], params = _ref[1]);
		return (app = this.get(name)) ? callback(app) : this.create(name, params, callback)
	};
	ApplicationManager.prototype.create = function (name, params, callback) {
		var AppClass, appInstance, appOptions, _ref;
		callback || (_ref = [params, callback], callback = _ref[0], params = _ref[1]);
		AppClass = KD.getAppClass(name);
		appOptions = $.extend({}, !0, KD.getAppOptions(name));
		appOptions.params = params;
		AppClass && this.register(appInstance = new AppClass(appOptions));
		return this.isAppInternal(name) ? KodingAppsController.loadInternalApp(name, function (_this) {
			return function (err) {
				return err ? warn(err) : KD.utils.defer(function () {
					return _this.create(name, params, callback)
				})
			}
		}(this)) : this.utils.defer(function (_this) {
			return function () {
				if (!appInstance) return _this.emit("AppCouldntBeCreated");
				_this.emit("AppCreated", appInstance);
				return appOptions.thirdParty ? KD.getSingleton("kodingAppsController").putAppResources(appInstance, callback) : "function" == typeof callback ? callback(appInstance) : void 0
			}
		}(this))
	};
	ApplicationManager.prototype.show = function (name, appParams, callback) {
		var appInstance, appOptions, appView;
		appOptions = KD.getAppOptions(name);
		appInstance = this.get(name);
		appView = "function" == typeof appInstance.getView ? appInstance.getView() : void 0;
		if (appView) {
			this.emit("AppIsBeingShown", appInstance, appView, appOptions);
			"function" == typeof appInstance.appIsShown && appInstance.appIsShown(appParams);
			this.setLastActiveIndex(appInstance);
			return this.utils.defer(function () {
				return "function" == typeof callback ? callback(appInstance) : void 0
			})
		}
	};
	ApplicationManager.prototype.showInstance = function (appInstance, callback) {
		var appOptions, appView;
		appView = ("function" == typeof appInstance.getView ? appInstance.getView() : void 0) || null;
		appOptions = KD.getAppOptions(appInstance.getOption("name"));
		if (!appOptions.background) {
			this.emit("AppIsBeingShown", appInstance, appView, appOptions);
			"function" == typeof appInstance.appIsShown && appInstance.appIsShown();
			this.setLastActiveIndex(appInstance);
			return this.utils.defer(function () {
				return "function" == typeof callback ? callback(appInstance) : void 0
			})
		}
	};
	ApplicationManager.prototype.quit = function (appInstance, callback) {
		var destroyer, view;
		null == callback && (callback = noop);
		view = "function" == typeof appInstance.getView ? appInstance.getView() : void 0;
		destroyer = null != view ? view : appInstance;
		destroyer.destroy();
		return callback()
	};
	ApplicationManager.prototype.quitAll = function () {
		var app, apps, name, _ref, _results;
		_ref = this.appControllers;
		_results = [];
		for (name in _ref)
			if (__hasProp.call(_ref, name)) {
				apps = _ref[name];
				_results.push(function () {
					var _i, _len, _ref1, _results1;
					_ref1 = apps.instances;
					_results1 = [];
					for (_i = 0, _len = _ref1.length; _len > _i; _i++) {
						app = _ref1[_i];
						_results1.push(this.quit(app))
					}
					return _results1
				}.call(this))
			}
		return _results
	};
	ApplicationManager.prototype.quitByName = function (name, closeAllInstances) {
		var appController, instances, _results;
		null == closeAllInstances && (closeAllInstances = !0);
		appController = this.appControllers[name];
		if (appController) {
			if (closeAllInstances) {
				instances = appController.instances;
				_results = [];
				for (; instances.length > 0;) _results.push(this.quit(instances.first));
				return _results
			}
			return this.quit(appController.instances[appController.lastActiveIndex])
		}
	};
	ApplicationManager.prototype.get = function (name) {
		var apps;
		return (apps = this.appControllers[name]) ? apps.instances[apps.lastActiveIndex] || apps.instances.first : null
	};
	ApplicationManager.prototype.getByView = function (view) {
		var appController, appInstance, apps, name, _i, _len, _ref, _ref1, _ref2;
		appInstance = null;
		_ref = this.appControllers;
		for (name in _ref)
			if (__hasProp.call(_ref, name)) {
				apps = _ref[name];
				_ref1 = apps.instances;
				for (_i = 0, _len = _ref1.length; _len > _i; _i++) {
					appController = _ref1[_i];
					if (view.getId() === ("function" == typeof appController.getView && null != (_ref2 = appController.getView()) ? _ref2.getId() : void 0)) {
						appInstance = appController;
						break
					}
				}
				if (appInstance) break
			}
		return appInstance
	};
	ApplicationManager.prototype.getFrontApp = function () {
		return this.frontApp
	};
	ApplicationManager.prototype.setFrontApp = function (appInstance) {
		var name, router;
		router = KD.singletons.router;
		name = appInstance.getOptions().name;
		name && router.setPageTitle(name);
		this.setLastActiveIndex(appInstance);
		return this.frontApp = appInstance
	};
	ApplicationManager.prototype.getFrontAppManifest = function () {
		var name;
		name = this.getFrontApp().getOptions().name;
		return KD.getAppOptions(name)
	};
	ApplicationManager.prototype.register = function (appInstance) {
		var name, _base;
		name = appInstance.getOption("name");
		null == (_base = this.appControllers)[name] && (_base[name] = {
			instances: [],
			lastActiveIndex: null
		});
		this.appControllers[name].instances.push(appInstance);
		this.setListeners(appInstance);
		return this.emit("AppRegistered", name, appInstance.options)
	};
	ApplicationManager.prototype.unregister = function (appInstance) {
		var index, name;
		name = appInstance.getOption("name");
		index = this.appControllers[name].instances.indexOf(appInstance);
		if (index >= 0) {
			this.appControllers[name].instances.splice(index, 1);
			this.emit("AppUnregistered", name, appInstance.options);
			if (0 === this.appControllers[name].instances.length) return delete this.appControllers[name]
		}
	};
	ApplicationManager.prototype.createPromptModal = function (appOptions, callback) {
		var i, instance, modal, name, selectOptions;
		name = appOptions.name;
		selectOptions = function () {
			var _i, _len, _ref, _results;
			_ref = this.appControllers[name].instances;
			_results = [];
			for (i = _i = 0, _len = _ref.length; _len > _i; i = ++_i) {
				instance = _ref[i];
				_results.push({
					title: "" + instance.getOption("name") + " (" + (i + 1) + ")",
					value: i
				})
			}
			return _results
		}.call(this);
		return modal = new KDModalViewWithForms({
			title: "Open with:",
			tabs: {
				navigable: !1,
				forms: {
					openWith: {
						callback: function (formOutput) {
							var index, openNew;
							modal.destroy();
							index = formOutput.index, openNew = formOutput.openNew;
							return callback(index, openNew)
						},
						fields: {
							instance: {
								label: "Instance:",
								itemClass: KDSelectBox,
								name: "index",
								type: "select",
								defaultValue: selectOptions.first.value,
								selectOptions: selectOptions
							},
							newOne: {
								label: "Open new app:",
								itemClass: KDOnOffSwitch,
								name: "openNew",
								defaultValue: !1
							}
						},
						buttons: {
							Open: {
								cssClass: "modal-clean-green",
								type: "submit"
							},
							Cancel: {
								cssClass: "modal-cancel",
								callback: function () {
									modal.cancel();
									return callback(null)
								}
							}
						}
					}
				}
			}
		})
	};
	ApplicationManager.prototype.setListeners = function (appInstance) {
		var destroyer, view;
		destroyer = (view = "function" == typeof appInstance.getView ? appInstance.getView() : void 0) ? view : appInstance;
		return destroyer.once("KDObjectWillBeDestroyed", function (_this) {
			return function () {
				_this.unregister(appInstance);
				appInstance.emit("AppDidQuit");
				return KD.getSingleton("appManager").emit("AppDidQuit", appInstance)
			}
		}(this))
	};
	ApplicationManager.prototype.setLastActiveIndex = function (appInstance) {
		var index, optionSet;
		if (appInstance && (optionSet = this.appControllers[appInstance.getOption("name")])) {
			index = optionSet.instances.indexOf(appInstance);
			return optionSet.lastActiveIndex = -1 === index ? null : index
		}
	};
	notification = null;
	ApplicationManager.prototype.notify = function (msg) {
		notification && notification.destroy();
		return notification = new KDNotificationView({
			title: msg || "Currently disabled!",
			type: "mini",
			duration: 2500
		})
	};
	ApplicationManager.prototype.handleAppNotFound = function () {
		return new KDNotificationView({
			title: "You don't have this app installed!",
			type: "mini",
			cssClass: "error",
			duration: 5e3
		})
	};
	return ApplicationManager
}(KDObject);
var AppController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AppController = function (_super) {
	function AppController() {
		var mainController, name, version, _ref;
		AppController.__super__.constructor.apply(this, arguments);
		_ref = this.getOptions(), name = _ref.name, version = _ref.version;
		mainController = KD.singletons.mainController;
		mainController.ready(function (_this) {
			return function () {
				return KD.utils.defer(function () {
					var appStorageController;
					appStorageController = KD.singletons.appStorageController;
					return _this.appStorage = appStorageController.storage(name, version || "1.0.1")
				})
			}
		}(this));
		this.bindKeyCombos()
	}
	__extends(AppController, _super);
	AppController.prototype.bindKeyCombos = function () {
		var globalKeyCombos;
		globalKeyCombos = KD.singletons.globalKeyCombos;
		this.appKeyListener = new KDKeyboardListener;
		this.appKeyMap = new KDKeyboardMap({
			priority: 10
		});
		this.appKeyListener.addComboMap(globalKeyCombos).addComboMap(this.appKeyMap);
		this.registerDeclaredBindings();
		return KD.singletons.appManager.on("AppIsBeingShown", function (_this) {
			return function (app) {
				var _ref;
				return app === _this && null != (_ref = _this.appKeyListener) ? _ref.listen() : void 0
			}
		}(this))
	};
	AppController.prototype.registerAppKeys = function (bindings) {
		var binding, fn;
		null == bindings && (bindings = {});
		for (binding in bindings)
			if (__hasProp.call(bindings, binding)) {
				fn = bindings[binding];
				this.appKeyMap.addCombo(binding, fn)
			}
		this.appKeyListener.addComboMap(this.appKeyMap);
		return this.appKeyMap
	};
	AppController.prototype.createContentDisplay = function () {
		return warn("You need to override #createContentDisplay - " + this.constructor.name)
	};
	AppController.prototype.handleQuery = function (query) {
		return this.ready(function (_this) {
			return function () {
				var _ref;
				return null != (_ref = _this.feedController) && "function" == typeof _ref.handleQuery ? _ref.handleQuery(query) : void 0
			}
		}(this))
	};
	AppController.prototype.handleCommand = function (command, appName, event) {
		var cmd, commands, _ref;
		commands = KD.getAppOptions(this.getOptions().name).commands;
		cmd = commands[command];
		if ("function" == typeof cmd) return cmd.call(this, event);
		if ("string" == typeof cmd) return null != (_ref = this[cmd]) ? _ref.call(this, event) : void 0;
		throw new Error("Unknown command: " + command)
	};
	AppController.prototype.registerDeclaredBindings = function () {
		var appName, keyBindings;
		appName = this.getOptions().name;
		keyBindings = KD.getAppOptions(appName).keyBindings;
		return null != keyBindings ? keyBindings.forEach(function (_this) {
			return function (b) {
				return _this.appKeyMap.addCombo(b.binding, {
					global: b.global
				}, function (ev) {
					return _this.handleCommand(b.command, appName, ev)
				})
			}
		}(this)) : void 0
	};
	return AppController
}(KDViewController);
var AppStorage, AppStorageController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
AppStorage = function (_super) {
	function AppStorage(appId, version) {
		this._applicationID = appId;
		this._applicationVersion = version;
		this.reset();
		AppStorage.__super__.constructor.apply(this, arguments)
	}
	__extends(AppStorage, _super);
	AppStorage.prototype.fetchStorage = function (callback, force) {
		var appId, mainController, version, _ref;
		null == force && (force = !1);
		_ref = [this._applicationID, this._applicationVersion], appId = _ref[0], version = _ref[1];
		if (!this._storage || force) {
			mainController = KD.singletons.mainController;
			return mainController.ready(function (_this) {
				return function () {
					return KD.whoami().fetchAppStorage({
						appId: appId,
						version: version
					}, function (error, storage) {
						if (!error && storage) {
							_this._storage = storage;
							"function" == typeof callback && callback(_this._storage);
							_this.emit("storageFetched");
							return _this.emit("ready")
						}
						return "function" == typeof callback ? callback(null) : void 0
					})
				}
			}(this))
		}
		return KD.utils.defer(function (_this) {
			return function () {
				"function" == typeof callback && callback(_this._storage);
				_this.emit("storageFetched");
				return _this.emit("ready")
			}
		}(this))
	};
	AppStorage.prototype.fetchValue = function (key, callback, group, force) {
		null == group && (group = "bucket");
		null == force && (force = !1);
		this.reset();
		return this.fetchStorage(function (storage) {
			var _ref;
			return callback((null != storage && null != (_ref = storage[group]) ? _ref[key] : void 0) ? storage[group][key] : void 0)
		}, force)
	};
	AppStorage.prototype.getValue = function (key, group) {
		var _ref, _ref1;
		null == group && (group = "bucket");
		return this._storage ? null != (null != (_ref = this._storageData[group]) ? _ref[key] : void 0) ? this._storageData[group][key] : null != (null != (_ref1 = this._storage[group]) ? _ref1[key] : void 0) ? this._storage[group][key] : void 0 : void 0
	};
	AppStorage.prototype.setValue = function (key, value, callback, group) {
		var pack;
		null == group && (group = "bucket");
		pack = this.zip(key, group, value);
		null == this._storageData[group] && (this._storageData[group] = {});
		this._storageData[group][key] = value;
		return this.fetchStorage(function (storage) {
			return null != storage ? storage.update({
				$set: pack
			}, function () {
				return "function" == typeof callback ? callback() : void 0
			}) : void 0
		})
	};
	AppStorage.prototype.unsetKey = function (key, callback, group) {
		var pack;
		null == group && (group = "bucket");
		pack = this.zip(key, group, 1);
		return this.fetchStorage(function (_this) {
			return function (storage) {
				var _ref;
				null != (_ref = _this._storageData[group]) && delete _ref[key];
				return storage.update({
					$unset: pack
				}, callback)
			}
		}(this))
	};
	AppStorage.prototype.reset = function () {
		this._storage = null;
		return this._storageData = {}
	};
	AppStorage.prototype.zip = function (key, group, value) {
		var pack, _key;
		pack = {};
		_key = group + "." + key;
		pack[_key] = value;
		return pack
	};
	return AppStorage
}(KDObject);
AppStorageController = function (_super) {
	function AppStorageController() {
		AppStorageController.__super__.constructor.apply(this, arguments);
		this.appStorages = {}
	}
	__extends(AppStorageController, _super);
	AppStorageController.prototype.storage = function (appName, version) {
		var key, storage, _base;
		null == version && (version = "1.0");
		key = "" + appName + "-" + version;
		(_base = this.appStorages)[key] || (_base[key] = new AppStorage(appName, version));
		storage = this.appStorages[key];
		storage.fetchStorage();
		return storage
	};
	return AppStorageController
}(KDController);
KD.classes.AppStorage = AppStorage;
var LocalStorage, LocalStorageController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LocalStorage = function (_super) {
	function LocalStorage() {
		return LocalStorage.__super__.constructor.apply(this, arguments)
	}
	var e, storage;
	__extends(LocalStorage, _super);
	try {
		storage = window.localStorage
	} catch (_error) {
		e = _error;
		warn("" + e.name + " occured while getting localStorage:", e.message);
		storage = {}
	}
	LocalStorage.prototype.fetchStorage = function () {
		return KD.utils.defer(function (_this) {
			return function () {
				return _this.emit("ready")
			}
		}(this))
	};
	LocalStorage.prototype.getValue = function (key) {
		var data;
		data = this._storageData[key];
		if (data) return data;
		data = storage[this.getSignature(key)];
		if (data) try {
			data = JSON.parse(data)
		} catch (_error) {
			e = _error;
			warn("parse failed", e)
		}
		return data
	};
	LocalStorage.prototype.getAt = function (path) {
		var data, keys;
		if (!path) return null;
		keys = path.split(".");
		data = this.getValue(keys.shift());
		return data ? 0 === keys.length ? data : JsPath.getAt(data, keys.join(".")) : null
	};
	LocalStorage.prototype.setAt = function (path, value, callback) {
		var key, keys;
		if (!path || !value) return null;
		keys = path.split(".");
		key = keys.shift();
		return 0 === keys.length ? this.setValue(key, value, callback) : this.setValue(key, JsPath.setAt({}, keys.join("."), value), callback)
	};
	LocalStorage.prototype.fetchValue = function (key, callback) {
		return "function" == typeof callback ? callback(this.getValue(key)) : void 0
	};
	LocalStorage.prototype.setValue = function (key, value, callback) {
		this._storageData[key] = value || "";
		storage[this.getSignature(key)] = JSON.stringify(value) || "";
		return KD.utils.defer(function () {
			return function () {
				return "function" == typeof callback ? callback(null) : void 0
			}
		}(this))
	};
	LocalStorage.prototype.unsetKey = function (key) {
		delete storage[this.getSignature(key)];
		return delete this._storageData[key]
	};
	LocalStorage.prototype.getSignature = function (key) {
		return "koding-" + this._applicationID + "-" + this._applicationVersion + "-" + key
	};
	LocalStorage.prototype.getLocalStorageKeys = function () {
		return Object.keys(storage)
	};
	return LocalStorage
}(AppStorage);
LocalStorageController = function (_super) {
	function LocalStorageController() {
		LocalStorageController.__super__.constructor.apply(this, arguments);
		this.localStorages = {}
	}
	__extends(LocalStorageController, _super);
	LocalStorageController.prototype.storage = function (appName, version) {
		var key, _base;
		null == version && (version = KD.getAppVersion(appName) || "1.0");
		key = "" + appName + "-" + version;
		return (_base = this.localStorages)[key] || (_base[key] = new LocalStorage(appName, version))
	};
	return LocalStorageController
}(KDController);
KD.classes.LocalStorage = LocalStorage;
var GitHub;
GitHub = function () {
	function GitHub() {}
	var GITHUB_API_URL;
	GITHUB_API_URL = "https://api.github.com";
	GitHub._repoCache = {};
	GitHub.fetch = function (url, params, callback) {
		var req, _ref;
		callback || (_ref = [callback, params], params = _ref[0], callback = _ref[1]);
		null == callback && (callback = noop);
		req = {
			url: "" + GITHUB_API_URL + url,
			dataType: "jsonp",
			success: callback
		};
		params && (req.data = params);
		$.ajax(req);
		return null
	};
	GitHub.fetchUserRepos = function (username, callback, force) {
		var fetch, page, repos, _ref;
		null == callback && (callback = noop);
		force && this.resetCache(username);
		if (!((null != (_ref = this._repoCache[username]) ? _ref.length : void 0) > 0)) {
			repos = [];
			page = 0;
			return (fetch = function (_this) {
				return function () {
					page++;
					return _this.fetch("/users/" + username + "/repos", {
						sort: "updated",
						per_page: 30,
						page: page
					}, function (response, state) {
						var data, link, meta, _ref1, _ref2;
						meta = response.meta, data = response.data;
						if ("success" !== state || 200 !== meta.status) return _this.errorWrapper(callback, {
							message: "Failed to fetch repos for " + username,
							state: state,
							meta: meta
						}, repos);
						repos = repos.concat(data);
						link = null != meta && null != (_ref1 = meta.Link) ? _ref1[0] : void 0;
						if ("next" === (null != link && null != (_ref2 = link[1]) ? _ref2.rel : void 0)) return fetch();
						_this._repoCache[username] = repos;
						return callback(null, repos)
					})
				}
			}(this))()
		}
		callback(null, this._repoCache[username])
	};
	GitHub.fetchMyRepos = function (callback, force) {
		var me;
		null == callback && (callback = noop);
		null == force && (force = !1);
		me = KD.whoami();
		return me.fetchOAuthInfo(function (_this) {
			return function (err, oauth) {
				var username;
				if (null != err) return callback(err);
				if (null == (null != oauth ? oauth.github : void 0)) return callback({
					message: "There is no linked GitHub account with this account."
				});
				username = oauth.github.username;
				return _this.fetchUserRepos(username, callback, force)
			}
		}(this))
	};
	GitHub.resetCache = function (username) {
		username ? delete this._repoCache[username] : delete this._repoCache;
		return null
	};
	GitHub.link = function (callback) {
		var me;
		null == callback && (callback = noop);
		me = KD.whoami();
		return me.fetchOAuthInfo(function (err, oauth) {
			var handler, mainController, oauthController, _ref;
			if (null != err) return callback(err);
			if (null != (null != oauth ? oauth.github : void 0)) return callback({
				message: "Already linked with " + oauth.github.username
			});
			_ref = KD.singletons, mainController = _ref.mainController, oauthController = _ref.oauthController;
			oauthController.openPopup("github");
			handler = function () {
				return callback(null)
			};
			mainController.off("ForeignAuthSuccess.github", handler);
			return mainController.once("ForeignAuthSuccess.github", handler)
		})
	};
	GitHub.rateLimit = function (callback) {
		null == callback && (callback = noop);
		return this.fetch("/rate_limit", function (_this) {
			return function (response, state) {
				var data, meta, status;
				meta = response.meta, data = response.data;
				status = meta.status;
				return null != data.rate ? callback(null, data.rate) : _this.errorWrapper(callback, {
					message: "Failed to fetch rate limit",
					state: state,
					meta: meta
				})
			}
		}(this))
	};
	GitHub.username = function (callback) {
		var me;
		me = KD.whoami();
		return me.fetchOAuthInfo(function (err, oauth) {
			return callback(null != err ? "" : null != (null != oauth ? oauth.github : void 0) ? oauth.github.username : "")
		})
	};
	GitHub.makeLink = function (path, text) {
		return "<a href='https://github.com/" + path + "' target='_github_" + path + "'>\n  " + (text ? text : "github.com/" + path) + "\n</a>"
	};
	GitHub.getLatestCommit = function (repo, callback) {
		return this.username(function (_this) {
			return function (username) {
				return username ? _this.fetch("/repos/" + username + "/" + repo + "/commits?per_page=1", function (response, state) {
					var data, meta;
					meta = response.meta, data = response.data;
					if (200 === meta.status) {
						data || (data = []);
						return callback(null, data.first)
					}
					return _this.errorWrapper(callback, {
						message: "Failed to fetch latest commit",
						state: state,
						meta: meta
					})
				}) : callback({
					message: "There is no linked GitHub account with this account."
				})
			}
		}(this))
	};
	GitHub.errorWrapper = function (callback, options) {
		var remaining;
		if ("0" === options.meta["X-RateLimit-Remaining"]) {
			remaining = new Date(new Date(1e3 * options.meta["X-RateLimit-Reset"]) - new Date).getMinutes();
			remaining = remaining > 1 ? "" + remaining + " minutes" : void 0;
			options.message = "You reached the rate limit for GitHub\napi calls, try again in " + remaining + "."
		}
		return callback(options)
	};
	return GitHub
}();
var __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
GitHub.Modal = function (_super) {
	function Modal(options, data) {
		null == options && (options = {});
		options = $.extend({
			title: "GitHub repositories",
			cssClass: "github-modal",
			width: 540,
			overlay: !0
		}, options);
		Modal.__super__.constructor.call(this, options, data)
	}
	__extends(Modal, _super);
	Modal.prototype.viewAppended = function () {
		this.addSubView(this.loader = new KDLoaderView({
			cssClass: "loader",
			showLoader: !0,
			size: {
				width: 16
			}
		}));
		this.addSubView(this.refreshButton = new KDButtonView({
			style: "refresh-button hidden",
			title: "",
			icon: !0,
			iconOnly: !0,
			iconClass: "cog",
			callback: this.lazyBound("checkLinkStatus", !0)
		}));
		this.addSubView(this.message = new KDView({
			cssClass: "message"
		}));
		this.addSubView(this.container = new KDView({
			cssClass: "hidden"
		}));
		this.repoController = new KDListViewController({
			viewOptions: {
				type: "github",
				wrapper: !0,
				itemClass: GitHub.RepoItem,
				itemOptions: {
					buttonTitle: "publish"
				}
			},
			noItemFoundWidget: new KDView({
				cssClass: "noitem-warning",
				partial: "There is no repository to show."
			})
		});
		this.container.addSubView(this.repoListView = this.repoController.getView());
		this.forwardEvent(this.repoController.getListView(), "RepoSelected");
		return this.checkLinkStatus()
	};
	Modal.prototype.showRepos = function (username, force) {
		this.message.updatePartial("Fetching repositories from " + GitHub.makeLink(username) + "...");
		return GitHub.fetchUserRepos(username, function (_this) {
			return function (err, repos) {
				if (err) {
					_this.loader.hide();
					_this.refreshButton.show();
					_this.message.updatePartial("An error occured while fetching\nrepos from " + GitHub.makeLink(username) + "...");
					null != err.message && new KDNotificationView({
						title: err.message
					});
					KD.utils.defer(function () {
						return _this._windowDidResize()
					});
					return warn(err)
				}
				null != _this.repoFilter && (repos = _this.repoFilter(repos));
				_this.repoController.replaceAllItems(repos);
				return KD.utils.defer(function () {
					_this._windowDidResize();
					_this.message.updatePartial("Repositories of " + GitHub.makeLink(username));
					_this.refreshButton.show();
					return _this.loader.hide()
				})
			}
		}(this), force)
	};
	Modal.prototype.checkLinkStatus = function (force) {
		var me;
		this.message.updatePartial("Checking GitHub account status...");
		this.refreshButton.hide();
		this.loader.show();
		me = KD.whoami();
		return me.fetchOAuthInfo(function (_this) {
			return function (err, oauth) {
				if (null != err) return callback(err);
				_this.container.show();
				if (null == (null != oauth ? oauth.github : void 0)) {
					_this.loader.hide();
					_this.message.updatePartial("To fetch GitHub repositories you need to link your Koding account\nwith your GitHub account. Click <span>here</span> to link now.");
					_this.container.hide();
					return _this.message.on("click", function () {
						_this.loader.show();
						_this.message.updatePartial("Waiting for authentication...");
						return GitHub.link(function (err) {
							return err ? void 0 : _this.checkLinkStatus()
						})
					})
				}
				_this.message.off("click");
				_this.container.show();
				return _this.showRepos(oauth.github.username, force)
			}
		}(this))
	};
	return Modal
}(KDModalView);
var __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
GitHub.RepoItem = function (_super) {
	function RepoItem(options, data) {
		null == options && (options = {});
		options.type = "repo";
		options.buttonTitle || (options.buttonTitle = "clone");
		RepoItem.__super__.constructor.call(this, options, data);
		this.actionButton = new KDButtonView({
			title: this.getOption("buttonTitle"),
			cssClass: "solid green mini action-button",
			callback: function (_this) {
				return function () {
					return _this.getDelegate().emit("RepoSelected", _this.getData())
				}
			}(this),
			disabled: data._disabled
		});
		data._disabled && this.setClass("disabled")
	}
	__extends(RepoItem, _super);
	JView.mixin(RepoItem.prototype);
	RepoItem.prototype.pistachio = function () {
		var description, html_url, name, _ref;
		_ref = this.getData(), name = _ref.name, description = _ref.description, html_url = _ref.html_url;
		return '<h1>\n  <a href="' + html_url + '" target="_blank">' + name + "</a>\n</h1>\n{p{#(description)}}\n{{> this.actionButton}}"
	};
	return RepoItem
}(KDListItemView);
var KodingAppsController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
KodingAppsController = function (_super) {
	function KodingAppsController() {
		var appStorage;
		KodingAppsController.__super__.constructor.apply(this, arguments);
		appStorage = KD.getSingleton("appStorageController");
		this.storage = appStorage.storage("Applications", version);
		this.storage.fetchStorage(function (_this) {
			return function () {
				_this.apps = _this.storage.getValue("installed") || {};
				_this.apps || (_this.apps = {});
				return _this.emit("ready")
			}
		}(this))
	}
	var defaultManifest, getVMNameFromPath, name, newAppModal, version;
	__extends(KodingAppsController, _super);
	name = "KodingAppsController";
	version = "0.1";
	KD.registerAppClass(KodingAppsController, {
		name: name,
		version: version,
		background: !0
	});
	KodingAppsController.loadInternalApp = function (name, callback) {
		var app, message, _ref, _ref1;
		if (!KD.config.apps[name]) {
			warn(message = "" + name + " is not available to run!");
			return callback({
				message: message
			})
		}
		if (_ref = name.capitalize(), __indexOf.call(Object.keys(KD.appClasses), _ref) >= 0) {
			warn("" + name + " is already imported");
			return callback(null)
		}
		null != (_ref1 = KD.singletons.dock) && _ref1.setNavItemState({
			name: name,
			route: "/" + name
		}, "loading");
		app = KD.config.apps[name];
		return this.putAppScript(app, callback)
	};
	KodingAppsController.putAppScript = function (app, callback) {
		null == callback && (callback = noop);
		app.style && this.appendHeadElement("style", {
			url: app.style,
			identifier: app.identifier,
			force: !0
		});
		app.script && this.appendHeadElement("script", {
			url: app.script,
			identifier: app.identifier,
			force: !0
		}, callback)
	};
	KodingAppsController.unloadAppScript = function (app, callback) {
		var identifier;
		null == callback && (callback = noop);
		identifier = app.identifier.replace(/\./g, "_");
		this.destroyScriptElement("style", identifier);
		this.destroyScriptElement("script", identifier);
		return KD.utils.defer(function () {
			return callback()
		})
	};
	KodingAppsController.runApprovedApp = function (jApp, options, callback) {
		var app, route, script, style, _ref, _ref1;
		null == options && (options = {});
		null == callback && (callback = noop);
		if (!jApp) return warn("JNewApp not found!");
		_ref = jApp.urls, script = _ref.script, style = _ref.style;
		if (!script) return warn("Script not found! on " + jApp);
		app = {
			name: jApp.name,
			script: script,
			style: style,
			identifier: jApp.identifier
		};
		route = "verified" === jApp.status ? "/" + jApp.name : "/" + jApp.manifest.authorNick + "/Apps/" + jApp.name;
		null != (_ref1 = KD.singletons.dock) && _ref1.setNavItemState({
			name: app.name,
			options: {
				dockPath: route
			}
		}, "loading");
		return this.putAppScript(app, function () {
			return KD.utils.defer(function () {
				options.dontUseRouter ? KD.singletons.appManager.open(jApp.name) : KD.singletons.router.handleRoute(route);
				return callback()
			})
		})
	};
	KodingAppsController.runExternalApp = function (jApp, options, callback) {
		var authorLink, modal, repo, script;
		null == options && (options = {});
		null == callback && (callback = noop);
		if ("verified" === jApp.status || jApp.manifest.authorNick === KD.nick()) return this.runApprovedApp(jApp, options);
		if ("not-verified" === jApp.status) return new KDModalView({
			title: "Not a verified app",
			content: "Only the owner of the app can run it.",
			buttons: {
				"Got it": {
					callback: function () {
						return this.getDelegate().destroy()
					}
				}
			}
		});
		repo = jApp.manifest.repository.replace(/^git\:\/\//, "https://");
		script = jApp.urls.script.replace(KD.config.appsUri, "https://raw.github.com");
		authorLink = '<a href="/' + jApp.manifest.authorNick + '">' + jApp.manifest.author + "</a>";
		modal = new KDModalView({
			title: "Run " + jApp.manifest.name,
			cssClass: "run-app-dialog",
			content: "<p>\n  <strong>\n    Unverified apps are not moderated, they may be harmful.\n  </strong>\n</p>\n<p>\n  If you don't know " + authorLink + ", it's recommended that\n  you don't run this app.\n</p>\n<p>This app can <span>Access your files</span>,\n  <span>Access your account</span>, <span>Change your account</span>,\n  <span>Can post updates</span>.</p>\n<p>\n  You can take a look at this application\n  <a href=\"" + repo + '" target="_blank">repository</a> and the\n  <a href="' + script + '" target="_blank">source code</a> from here.\n</p>',
			height: "auto",
			overlay: !0,
			buttons: {
				Run: {
					style: "modal-clean-red",
					loader: {
						color: "#ffffff",
						diameter: 16
					},
					callback: function (_this) {
						return function () {
							return $.ajax({
								type: "HEAD",
								url: jApp.urls.script,
								complete: function (res) {
									modal.destroy();
									return 200 === res.status ? _this.runApprovedApp(jApp, options, function () {
										return modal.destroy()
									}) : new KDNotificationView({
										title: "Application is not reachable"
									})
								}
							})
						}
					}(this)
				},
				cancel: {
					style: "modal-cancel",
					callback: function () {
						return modal.destroy()
					}
				}
			}
		});
		return modal.buttonHolder.addSubView(new KDView({
			partial: "Do you still want to continue?",
			cssClass: "run-warning"
		}))
	};
	KodingAppsController.appendHeadElement = Promise.promisify(function (type, _arg, callback) {
		var attributes, bind, delim, domId, file, force, identifier, load, tagName, url, vmName;
		identifier = _arg.identifier, url = _arg.url, force = _arg.force;
		null == callback && (callback = function () {});
		identifier = identifier.replace(/\./g, "_");
		domId = "internal-" + type + "-" + identifier;
		vmName = getVMNameFromPath(url);
		tagName = type;
		if (vmName) {
			file = FSHelper.createFileFromPath(url);
			return file.fetchContents(function (_this) {
				return function (err, partial) {
					var obj;
					if (!err) {
						obj = new KDCustomHTMLView({
							domId: domId,
							tagName: tagName
						});
						obj.getElement().textContent = partial;
						force && _this.destroyScriptElement(type, identifier);
						"script" === type ? obj.once("viewAppended", function () {
							return callback(null)
						}) : callback(null);
						return KD.utils.defer(function () {
							return obj.appendToSelector("head")
						})
					}
				}
			}(this))
		}
		delim = /\?/.test(url) ? "&" : "?";
		url = "" + url + delim + KD.utils.uniqueId();
		bind = "";
		load = noop;
		if ("style" === type) {
			tagName = "link";
			attributes = {
				rel: "stylesheet",
				href: url
			}
		} else {
			attributes = {
				type: "text/javascript",
				src: url
			};
			bind = "load";
			load = function () {
				return callback(null)
			}
		}
		force && this.destroyScriptElement(type, identifier);
		document.head.appendChild(new KDCustomHTMLView({
			domId: domId,
			tagName: tagName,
			attributes: attributes,
			bind: bind,
			load: load
		}).getElement());
		return "style" === type ? callback(null) : void 0
	});
	KodingAppsController.destroyScriptElement = function (type, identifier) {
		var _ref;
		return null != (_ref = document.getElementById("internal-" + type + "-" + identifier)) ? _ref.remove() : void 0
	};
	KodingAppsController.appendHeadElements = function (options, callback) {
		var identifier, items;
		items = options.items, identifier = options.identifier;
		return Promise.reduce(items, function () {
			return function (acc, _arg, index) {
				var type, url;
				url = _arg.url, type = _arg.type;
				return KodingAppsController.appendHeadElement(type, {
					identifier: "" + identifier + "-" + index,
					url: url
				})
			}
		}(this), 0).nodeify(callback)
	};
	defaultManifest = function (type, name) {
		var json, profile, raw;
		profile = KD.whoami().profile;
		raw = {
			background: !1,
			behavior: "application",
			version: "0.1",
			title: "" + (name || type.capitalize()),
			name: "" + (name || type.capitalize()),
			identifier: "com.koding.apps." + utils.slugify(name || type),
			path: "~/Applications/" + (name || type.capitalize()) + ".kdapp",
			homepage: "" + profile.nickname + "." + KD.config.userSitesDomain + "/" + utils.slugify(name || type),
			repository: "git://github.com/" + profile.nickname + "/" + utils.slugify(name || type) + ".kdapp.git",
			description: "" + (name || type) + " : a Koding application created with the " + type + " template.",
			category: "web-app",
			source: {
				blocks: {
					app: {
						files: ["./index.coffee"]
					}
				},
				stylesheets: ["./resources/style.css"]
			},
			options: {
				type: "tab"
			},
			icns: {
				128: "./resources/icon.128.png"
			},
			fileTypes: []
		};
		return json = JSON.stringify(raw, null, 2)
	};
	newAppModal = null;
	KodingAppsController.prototype.getAppPath = function (manifest, escaped) {
		var path;
		null == escaped && (escaped = !1);
		path = "string" == typeof manifest ? manifest : manifest.path;
		path = /^~/.test(path) ? "/home/" + KD.nick() + path.substr(1) : path;
		return escaped ? FSHelper.escapeFilePath(path) : path.replace(/(\/+)$/, "")
	};
	KodingAppsController.prototype.makeNewApp = function (callback) {
		return newAppModal = new KDModalViewWithForms({
			title: "Create a new Application",
			content: "<div class='modalformline'>\n  <p>\n    Please provide a name for your awesome Koding App you want to start with.\n  </p>\n</div>",
			overlay: !0,
			width: 600,
			height: "auto",
			tabs: {
				navigable: !0,
				forms: {
					form: {
						buttons: {
							Create: {
								cssClass: "modal-clean-gray",
								loader: {
									color: "#444444",
									diameter: 12
								},
								callback: function (_this) {
									return function () {
										var appPath, defaultVm, form, manifest, manifestStr, type;
										form = newAppModal.modalTabs.forms.form;
										if (form.inputs.name.validate()) {
											name = form.inputs.name.getValue();
											if (!name) return new KDNotificationView({
												title: "Application name is not provided."
											});
											type = "blank";
											name = name.replace(/[^a-zA-Z]/g, "").capitalize();
											manifestStr = defaultManifest(type, name);
											manifest = JSON.parse(manifestStr);
											appPath = _this.getAppPath(manifest);
											defaultVm = KD.singletons.vmController.defaultVmName;
											return FSHelper.exists(appPath, defaultVm, function (err, exists) {
												if (exists) {
													form.buttons.Create.hideLoader();
													return new KDNotificationView({
														type: "mini",
														cssClass: "error",
														title: "App folder with that name is already exists, please choose a new name.",
														duration: 3e3
													})
												}
												return _this.prepareApplication(name, function (err, response) {
													"function" == typeof callback && callback(err, response);
													form.buttons.Create.hideLoader();
													return newAppModal.destroy()
												})
											})
										}
										form.buttons.Create.hideLoader()
									}
								}(this)
							}
						},
						fields: {
							name: {
								label: "Name:",
								name: "name",
								placeholder: "name your application...",
								validate: {
									rules: {
										regExp: /^[a-z]+([a-z]+)*$/i
									},
									messages: {
										regExp: "For Application name only lowercase letters are allowed!"
									}
								}
							}
						}
					}
				}
			}
		})
	};
	KodingAppsController.prototype._createChangeLog = function (name) {
		var fullName, profile, today;
		today = (new Date).format("yyyy-mm-dd");
		profile = KD.whoami().profile;
		fullName = KD.utils.getFullnameFromAccount();
		return "" + today + " " + fullName + " <@" + profile.nickname + ">\n\n   * " + name + " (index.coffee): Application created."
	};
	KodingAppsController.prototype.prepareApplication = function (name, callback) {
		var APPNAME, appPath, appname, changeLogStr, manifest, manifestStr, type, vmController;
		if (!name) return new KDNotificationView({
			title: "Application name is not provided."
		});
		type = "blank";
		appname = KD.utils.slugify(name.replace(/[^a-zA-Z]/g, ""));
		APPNAME = appname.capitalize();
		manifestStr = defaultManifest(type, APPNAME);
		changeLogStr = this._createChangeLog(APPNAME);
		manifest = JSON.parse(manifestStr);
		appPath = this.getAppPath(manifest);
		vmController = KD.singletons.vmController;
		return vmController.run({
			method: "app.skeleton",
			withArgs: {
				type: "blank",
				appPath: appPath
			}
		}).then(function () {
			var indexFile;
			indexFile = FSHelper.createFileFromPath("" + appPath + "/index.coffee");
			return indexFile.fetchContents().then(function (content) {
				content = content.replace(/\%\%APPNAME\%\%/g, APPNAME).replace(/\%\%appname\%\%/g, appname).replace(/\%\%AUTHOR\%\%/g, KD.nick());
				return indexFile.save(content)
			})
		}).then(function () {
			var styleFile;
			styleFile = FSHelper.createFileFromPath("" + appPath + "/resources/style.css");
			return styleFile.fetchContents().then(function (content) {
				content = content.replace(/\%\%appname\%\%/g, appname);
				return styleFile.save(content)
			})
		}).then(function () {
			var readmeFile;
			readmeFile = FSHelper.createFileFromPath("" + appPath + "/README.md");
			return readmeFile.fetchContents().then(function (content) {
				var author;
				author = Encoder.htmlDecode(KD.utils.getFullnameFromAccount());
				content = content.replace(/\%\%APPNAME\%\%/g, APPNAME).replace(/\%\%AUTHOR_FULLNAME\%\%/g, author);
				return readmeFile.save(content)
			})
		}).then(function () {
			return FSHelper.createFileFromPath("" + appPath + "/manifest.json").save(manifestStr)
		}).then(function () {
			return FSHelper.createFileFromPath("" + appPath + "/ChangeLog").save(changeLogStr)
		}).then(function () {
			return {
				appPath: appPath
			}
		})["catch"](function (err) {
			return warn(err)
		}).nodeify(callback)
	};
	getVMNameFromPath = function (path) {
		var _ref;
		return null != (_ref = /^\[([^\]]+)\]/g.exec(path)) ? _ref[1] : void 0
	};
	KodingAppsController.getAppInfoFromPath = function (path, showWarning) {
		var parts, reg, vm, _ref;
		null == showWarning && (showWarning = !1);
		if (path) {
			vm = getVMNameFromPath(path);
			path = FSHelper.plainPath(path);
			reg = RegExp("^/home/" + KD.nick() + "/Applications/(.*)\\.kdapp");
			parts = reg.exec(path);
			if (parts) {
				_ref = parts.slice(0, 2), path = _ref[0], name = _ref[1];
				return {
					path: path,
					name: name,
					fullPath: "[" + vm + "]" + path,
					vm: vm
				}
			}
			showWarning && new KDNotificationView({
				title: "Failed to find app information from given path",
				type: "mini"
			})
		}
	};
	KodingAppsController.installKDC = function () {
		var modal;
		modal = new ModalViewWithTerminal({
			title: "Koding app compiler is not installed in your VM.",
			width: 500,
			overlay: !0,
			terminal: {
				hidden: !0
			},
			content: "<p>\n  If you want to install it now, click <strong>Install Compiler</strong> button.\n</p>\n<p>\n  <strong>Remember to enter your password when asked.</strong>\n</p>",
			buttons: {
				"Install Compiler": {
					cssClass: "modal-clean-green",
					callback: function () {
						return function () {
							return modal.run("sudo npm install -g kdc; echo $?|kdevent;")
						}
					}(this)
				}
			}
		});
		return modal.on("terminal.event", function () {
			return function (data) {
				if ("0" === data) {
					new KDNotificationView({
						title: "Installed successfully!"
					});
					return modal.destroy()
				}
				return new KDNotificationView({
					title: "An error occured.",
					content: "Something went wrong while installing Koding App Compiler. Please try again."
				})
			}
		}(this))
	};
	KodingAppsController.compileAppOnServer = function (path, callback) {
		var app, loader, vmController;
		app = KodingAppsController.getAppInfoFromPath(path, !0);
		if (app) {
			loader = new KDNotificationView({
				duration: 18e3,
				title: "Compiling " + app.name + "...",
				type: "mini"
			});
			vmController = KD.singletons.vmController;
			return vmController.run({
				withArgs: "kdc " + app.path,
				vmName: app.vm
			}, function (err, response) {
				if (err || !response) {
					loader.notificationSetTitle("An unknown error occured");
					loader.notificationSetTimer(2e3);
					"function" == typeof callback && callback(err, app);
					return warn(err)
				}
				if (0 === response.exitStatus) {
					loader.notificationSetTitle("App compiled successfully");
					loader.notificationSetTimer(2e3);
					return callback(null, app)
				}
				loader.destroy();
				err = response.stderr || response.stdout;
				if (127 !== response.exitStatus) {
					new KDModalView({
						title: "An error occured while compiling " + app.name,
						width: 600,
						overlay: !0,
						cssClass: "compiler-modal",
						content: "<pre>" + err + "</pre>"
					});
					return "function" == typeof callback ? callback({
						message: "Failed to compile: " + err
					}, app) : void 0
				}
				KodingAppsController.installKDC();
				"function" == typeof callback && callback({
					message: "KDC is not installed: " + err
				})
			})
		}
	};
	KodingAppsController.createJApp = function (_arg, callback) {
		var app, path, target;
		path = _arg.path, target = _arg.target;
		app = this.getAppInfoFromPath(path);
		if (app) {
			name = app.name;
			return this.compileAppOnServer(path, function (_this) {
				return function (err) {
					return err ? warn(err) : _this.fetchManifest("" + app.path + "/manifest.json", function (err, manifest) {
						var modal;
						if (null != err || !manifest) return new KDNotificationView({
							title: "Failed to fetch application manifest."
						});
						if ("production" !== target) return KD.remote.api.JNewApp.publish({
							name: name,
							url: app.fullPath,
							manifest: manifest
						}, callback);
						modal = new KodingAppSelectorForGitHub({
							title: "Select repository of " + app.name + ".kdapp",
							customFilter: RegExp("" + app.name + "\\.kdapp$")
						});
						return modal.once("RepoSelected", function (repo) {
							return GitHub.getLatestCommit(repo.name, function (err, commit) {
								var url;
								if (!err && commit) {
									url = "" + KD.config.appsUri + "/" + repo.full_name + "/" + commit.sha + "/";
									manifest.commitId = commit.sha;
									KD.remote.api.JNewApp.publish({
										name: name,
										url: url,
										manifest: manifest
									}, callback)
								} else new KDNotificationView({
									title: "Failed to fetch latest commit for " + repo.full_name
								});
								return modal.destroy()
							})
						})
					})
				}
			}(this))
		}
	};
	KodingAppsController.fetchManifest = function (path, callback) {
		var manifest;
		null == callback && (callback = noop);
		manifest = FSHelper.createFileFromPath(path);
		return manifest.fetchContents(function () {
			return function (err, response) {
				var e;
				if (err) return warn(err);
				try {
					manifest = JSON.parse(response)
				} catch (_error) {
					e = _error;
					return callback({
						message: "Failed to parse manifest.json",
						name: "JSONPARSEERROR",
						details: e
					})
				}
				return callback(null, manifest)
			}
		}(this))
	};
	return KodingAppsController
}(KDController);
var KodingAppSelectorForGitHub, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
KodingAppSelectorForGitHub = function (_super) {
	function KodingAppSelectorForGitHub(options, data) {
		null == options && (options = {});
		options.title || (options.title = "Select app repository to publish");
		KodingAppSelectorForGitHub.__super__.constructor.call(this, options, data)
	}
	__extends(KodingAppSelectorForGitHub, _super);
	KodingAppSelectorForGitHub.prototype.viewAppended = function () {
		var message, warning;
		KodingAppSelectorForGitHub.__super__.viewAppended.apply(this, arguments);
		message = this.getOption("customFilter") ? "To be able to select a repository, the name of the\nrepository should match with the application name." : "This list only includes repositories ends with '.kdapp'";
		return this.container.addSubView(warning = new KDView({
			cssClass: "warning",
			partial: message
		}))
	};
	KodingAppSelectorForGitHub.prototype.repoFilter = function (repos) {
		var customFilter, repo, _filter, _i, _len;
		customFilter = this.getOptions().customFilter;
		_filter = null != customFilter ? customFilter : /\.kdapp$/;
		for (_i = 0, _len = repos.length; _len > _i; _i++) {
			repo = repos[_i];
			repo._disabled = !_filter.test(repo.full_name)
		}
		return repos
	};
	return KodingAppSelectorForGitHub
}(GitHub.Modal);
var ContentDisplay, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ContentDisplay = function (_super) {
	function ContentDisplay(options) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("content-display-wrapper content-page", options.cssClass);
		ContentDisplay.__super__.constructor.apply(this, arguments)
	}
	__extends(ContentDisplay, _super);
	return ContentDisplay
}(MainTabPane);
var ContentDisplayController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ContentDisplayController = function (_super) {
	function ContentDisplayController() {
		ContentDisplayController.__super__.constructor.apply(this, arguments);
		this.displays = {};
		this.attachListeners()
	}
	__extends(ContentDisplayController, _super);
	ContentDisplayController.prototype.attachListeners = function () {
		var appManager, mc;
		mc = KD.singleton("mainController");
		appManager = KD.singleton("appManager");
		this.on("ContentDisplayWantsToBeShown", function (_this) {
			return function (view) {
				return mc.ready(function () {
					return _this.showDisplay(view)
				})
			}
		}(this));
		this.on("ContentDisplayWantsToBeHidden", function (_this) {
			return function (view) {
				return mc.ready(function () {
					return _this.hideDisplay(view)
				})
			}
		}(this));
		this.on("ContentDisplaysShouldBeHidden", function (_this) {
			return function () {
				return mc.ready(function () {
					return _this.hideAllDisplays()
				})
			}
		}(this));
		return appManager.on("ApplicationShowedAView", function (_this) {
			return function () {
				return mc.ready(function () {
					return _this.hideAllDisplays()
				})
			}
		}(this))
	};
	ContentDisplayController.prototype.showDisplay = function (view) {
		var activePane, model, tabPane;
		tabPane = new ContentDisplay({
			name: "content-display",
			type: "social",
			view: view
		});
		tabPane.on("KDTabPaneInactive", function (_this) {
			return function () {
				return _this.hideDisplay(view)
			}
		}(this));
		this.displays[view.id] = view;
		this.mainTabView = KD.singleton("mainView").mainTabView;
		activePane = this.mainTabView.getActivePane();
		this.mainTabView.addPane(tabPane);
		model = view.getData();
		this.changePageTitle(model);
		KD.singleton("dock").navController.selectItemByName("Activity");
		return tabPane
	};
	ContentDisplayController.prototype.changePageTitle = function (model) {
		var JAccount, JGroup, JNewStatusUpdate, title, _ref;
		if (model) {
			_ref = KD.remote.api, JAccount = _ref.JAccount, JNewStatusUpdate = _ref.JNewStatusUpdate, JGroup = _ref.JGroup;
			title = function () {
				switch (model.constructor) {
				case JAccount:
					return KD.utils.getFullnameFromAccount(model);
				case JNewStatusUpdate:
					return this.utils.getPlainActivityBody(model);
				case JGroup:
					return model.title;
				default:
					return "" + model.title + getSectionName(model)
				}
			}.call(this);
			this.utils.shortenText(title, {
				maxLength: 100
			});
			return KD.singletons.router.setPageTitle(title)
		}
	};
	ContentDisplayController.prototype.hideDisplay = function (view) {
		var tabPane;
		tabPane = view.parent;
		this.destroyView(view);
		return tabPane ? this.mainTabView.removePane(tabPane) : void 0
	};
	ContentDisplayController.prototype.hideAllDisplays = function (exceptFor) {
		var display, displayIds, id, lastId, _i, _len;
		displayIds = null != exceptFor ? function () {
			var _ref, _results;
			_ref = this.displays;
			_results = [];
			for (id in _ref)
				if (__hasProp.call(_ref, id)) {
					display = _ref[id];
					exceptFor !== display && _results.push(id)
				}
			return _results
		}.call(this) : function () {
			var _ref, _results;
			_ref = this.displays;
			_results = [];
			for (id in _ref)
				if (__hasProp.call(_ref, id)) {
					display = _ref[id];
					_results.push(id)
				}
			return _results
		}.call(this);
		if (0 !== displayIds.length) {
			lastId = displayIds.pop();
			for (_i = 0, _len = displayIds.length; _len > _i; _i++) {
				id = displayIds[_i];
				this.destroyView(this.displays[id])
			}
			return this.hideDisplay(this.displays[lastId])
		}
	};
	ContentDisplayController.prototype.destroyView = function (view) {
		this.emit("DisplayIsDestroyed", view);
		delete this.displays[view.id];
		return view.destroy()
	};
	return ContentDisplayController
}(KDController);
var Pinger, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
Pinger = function (_super) {
	function Pinger(options, data) {
		Pinger.__super__.constructor.call(this, options, data)
	}
	__extends(Pinger, _super);
	Pinger.prototype.reset = function () {
		null != this.unresponsiveTimeoutId && clearTimeout(this.unresponsiveTimeoutId);
		null != this.pingTimeoutId && clearTimeout(this.pingTimeoutId);
		delete this.unresponsiveTimeoutId;
		return delete this.pingTimeoutId
	};
	Pinger.prototype.handleChannelPublish = function () {
		this.reset();
		return this.unresponsiveTimeoutId = setTimeout(function (_this) {
			return function () {
				return _this.emit("possibleUnresponsive")
			}
		}(this), 15e3)
	};
	Pinger.prototype.handleMessageArrived = function () {
		this.reset();
		this.unresponded = 0;
		this.lastPong = Date.now();
		return this.pingTimeoutId = setTimeout(function (_this) {
			return function () {
				return _this.ping()
			}
		}(this), 3e4)
	};
	Pinger.prototype.ping = function () {
		throw new Error("The subclass must implement #ping")
	};
	Pinger.prototype.run = function () {
		throw new Error("The subclass must implement #run")
	};
	Pinger.prototype.handleSuspectChannel = function () {
		null == this.unresponded && (this.unresponded = 0);
		log("broker possibleUnresponsive: " + this.unresponded + " times");
		this.unresponded++;
		return this.unresponded > 1 ? this.emit("unresponsive") : this.run()
	};
	Pinger.prototype.setStartPinging = function () {
		return this.stopPinging = !1
	};
	Pinger.prototype.setStopPinging = function () {
		return this.stopPinging = !0
	};
	return Pinger
}(KDObject);
var Kite, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__slice = [].slice;
Kite = function (_super) {
	function Kite(options) {
		Kite.__super__.constructor.apply(this, arguments);
		this.kiteName = options.kiteName, this.correlationName = options.correlationName, this.kiteKey = options.kiteKey;
		this.initChannel();
		this.localStore = new Store;
		this.remoteStore = new Store;
		this.readyState = NOTREADY
	}
	var NOTREADY, READY, Scrubber, Store, _ref, _ref1;
	__extends(Kite, _super);
	_ref = [0, 1], NOTREADY = _ref[0], READY = _ref[1];
	_ref1 = Bongo.dnodeProtocol, Scrubber = _ref1.Scrubber, Store = _ref1.Store;
	Kite.prototype.createId = Bongo.createId;
	Kite.prototype.initChannel = function () {
		this.entropy = this.createId(128);
		this.qualifiedName = "kite-" + this.kiteName;
		this.channelName = this.getChannelName();
		this.channel = KD.kite.mq.subscribe(this.channelName);
		this.channel.setAuthenticationInfo({
			serviceType: "kite",
			name: this.qualifiedName,
			correlationName: this.correlationName,
			clientId: KD.remote.getSessionToken()
		});
		this.channel.cycleChannel = this.bound("cycleChannel");
		this.channel.ping = this.bound("ping");
		this.channel.setStartPinging = this.bound("setStartPinging");
		this.channel.setStopPinging = this.bound("setStopPinging");
		this.channel.on("message", this.bound("handleChannelMessage"));
		this.channel.on("message", this.bound("handleMessageArrived"));
		this.channel.on("publish", this.bound("handleChannelPublish"));
		this.channel.on("possibleUnresponsive", this.bound("handleSuspectChannel"));
		return this.channel.on("unresponsive", this.bound("handleUnresponsiveChannel"))
	};
	Kite.prototype.handleBrokerSubscribed = function () {};
	Kite.prototype.cycleChannel = function () {
		log("cycleChannel", this.channel.name);
		this.setStopPinging();
		this.channel.off();
		this.initChannel();
		return this.emit("destroy")
	};
	Kite.prototype.ping = function (callback) {
		if (!this.stopPinging) {
			this.channel.publish(JSON.stringify({
				method: "ping",
				arguments: [],
				callbacks: {}
			}));
			return callback ? this.channel.once("pong", callback) : void 0
		}
	};
	Kite.prototype.handleChannelMessage = function (args) {
		var callback, method;
		method = args.method;
		callback = function () {
			var _ref2;
			switch (method) {
			case "ready":
				return this.bound("handleReady");
			case "error":
				return this.bound("handleError");
			case "ping":
				return this.bound("handlePing");
			case "pong":
				return this.bound("handlePong");
			case "cycleChannel":
				return this.bound("cycleChannel");
			default:
				return null != (_ref2 = this.localStore.get(method)) ? _ref2 : function () {}
			}
		}.call(this);
		return callback.apply(this, this.unscrub(args))
	};
	Kite.prototype.handleUnresponsiveChannel = function () {
		log("unresponsive", this.channel.name);
		return this.cycleChannel()
	};
	Kite.prototype.ready = function (callback) {
		return this.readyState === READY ? KD.utils.defer(callback) : this.once("ready", callback)
	};
	Kite.prototype.handleReady = function (resourceName) {
		this.readyState = READY;
		this.channel.exchange = resourceName;
		return this.emit("ready")
	};
	Kite.prototype.handleError = function (err) {
		error(err);
		return this.emit("KiteError", err)
	};
	Kite.prototype.handlePing = function () {
		return this.channel.publish(JSON.stringify({
			method: "pong",
			arguments: [],
			callbacks: {}
		}))
	};
	Kite.prototype.handlePong = function () {
		this.channel.emit("pong");
		return this.lastPong = Date.now()
	};
	Kite.prototype.handleRequest = function (method, args) {
		return this.scrub(method, args, function (_this) {
			return function (scrubbed) {
				var messageString;
				messageString = JSON.stringify(scrubbed);
				return _this.ready(function () {
					return _this.channel.publish(messageString)
				})
			}
		}(this))
	};
	Kite.prototype.scrub = function (method, args, callback) {
		var scrubber;
		scrubber = new Scrubber(this.localStore, null, !1);
		return scrubber.scrub(args, function () {
			return function () {
				var scrubbed;
				scrubbed = scrubber.toDnodeProtocol();
				scrubbed.method || (scrubbed.method = method);
				return callback(scrubbed)
			}
		}(this))
	};
	Kite.prototype.unscrub = function (args) {
		var scrubber;
		scrubber = new Scrubber(this.localStore, null, !1);
		return scrubber.unscrub(args, function (_this) {
			return function (callbackId) {
				_this.remoteStore.has(callbackId) || _this.remoteStore.add(callbackId, function () {
					var rest;
					rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
					return _this.handleRequest(callbackId, rest)
				});
				return _this.remoteStore.get(callbackId)
			}
		}(this))
	};
	Kite.prototype.getChannelName = function () {
		var channelName, delegate, nickname, _ref2, _ref3;
		delegate = KD.whoami();
		nickname = null != (_ref2 = null != (_ref3 = null != delegate ? delegate.profile.nickname : void 0) ? _ref3 : (null != delegate ? delegate.guestId : void 0) ? "guest" + delegate.guestId : void 0) ? _ref2 : "unknown";
		channelName = "" + this.entropy + "." + nickname + "." + this.qualifiedName;
		return channelName
	};
	Kite.prototype.tellOld = function (options, callback) {
		return this.handleRequest(options.method, [options, callback])
	};
	return Kite
}(Pinger);
var KDKite, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__slice = [].slice;
KDKite = function (_super) {
	function KDKite() {
		return KDKite.__super__.constructor.apply(this, arguments)
	}
	var createProperError;
	__extends(KDKite, _super);
	KDKite.createMethod = function (ctx, _arg) {
		var method, rpcMethod;
		method = _arg.method, rpcMethod = _arg.rpcMethod;
		return ctx[method] = function () {
			var rest;
			rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
			return this.tell.apply(this, [rpcMethod].concat(__slice.call(rest)))
		}
	};
	KDKite.createApiMapping = function (api) {
		var method, rpcMethod, _results;
		_results = [];
		for (method in api)
			if (__hasProp.call(api, method)) {
				rpcMethod = api[method];
				_results.push(this.prototype[method] = this.createMethod(this.prototype, {
					method: method,
					rpcMethod: rpcMethod
				}))
			}
		return _results
	};
	KDKite.constructors = {};
	createProperError = function (err) {
		var e;
		e = new Error(err.message);
		e.type = err.type;
		e.name = err.type;
		e.code = err.code;
		return e
	};
	KDKite.prototype.tell = function (method, params) {
		var classTimeout, correlationName, kiteName, options, _ref;
		null == params && (params = {});
		_ref = this.getOptions(), correlationName = _ref.correlationName, kiteName = _ref.kiteName, classTimeout = _ref.timeout;
		options = this.getOptions();
		return new Promise(function (_this) {
			return function (resolve, reject) {
				var callback;
				options = {
					method: method,
					kiteName: kiteName,
					correlationName: correlationName,
					withArgs: params
				};
				callback = function () {
					var err, restResponse;
					err = arguments[0], restResponse = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
					return null != err ? reject(createProperError(err)) : resolve.apply(null, restResponse)
				};
				return KD.singletons.vmController.fetchVmInfo(correlationName, function (err, vm) {
					if (null != err) return reject(err);
					options.withArgs.groupId = vm.groupId;
					return _this.tellOld(options, callback)
				})
			}
		}(this)).timeout(null != classTimeout ? classTimeout : 15e3)
	};
	return KDKite
}(Kite);
var OsKite, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
OsKite = function (_super) {
	function OsKite(options, data) {
		null == options && (options = {});
		OsKite.__super__.constructor.call(this, options, data);
		this.pollState()
	}
	var KiteError;
	__extends(OsKite, _super);
	KiteError = require("kite").Error;
	OsKite.createApiMapping({
		exec: "exec",
		appInstall: "app.install",
		appDownload: "app.download",
		appPublish: "app.publish",
		appSkeleton: "app.skeleton",
		fsReadDirectory: "fs.readDirectory",
		fsGlob: "fs.glob",
		fsReadFile: "fs.readFile",
		fsGetInfo: "fs.getInfo",
		fsSetPermissions: "fs.setPermissions",
		fsRemove: "fs.remove",
		fsUniquePath: "fs.uniquePath",
		fsWriteFile: "fs.writeFile",
		fsRename: "fs.rename",
		fsCreateDirectory: "fs.createDirectory",
		s3Store: "s3.store",
		s3Delete: "s3.delete",
		vmStart: "vm.start",
		vmPrepareAndStart: "vm.prepareAndStart",
		vmStopAndUnprepare: "vm.stopAndUnprepare",
		vmShutdown: "vm.shutdown",
		vmUnprepare: "vm.unprepare",
		vmStop: "vm.stop",
		vmReinitialize: "vm.reinitialize",
		vmInfo: "vm.info",
		vmResizeDisk: "vm.resizeDisk",
		vmCreateSnapshot: "vm.createSnapshot"
	});
	OsKite.prototype.stopPollingState = function () {
		log("stop polling state");
		KD.utils.killRepeat(this.intervalId);
		return this.intervalId = null
	};
	OsKite.prototype.pollState = function () {
		log("start polling state");
		this.fetchState();
		KD.getSingleton("mainController").once("userIdle", this.bound("stopPollingState")).once("userBack", this.bound("pollState"));
		return this.intervalId = KD.utils.repeat(KD.config.osKitePollingMs, this.bound("fetchState"))
	};
	OsKite.prototype.fetchState = function () {
		return this.vmInfo().then(function (_this) {
			return function (state) {
				var _ref;
				"RUNNING" === state.state && "RUNNING" !== (null != (_ref = _this.recentState) ? _ref.state : void 0) && _this.emit("vmOn");
				_this.recentState = state;
				_this.emit("vm.state.info", _this.recentState);
				return state ? void 0 : _this.cycleChannel()
			}
		}(this))
	};
	OsKite.prototype.changeState = function (state, event, finEvent, method) {
		return null == this.recentState || this.recentState.state !== state ? method.call(this, {
			onProgress: function (_this) {
				return function (update) {
					var _ref;
					if (update.error) return _this.handleError(update);
					if ("FINISHED" === update.message) {
						null != (_ref = _this.recentState) && (_ref.state = state);
						_this.emit(finEvent)
					}
					return _this.emit(event, update)
				}
			}(this)
		}) : Promise.resolve()
	};
	OsKite.prototype.vmOn = function () {
		var errPredicate;
		errPredicate = function (err) {
			return !(KiteError.codeIs("ErrQuotaExceeded")(err) || /ErrQuotaExceeded/.test(err.message))
		};
		return function (t) {
			null == t && (t = 0);
			return this.changeState("RUNNING", "vm.progress.start", "vmOn", this.vmPrepareAndStart)["catch"](errPredicate, function (_this) {
				return function (err) {
					if (5 > t) return Promise.delay(1e3 * Math.pow(1.3, ++t)).then(function () {
						return _this.vmOn(t)
					});
					ErrorLog.create("terminal: vm turn on", {
						attempt: t,
						reason: null != err ? err.message : void 0
					});
					throw err
				}
			}(this)).then(function (_this) {
				return function () {
					return _this.emit("vmOn")
				}
			}(this))
		}
	}();
	OsKite.prototype.vmOff = function () {
		return this.changeState("STOPPED", "vm.progress.stop", "vmOff", this.vmStopAndUnprepare)
	};
	OsKite.prototype.handleError = function (update) {
		var error, _ref;
		error = update.error;
		KD.utils.warnAndLog(null != error ? error.message : void 0);
		null != (_ref = this.recentState) && (_ref.state = "FAILED");
		return this.emit("vm.progress.error", error)
	};
	OsKite.prototype.fsExists = function (options) {
		return this.fsGetInfo(options).then(function (result) {
			return !!result
		})
	};
	OsKite.constructors.oskite = OsKite;
	OsKite.constructors.os = OsKite;
	return OsKite
}(KDKite);
var TerminalKite, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
TerminalKite = function (_super) {
	function TerminalKite() {
		return TerminalKite.__super__.constructor.apply(this, arguments)
	}
	__extends(TerminalKite, _super);
	TerminalKite.createApiMapping({
		webtermGetSessions: "webterm.getSessions",
		webtermConnect: "webterm.connect",
		webtermKillSession: "webterm.killSession",
		webtermPing: "webterm.ping"
	});
	TerminalKite.constructors.terminal = TerminalKite;
	return TerminalKite
}(KDKite);
var KiteController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
KiteController = function (_super) {
	function KiteController() {
		KiteController.__super__.constructor.apply(this, arguments);
		this.kiteIds = {};
		this.status = !1;
		this.intervals = {};
		this.setListeners();
		this.kites = {};
		this.channels = {};
		this.kiteInstances = {};
		this.helper = new KiteHelper
	}
	var getKiteKey, notify, _attempt, _notifications, _tempCallback, _tempOptions;
	__extends(KiteController, _super);
	_tempOptions = null;
	_tempCallback = null;
	_attempt = 1;
	_notifications = {
		"default": "Something went wrong",
		creatingEnv: "Creating your environment.",
		stillCreatingEnv: "...still busy with setting up your environment.",
		creationTookLong: "...still busy with it, there might be something wrong.",
		tookTooLong: "It seems like we couldn't set up your environment, please click here to try again.",
		envCreated: "Your server, terminal and files are ready, enjoy!",
		notResponding: "Backend is not responding, trying to fix...",
		checkingServers: "Checking if servers are back...",
		alive: "Shared hosting is alive!"
	};
	getKiteKey = function (kiteName, correlationName) {
		return "~" + kiteName + "~" + correlationName
	};
	KiteController.prototype.getKite = function (kiteName, correlationName, type) {
		var key, kite;
		key = getKiteKey(kiteName, correlationName);
		kite = this.kiteInstances[key];
		if (null != kite) return kite;
		kite = this.createKite(kiteName, correlationName, key, type);
		this.kiteInstances[key] = kite;
		return kite
	};
	KiteController.prototype.destroyKite = function (kite) {
		return delete this.kiteInstances[kite.kiteKey]
	};
	KiteController.prototype.createKite = function (kiteName, correlationName, kiteKey, type) {
		var kite, konstructor;
		null == type && (type = "os");
		konstructor = KDKite.constructors[type];
		if (null == konstructor) throw new Error("Unknown constructor: " + kiteName);
		kite = new konstructor({
			kiteName: kiteName,
			correlationName: correlationName,
			kiteKey: kiteKey
		});
		kite.on("destroy", function (_this) {
			return function () {
				_this.destroyKite(kite);
				return _this.emit("channelDeleted", kite, kiteName)
			}
		}(this));
		this.forwardEvent(kite, "KiteError");
		this.emit("channelAdded", kite, kiteName);
		return kite
	};
	notify = function (options) {
		var notification;
		null == options && (options = {});
		"string" == typeof options && (options = {
			msg: options
		});
		options.msg || (options.msg = _notifications["default"]);
		options.duration || (options.duration = 3303);
		options.cssClass || (options.cssClass = "");
		options.click || (options.click = noop);
		return notification = new KDNotificationView({
			title: "<span></span>" + options.msg,
			type: "tray",
			cssClass: "mini realtime " + options.cssClass,
			duration: options.duration,
			click: options.click
		})
	};
	KiteController.prototype.addKite = function (name, channel) {
		this.channels[name] = channel;
		this.kites[name] = channel;
		return this.emit("channelAdded", channel, name)
	};
	KiteController.prototype.deleteKite = function (name) {
		this.emit("channelDeleted", this.kites[name], name);
		delete this.kites[name];
		return delete this.channels[name]
	};
	KiteController.prototype.run = function (options, callback) {
		var command, correlationName, kite, ok, vmc;
		null == options && (options = {});
		console.warn("KiteController#run is deprecated");
		if ("string" == typeof options) {
			command = options;
			options = {}
		}
		if ("string" == typeof options.withArgs) {
			command = options.withArgs;
			options.withArgs = {}
		}
		options.method || (options.method = "exec");
		options.kiteName || (options.kiteName = "os");
		correlationName = options.correlationName || "";
		if ("os" === options.kiteName && !correlationName) {
			warn("THIS METHOD DEPRECATED, PLEASE USE vmController.run with vmName !");
			warn("OS kite call requested without providing\ncorrelationName, using default if exists.");
			vmc = KD.getSingleton("vmController");
			correlationName = vmc.defaultVmName;
			options.kiteName = "os-" + vmc.vmRegions[vmc.defaultVmName]
		}
		kite = KD.useNewKites ? KD.getSingleton("kontrol").getKite({
			name: options.kiteName,
			correlationName: correlationName
		}) : this.getKite(options.kiteName, correlationName);
		command ? options.withArgs.command = command : null == options.withArgs && (options.withArgs = {});
		if (KD.logsEnabled && KD.showKiteCalls) {
			notify("Calling <b>" + options.method + "</b> method,\nfrom <b>" + options.kiteName + "</b> kite");
			log("Kite Request:", options)
		}
		ok = "os" === options.kiteName ? kite.vmOn() : Promise.cast();
		return ok.then(function () {
			return kite.tell(options.method, options.withArgs)
		}).nodeify(function (_this) {
			return function (err, response) {
				return _this.parseKiteResponse({
					err: err,
					response: response
				}, options, callback)
			}
		}(this))
	};
	KiteController.prototype.setListeners = function () {
		var mainController;
		mainController = KD.getSingleton("mainController");
		this.on("CreatingUserEnvironment", function () {
			return function () {
				var mainView;
				return mainView = KD.getSingleton("mainView")
			}
		}(this));
		return this.on("UserEnvironmentIsCreated", function () {
			return function () {
				if (1 !== _attempt) {
					notify(_notifications.envCreated);
					return _attempt = 1
				}
			}
		}(this))
	};
	KiteController.prototype.accountChanged = function () {
		var kiteName;
		kiteName = "sharedHosting";
		return KD.isLoggedIn() ? this.resetKiteIds(kiteName, function (_this) {
			return function (err) {
				return err ? void 0 : _this.status = !0
			}
		}(this)) : this.status = !1
	};
	KiteController.prototype.parseKiteResponse = function (_arg, options, callback) {
		var err, notification, response;
		err = _arg.err, response = _arg.response;
		if (err && response) {
			"function" == typeof callback && callback(err, response);
			return warn("Command failed:", err)
		}
		if (err) {
			if (503 === err.code) return notification = notify({
				msg: error.message,
				duration: 0,
				click: function () {
					return notification.destroy()
				}
			});
			if (err.kiteNotPresent) return this.handleKiteNotPresent({
				err: err,
				response: response
			}, options, callback);
			if (/No\ssuch\suser/.test(err)) {
				_tempOptions || (_tempOptions = options);
				_tempCallback || (_tempCallback = callback);
				return this.createSystemUser(callback)
			}
			if (/Entry\sAlready\sExists/.test(err)) return this.utils.wait(5e3, function (_this) {
				return function () {
					_attempt++;
					return _this.run(_tempOptions, _tempCallback)
				}
			}(this));
			if (null != err.message) {
				"function" == typeof callback && callback(err);
				return warn("An error occured:", err.message)
			}
			"function" == typeof callback && callback(err);
			return warn("parsing kite response: we dont handle this yet", err)
		}
		this.status = !0;
		return "function" == typeof callback ? callback(err, response) : void 0
	};
	KiteController.prototype.handleKiteNotPresent = function (_arg, options, callback) {
		var err, response;
		err = _arg.err, response = _arg.response;
		notify(_notifications.notResponding);
		return this.resetKiteIds(options.kiteName, function (_this) {
			return function (err, kiteIds) {
				if (Array.isArray(kiteIds) && kiteIds.length > 0) return _this.run(options, callback);
				notify("Backend is not responding, try again later.");
				warn("handleKiteNotPresent: we dont handle this yet", err);
				return "function" == typeof callback ? callback("handleKiteNotPresent: we dont handle this yet") : void 0
			}
		}(this))
	};
	KiteController.prototype.createSystemUser = function (callback) {
		if (_attempt > 1 && 5 > _attempt) notify(_notifications.stillCreatingEnv);
		else if (_attempt >= 5 && 10 > _attempt) notify({
			msg: _notifications.creationTookLong,
			duration: 4500
		});
		else {
			if (_attempt >= 10) {
				notify({
					msg: _notifications.tookTooLong,
					duration: 0,
					click: function (_this) {
						return function () {
							return _this.createSystemUser(callback)
						}
					}(this)
				});
				return
			}
			this.emit("CreatingUserEnvironment");
			notify(_notifications.creatingEnv)
		}
		return this.run({
			method: "createSystemUser",
			withArgs: {
				fullName: "" + KD.whoami().getAt("profile.firstName") + " " + KD.whoami().getAt("profile.lastName"),
				password: utils.getRandomHex().substr(1)
			}
		}, function (_this) {
			return function (err, res) {
				log("Creating the user environment.");
				"function" == typeof callback && callback(err, res);
				if (err) return error("createUserEnvironment", err);
				notify(_notifications.envCreated);
				return _this.emit("UserEnvironmentIsCreated")
			}
		}(this))
	};
	KiteController.prototype.ping = function (kiteName, callback) {
		log("pinging : " + kiteName);
		return this.run({
			method: "_ping"
		}, function (_this) {
			return function (err) {
				if (err) {
					notify(_notifications.checkingServers);
					_this.parseError(_this, err)
				} else {
					_this.status = !0;
					_this.pinger && clearInterval(_this.pinger);
					notify(_notifications.alive)
				}
				return "function" == typeof callback ? callback() : void 0
			}
		}(this))
	};
	KiteController.prototype.setPinger = function () {
		if (!this.pinger) {
			this.pinger = setInterval(function (_this) {
				return function () {
					return _this.ping()
				}
			}(this), 1e4);
			return this.ping()
		}
	};
	KiteController.prototype.resetKiteIds = function (kiteName) {
		null == kiteName && (kiteName = "sharedHosting")
	};
	return KiteController
}(KDController);
var KiteHelper, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
KiteHelper = function (_super) {
	function KiteHelper() {
		KiteHelper.__super__.constructor.apply(this, arguments);
		this.attachListeners()
	}
	var clear, registerKodingClient_;
	__extends(KiteHelper, _super);
	KiteHelper.prototype.attachListeners = function () {
		var mainController;
		mainController = KD.getSingleton("mainController");
		mainController.on("pageLoaded.as.loggedIn", function (_this) {
			return function () {
				return _this.emit("changedToLoggedIn")
			}
		}(this));
		mainController.on("accountChanged.to.loggedIn", function (_this) {
			return function () {
				return _this.emit("changedToLoggedIn")
			}
		}(this));
		return this.once("changedToLoggedIn", this.registerKodingClient)
	};
	clear = function () {
		Cookies.expire("register-to-koding-client");
		return KD.getSingleton("router").clear()
	};
	KiteHelper.initiateRegistiration = function () {
		var message, modal;
		Cookies.set("register-to-koding-client", !0);
		if (KD.isLoggedIn()) {
			KD.getSingleton("router").clear();
			return registerKodingClient_()
		}
		message = "Please login to proceed to the next step";
		return modal = new KDBlockingModalView({
			title: "Koding Client Registration",
			content: "<div class='modalformline'>" + message + "</div>",
			height: "auto",
			overlay: !0,
			buttons: {
				"Go to Login": {
					style: "modal-clean-gray",
					callback: function () {
						modal.destroy();
						return KD.utils.wait(5e3, KD.getSingleton("router").handleRoute("/Login"))
					}
				},
				Cancel: {
					style: "modal-cancel",
					callback: function () {
						modal.destroy();
						return clear()
					}
				}
			}
		})
	};
	registerKodingClient_ = function () {
		var handleInfo, k, registerToKodingClient, showErrorModal, showSuccessfulModal;
		if (registerToKodingClient = Cookies.get("register-to-koding-client")) {
			clear();
			k = new NewKite({
				name: "kodingclient",
				publicIP: "127.0.0.1",
				port: "54321"
			});
			k.connect();
			showErrorModal = function (error, callback) {
				var Cancel, Ok, Retry, code, message, modal;
				message = error.message, code = error.code;
				modal = new KDBlockingModalView({
					title: "Kite Registration",
					content: "<div class='modalformline'>" + message + "</div>",
					height: "auto",
					overlay: !0,
					buttons: {}
				});
				Retry = {
					style: "modal-clean-gray",
					callback: function () {
						modal.destroy();
						return "function" == typeof callback ? callback() : void 0
					}
				};
				Cancel = {
					style: "modal-clean-red",
					callback: function () {
						modal.destroy();
						return clear()
					}
				};
				Ok = {
					style: "modal-clean-gray",
					callback: function () {
						modal.destroy();
						return clear()
					}
				};
				return 201 === code ? modal.setButtons({
					Ok: Ok
				}, !0) : modal.setButtons({
					Retry: Retry,
					Cancel: Cancel
				}, !0)
			};
			showSuccessfulModal = function (message, callback) {
				var modal;
				return modal = new KDBlockingModalView({
					title: "Koding Client Registration",
					content: "<div class='modalformline'>" + message + "</div>",
					height: "auto",
					overlay: !0,
					buttons: {
						Ok: {
							style: "modal-clean-green",
							callback: function () {
								modal.destroy();
								return "function" == typeof callback ? callback() : void 0
							}
						}
					}
				})
			};
			handleInfo = function (err, result) {
				return KD.remote.api.JKodingKey.registerHostnameAndKey({
					key: result.key,
					hostname: result.hostID
				}, function (err, res) {
					var fn;
					fn = function () {
						return function () {
							return k.tellOld("info", handleInfo)
						}
					}(this);
					return err ? showErrorModal(err, fn) : showSuccessfulModal(res, function () {
						result.cb(!0);
						return KD.utils.wait(500, clear)
					})
				})
			};
			return k.tellOld("info", handleInfo)
		}
	};
	KiteHelper.prototype.registerKodingClient = registerKodingClient_;
	return KiteHelper
}(KDEventEmitter);
var KodingKite, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
KodingKite = function (_super) {
	function KodingKite(options) {
		var name;
		KodingKite.__super__.constructor.call(this, options);
		name = options.name
	}
	var extractInfoFromWsEvent;
	__extends(KodingKite, _super);
	KodingKite.Error = require("kite").Error;
	extractInfoFromWsEvent = function (event) {
		var code, reason, timestamp, type, wasClean;
		reason = event.reason, code = event.code, wasClean = event.wasClean, timestamp = event.timestamp, type = event.type;
		return {
			reason: reason,
			code: code,
			wasClean: wasClean,
			timestamp: timestamp,
			type: type
		}
	};
	KodingKite.prototype.logTransportFailures = function () {
		this.transport.ws.addEventListener("close", function (event) {
			var params;
			params = extractInfoFromWsEvent(event);
			return ErrorLog.create("ws closed", params)
		});
		return this.transport.ws.addEventListener("error", function (event) {
			var params;
			params = extractInfoFromWsEvent(event);
			return ErrorLog.create("ws error", params)
		})
	};
	KodingKite.prototype.getTransport = function () {
		return this.transport
	};
	KodingKite.prototype.setTransport = function (transport) {
		this.transport = transport;
		this.transport.connect();
		return this.emit("ready")
	};
	KodingKite.prototype.tell = function (rpcMethod, params, callback) {
		return this.ready().then(function (_this) {
			return function () {
				return _this.transport.tell(rpcMethod, [params], callback)
			}
		}(this))
	};
	KodingKite.createMethod = function (ctx, _arg) {
		var method, rpcMethod;
		method = _arg.method, rpcMethod = _arg.rpcMethod;
		return ctx[method] = function (payload) {
			return this.tell(rpcMethod, payload)
		}
	};
	KodingKite.createApiMapping = function (api) {
		var method, rpcMethod, _results;
		_results = [];
		for (method in api)
			if (__hasProp.call(api, method)) {
				rpcMethod = api[method];
				_results.push(this.prototype[method] = this.createMethod(this.prototype, {
					method: method,
					rpcMethod: rpcMethod
				}))
			}
		return _results
	};
	KodingKite.constructors = {};
	return KodingKite
}(KDObject);
var KodingKontrol, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__slice = [].slice;
KodingKontrol = function (_super) {
	function KodingKontrol() {
		KodingKontrol.__super__.constructor.call(this, this.getAuthOptions());
		this.kites = {};
		this.regions = {}
	}
	__extends(KodingKontrol, _super);
	KodingKontrol.prototype.getAuthOptions = function () {
		return {
			autoConnect: !1,
			url: KD.config.newkontrol.url,
			auth: {
				type: "sessionID",
				key: Cookies.get("clientId")
			},
			transportClass: SockJS,
			transportOptions: {
				heartbeatTimeout: 3e4
			}
		}
	};
	KodingKontrol.prototype.reauthenticate = function () {
		var _ref;
		null != (_ref = this.kite) && _ref.disconnect();
		return this.authenticate(this.getAuthOptions())
	};
	KodingKontrol.prototype.fetchKites = function () {
		var query, rest;
		query = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
		null == query && (query = {});
		return KodingKontrol.__super__.fetchKites.apply(this, [this.injectQueryParams(query)].concat(__slice.call(rest)))
	};
	KodingKontrol.prototype.getVersion = function (name) {
		var os, terminal, _ref, _ref1;
		if (null == name) return "1.0.0";
		_ref = KD.config.kites, os = _ref.os, terminal = _ref.terminal;
		return null != (_ref1 = {
			oskite: os.version,
			terminal: terminal.version
		}[name]) ? _ref1 : ""
	};
	KodingKontrol.prototype.injectQueryParams = function (args) {
		var _base;
		null == (_base = args.query).version && (_base.version = this.getVersion(args.query.name));
		args.query.username = KD.config.kites.kontrol.username;
		args.query.environment = KD.config.environment;
		return args
	};
	KodingKontrol.prototype.getCachedKite = function (name, correlationName) {
		var _ref;
		return null != (_ref = this.kites[name]) ? _ref[correlationName] : void 0
	};
	KodingKontrol.prototype.setCachedKite = function (name, correlationName, kite) {
		var _base;
		null == (_base = this.kites)[name] && (_base[name] = {});
		return this.kites[name][correlationName] = kite
	};
	KodingKontrol.prototype.hasKite = function (options) {
		var correlationName, kite, name, region;
		null == options && (options = {});
		name = options.name, correlationName = options.correlationName, region = options.region;
		return null != (kite = this.getCachedKite(name, correlationName))
	};
	KodingKontrol.prototype.fetchRegion = function (correlationName, region) {
		return (null != region ? region : region = this.regions[correlationName]) ? Promise.resolve(region) : new Promise(function (_this) {
			return function (resolve, reject) {
				return KD.remote.api.JVM.fetchVmRegion(correlationName, function (err, region) {
					if (err) {
						warn(err);
						return reject(err)
					}
					region || (region = "sj");
					_this.regions[correlationName] = region;
					return resolve(region)
				})
			}
		}(this))
	};
	KodingKontrol.prototype.fetchVmInfo = function (correlationName) {
		return new Promise(function (resolve, reject) {
			return KD.remote.api.JVM.fetchVmInfo(correlationName, function () {
				return function (err, info) {
					return err ? reject(err) : null == info ? reject(new Error("VM info not found!")) : resolve(info)
				}
			}(this))
		})
	};
	KodingKontrol.prototype.getWhoParams = function (kiteName, correlationName) {
		return "oskite" === kiteName || "terminal" === kiteName ? {
			vmName: correlationName
		} : {
			correlationName: correlationName
		}
	};
	KodingKontrol.prototype.getKiteByCorrelationName = function (name, correlationName) {
		var kite;
		kite = this.getKiteProxy({
			name: name,
			correlationName: correlationName
		});
		this.fetchVmInfo(correlationName).then(function (_this) {
			return function (_arg) {
				var region;
				region = _arg.region;
				return _this.fetchKite({
					query: {
						name: name,
						region: region
					},
					who: _this.getWhoParams(name, correlationName)
				})
			}
		}(this)).then(kite.bound("setTransport")).then(kite.bound("logTransportFailures"))["catch"](function (_this) {
			return function (err) {
				var message;
				warn(err);
				message = err.message;
				message = message ? message : err;
				ErrorLog.create(message);
				return _this.setCachedKite(name, correlationName)
			}
		}(this));
		return kite
	};
	KodingKontrol.prototype.getKiteProxy = function (options) {
		var correlationName, kite, konstructor, name;
		name = options.name, correlationName = options.correlationName;
		if (null != (kite = this.getCachedKite(name, correlationName))) return kite;
		konstructor = KodingKite.constructors[name];
		kite = new konstructor(options);
		this.setCachedKite(name, correlationName, kite);
		return kite
	};
	KodingKontrol.prototype.getKite = function (options) {
		var correlationName, kite, name, region;
		null == options && (options = {});
		name = options.name, correlationName = options.correlationName, region = options.region;
		if (null != (kite = this.getCachedKite(name, correlationName))) return kite;
		kite = this.getKiteProxy(options);
		this.fetchRegion(correlationName, region).then(function (_this) {
			return function (region) {
				return _this.fetchKite({
					query: {
						name: name,
						region: region
					},
					who: _this.getWhoParams(name, correlationName)
				})
			}
		}(this)).then(kite.bound("setTransport")).then(kite.bound("logTransportFailures"))["catch"](function (_this) {
			return function (err) {
				var message;
				warn(err);
				message = err.message;
				message = message ? message : err;
				ErrorLog.create(message);
				return _this.setCachedKite(name, correlationName)
			}
		}(this));
		return kite
	};
	return KodingKontrol
}(require("kontrol"));
var KodingKite_VmKite, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
KodingKite_VmKite = function (_super) {
	function KodingKite_VmKite() {
		return KodingKite_VmKite.__super__.constructor.apply(this, arguments)
	}
	__extends(KodingKite_VmKite, _super);
	KodingKite_VmKite.createMethod = function (ctx, _arg) {
		var method, rpcMethod;
		method = _arg.method, rpcMethod = _arg.rpcMethod;
		return ctx[method] = function (payload) {
			null == payload && (payload = {});
			return this.tell(rpcMethod, payload)
		}
	};
	KodingKite_VmKite.prototype.tell = function (method, payload) {
		null == payload && (payload = {});
		payload.vmName = this.options.correlationName;
		payload.groupId = this.options.groupId;
		return KodingKite_VmKite.__super__.tell.call(this, method, payload)
	};
	return KodingKite_VmKite
}(KodingKite);
var KodingKite_OsKite, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
KodingKite_OsKite = function (_super) {
	function KodingKite_OsKite(options, data) {
		null == options && (options = {});
		KodingKite_OsKite.__super__.constructor.call(this, options, data);
		this.pollState()
	}
	var KiteError;
	__extends(KodingKite_OsKite, _super);
	KiteError = KodingKite_OsKite.Error;
	KodingKite_OsKite.constructors.oskite = KodingKite_OsKite;
	KodingKite_OsKite.createApiMapping({
		exec: "exec",
		appInstall: "app.install",
		appDownload: "app.download",
		appPublish: "app.publish",
		appSkeleton: "app.skeleton",
		fsReadDirectory: "fs.readDirectory",
		fsGlob: "fs.glob",
		fsReadFile: "fs.readFile",
		fsGetInfo: "fs.getInfo",
		fsSetPermissions: "fs.setPermissions",
		fsRemove: "fs.remove",
		fsUniquePath: "fs.uniquePath",
		fsWriteFile: "fs.writeFile",
		fsRename: "fs.rename",
		fsCreateDirectory: "fs.createDirectory",
		s3Store: "s3.store",
		s3Delete: "s3.delete",
		vmStart: "vm.start",
		vmPrepareAndStart: "vm.prepareAndStart",
		vmStopAndUnprepare: "vm.stopAndUnprepare",
		vmShutdown: "vm.shutdown",
		vmUnprepare: "vm.unprepare",
		vmStop: "vm.stop",
		vmReinitialize: "vm.reinitialize",
		vmInfo: "vm.info",
		vmResizeDisk: "vm.resizeDisk",
		vmCreateSnapshot: "vm.createSnapshot"
	});
	KodingKite_OsKite.prototype.stopPollingState = function () {
		log("stop polling state");
		KD.utils.killRepeat(this.intervalId);
		return this.intervalId = null
	};
	KodingKite_OsKite.prototype.pollState = function () {
		log("start polling state");
		this.fetchState();
		KD.getSingleton("mainController").once("userIdle", this.bound("stopPollingState")).once("userBack", this.bound("pollState"));
		return this.intervalId = KD.utils.repeat(KD.config.osKitePollingMs, this.bound("fetchState"))
	};
	KodingKite_OsKite.prototype.fetchState = function () {
		return this.vmInfo().then(function (_this) {
			return function (state) {
				var _ref;
				"RUNNING" === state.state && "RUNNING" !== (null != (_ref = _this.recentState) ? _ref.state : void 0) && _this.emit("vmOn");
				_this.recentState = state;
				return _this.emit("vm.state.info", _this.recentState)
			}
		}(this))
	};
	KodingKite_OsKite.prototype.changeState = function (state, event, finEvent, method) {
		return null == this.recentState || this.recentState.state !== state ? method.call(this, {
			onProgress: function (_this) {
				return function (update) {
					var _ref;
					if (update.error) return _this.handleError(update);
					if ("FINISHED" === update.message) {
						null != (_ref = _this.recentState) && (_ref.state = state);
						_this.emit(finEvent)
					}
					return _this.emit(event, update)
				}
			}(this)
		}) : Promise.resolve()
	};
	KodingKite_OsKite.prototype.vmOn = function (t) {
		null == t && (t = 0);
		return this.changeState("RUNNING", "vm.progress.start", "vmOn", this.vmPrepareAndStart)["catch"](KiteError.codeIsnt("ErrQuotaExceeded"), function (_this) {
			return function (err) {
				if (5 > t) return Promise.delay(1e3 * Math.pow(1.3, ++t)).then(function () {
					return _this.vmOn(t)
				});
				throw err
			}
		}(this)).then(function (_this) {
			return function () {
				return _this.emit("vmOn")
			}
		}(this))
	};
	KodingKite_OsKite.prototype.vmOff = function () {
		return this.changeState("STOPPED", "vm.progress.stop", "vmOff", this.vmStopAndUnprepare)
	};
	KodingKite_OsKite.prototype.fsExists = function (options) {
		return this.fsGetInfo(options).then(function (result) {
			return !!result
		})
	};
	KodingKite_OsKite.prototype.handleError = function (update) {
		var error, _ref;
		error = update.error;
		warn("vm prepare error ", error.Message);
		null != (_ref = this.recentState) && (_ref.state = "FAILED");
		return this.emit("vm.progress.error", error)
	};
	return KodingKite_OsKite
}(KodingKite_VmKite);
var KodingKite_TerminalKite, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
KodingKite_TerminalKite = function (_super) {
	function KodingKite_TerminalKite() {
		return KodingKite_TerminalKite.__super__.constructor.apply(this, arguments)
	}
	__extends(KodingKite_TerminalKite, _super);
	KodingKite_TerminalKite.constructors.terminal = KodingKite_TerminalKite;
	KodingKite_TerminalKite.createApiMapping({
		webtermGetSessions: "webterm.getSessions",
		webtermConnect: "webterm.connect",
		webtermKillSession: "webterm.killSession",
		webtermPing: "webterm.ping"
	});
	return KodingKite_TerminalKite
}(KodingKite_VmKite);
var VirtualizationController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__slice = [].slice;
VirtualizationController = function (_super) {
	function VirtualizationController() {
		var mc;
		VirtualizationController.__super__.constructor.apply(this, arguments);
		this.kc = KD.getSingleton("kiteController");
		this.payment = KD.singleton("paymentController");
		this.resetVMData();
		this.kites = {};
		this.terminalKites = {};
		this.vmsInfo = {};
		this.osKites = {};
		mc = KD.getSingleton("mainController");
		mc.once("AppIsReady", function (_this) {
			return function () {
				return KD.isLoggedIn() ? _this.fetchVMs(function () {
					return _this.emit("ready")
				}) : _this.emit("ready")
			}
		}(this));
		mc.on("AccountChanged", function (_this) {
			return function () {
				return _this.emit("VMListChanged")
			}
		}(this));
		this.on("VMListChanged", this.bound("fetchVMs"))
	}
	__extends(VirtualizationController, _super);
	VirtualizationController.prototype.run = Promise.promisify(function (options, callback) {
		var command;
		null == callback && (callback = noop);
		null == options && (options = {});
		if ("string" == typeof options) {
			command = options;
			options = {
				withArgs: command
			}
		}
		return this.fetchVmName(options, function (_this) {
			return function (err, vmName) {
				if (null != err) return callback(err);
				options.correlationName = vmName;
				return _this.fetchVmInfo(vmName, function (err, vm) {
					var region, _ref;
					if (err) return callback(err);
					region = vm.region;
					options.groupId = vm.groupId;
					options.kiteName = KD.useNewKites ? "os" === options.kiteName ? "oskite" : null != (_ref = options.kiteName) ? _ref : "oskite" : options.kiteName ? "" + options.kiteName + "-" + region : "os-" + region;
					return _this.kc.run(options, callback)
				})
			}
		}(this))
	});
	VirtualizationController.prototype.ping = function (callback) {
		var options;
		options = {
			withArgs: ""
		};
		return this.run(options, callback)
	};
	VirtualizationController.prototype._runWrapper = function (command, vm, callback) {
		var _ref;
		vm && "string" != typeof vm && (_ref = [vm, callback], callback = _ref[0], vm = _ref[1]);
		return this.fetchDefaultVmName(function (_this) {
			return function (defaultVm) {
				vm || (vm = defaultVm);
				return vm ? _this.askForApprove(command, function (approved) {
					var cb;
					if (approved) {
						cb = "vm.info" !== command ? _this._cbWrapper(vm, callback) : callback;
						return _this.run({
							method: command,
							vmName: vm
						}, cb)
					}
					return "vm.info" !== command ? _this.info(vm) : void 0
				}) : void 0
			}
		}(this))
	};
	VirtualizationController.prototype.resizeDisk = function (vm, callback) {
		return this._runWrapper("vm.resizeDisk", vm, callback)
	};
	VirtualizationController.prototype.start = function (vm, callback) {
		console.warn("VirtualizationController#start is deprecated");
		return this._runWrapper("vm.prepareAndStart", vm, callback)
	};
	VirtualizationController.prototype.stop = function (vm, callback) {
		console.warn("VirtualizationController#shutdown is deprecated");
		return this._runWrapper("vm.shutdown", vm, callback)
	};
	VirtualizationController.prototype.halt = function (vm, callback) {
		console.warn("VirtualizationController#halt is deprecated");
		return this._runWrapper("vm.stopAndUnprepare", vm, callback)
	};
	VirtualizationController.prototype.reinitialize = function (vm, callback) {
		console.warn("VirtualizationController#reinitialize is deprecated");
		return this._runWrapper("vm.reinitialize", vm, callback)
	};
	VirtualizationController.prototype.fetchVmInfo = function (vm, callback) {
		var JVM;
		JVM = KD.remote.api.JVM;
		return JVM.fetchVmInfo(vm, callback)
	};
	VirtualizationController.prototype.confirmVmDeletion = function (vmInfo, callback) {
		var hostnameAlias, modal, vmPrefix, _ref;
		null == callback && (callback = function () {});
		hostnameAlias = vmInfo.hostnameAlias;
		vmPrefix = (null != (_ref = this.parseAlias(hostnameAlias)) ? _ref.prefix : void 0) || hostnameAlias;
		return modal = new VmDangerModalView({
			name: vmInfo.hostnameAlias,
			title: "Destroy '" + hostnameAlias + "'",
			action: "Destroy my VM",
			callback: function (_this) {
				return function () {
					_this.deleteVmByHostname(hostnameAlias, function (err) {
						var appStorage;
						if (!KD.showError(err)) {
							new KDNotificationView({
								title: "Successfully destroyed!"
							});
							appStorage = KD.getSingleton("appStorageController").storage("Finder", "1.2");
							return appStorage.unsetKey("mountedVM", function () {
								return warn("couldn't reach to appstorage")
							})
						}
					});
					return modal.destroy()
				}
			}(this)
		}, vmPrefix)
	};
	VirtualizationController.prototype.deleteVmByHostname = function (hostnameAlias, callback, fireEvents) {
		var JVM;
		null == fireEvents && (fireEvents = !0);
		JVM = KD.remote.api.JVM;
		return JVM.removeByHostname(hostnameAlias, function (err) {
			var vmc;
			if (err) return callback(err);
			if (fireEvents) {
				vmc = KD.getSingleton("vmController");
				vmc.emit("VMListChanged");
				vmc.emit("VMDestroyed", hostnameAlias)
			}
			return callback(null)
		})
	};
	VirtualizationController.prototype.remove = function (vm, callback) {
		null == callback && (callback = noop);
		return this.fetchVmInfo(vm, function (_this) {
			return function (err, vmInfo) {
				var message;
				if (!KD.showError(err)) {
					if (vmInfo) {
						if (vmInfo.underMaintenance === !0) {
							message = "Your VM is under maintenance, not allowed to delete.";
							new KDNotificationView({
								title: message
							});
							return callback({
								message: message
							})
						}
						return _this.confirmVmDeletion(vmInfo)
					}
					new KDNotificationView({
						title: "Failed to remove!"
					});
					return callback({
						message: "No such VM!"
					})
				}
			}
		}(this))
	};
	VirtualizationController.prototype.info = function (vm, callback) {
		var _ref;
		"function" == typeof vm && (_ref = [vm, callback], callback = _ref[0], vm = _ref[1]);
		return this._runWrapper("vm.info", vm, function (_this) {
			return function (err, info) {
				err && warn("[VM-" + vm + "]", err);
				if ("UnderMaintenanceError" === (null != err ? err.name : void 0)) {
					info = {
						state: "MAINTENANCE"
					};
					err = null;
					delete _this.vmRegions[vm]
				}
				_this.emit("StateChanged", err, vm, info);
				return "function" == typeof callback ? callback(err, vm, info) : void 0
			}
		}(this))
	};
	VirtualizationController.prototype.fetchRegion = function (vmName, callback) {
		var region;
		return (region = this.vmRegions[vmName]) ? this.utils.defer(function () {
			return callback(region)
		}) : KD.remote.api.JVM.fetchVmRegion(vmName, function (_this) {
			return function (err, region) {
				if (err || !region) {
					err && warn(err);
					return callback("sj")
				}
				_this.vmRegions[vmName] = region;
				return callback(_this.vmRegions[vmName])
			}
		}(this))
	};
	VirtualizationController.prototype.fetchVmName = function (options, callback) {
		return null != options.vmName ? this.utils.defer(function () {
			return callback(null, options.vmName)
		}) : this.fetchDefaultVmName(function (defaultVmName) {
			return null != defaultVmName ? callback(null, defaultVmName) : callback({
				message: "There is no VM for this account.",
				code: 100
			})
		})
	};
	VirtualizationController.prototype.fetchDefaultVm = function (callback) {
		return this.fetchVMs(function (_this) {
			return function (err, vms) {
				return err ? callback(err) : _this.fetchDefaultVmName(function (vmName) {
					var vm;
					return err ? callback(err) : callback(null, function () {
						var _i, _len, _results;
						_results = [];
						for (_i = 0, _len = vms.length; _len > _i; _i++) {
							vm = vms[_i];
							vm.hostnameAlias === vmName && _results.push(vm)
						}
						return _results
					}()[0])
				})
			}
		}(this))
	};
	VirtualizationController.prototype.fetchDefaultVmName = function (callback, force) {
		var currentGroup, entryPoint;
		null == callback && (callback = noop);
		null == force && (force = !1);
		if (this.defaultVmName && !force) return this.utils.defer(function (_this) {
			return function () {
				return callback(_this.defaultVmName)
			}
		}(this));
		entryPoint = KD.config.entryPoint;
		currentGroup = "group" === (null != entryPoint ? entryPoint.type : void 0) ? entryPoint.slug : void 0;
		currentGroup || (currentGroup = KD.defaultSlug);
		return this.fetchVmNames(function (_this) {
			return function (err, vmNames) {
				return err || !vmNames ? callback(null) : KD.remote.api.JVM.fetchDefaultVm(function (err, defaultVmName) {
					var groupVMs, userVMs, vm, vmSort, vms, _i, _j, _len, _len1;
					if ("koding" === currentGroup && defaultVmName) return callback(_this.defaultVmName = defaultVmName);
					vmSort = function (x, y) {
						return x.uid - y.uid
					};
					vms = function () {
						var _i, _len, _results;
						_results = [];
						for (_i = 0, _len = vmNames.length; _len > _i; _i++) {
							vm = vmNames[_i];
							_results.push(this.parseAlias(vm))
						}
						return _results
					}.call(_this);
					userVMs = function () {
						var _i, _len, _results;
						_results = [];
						for (_i = 0, _len = vms.length; _len > _i; _i++) {
							vm = vms[_i];
							"user" === (null != vm ? vm.type : void 0) && _results.push(vm)
						}
						return _results
					}().sort(vmSort);
					groupVMs = function () {
						var _i, _len, _results;
						_results = [];
						for (_i = 0, _len = vms.length; _len > _i; _i++) {
							vm = vms[_i];
							"group" === (null != vm ? vm.type : void 0) && _results.push(vm)
						}
						return _results
					}().sort(vmSort);
					for (_i = 0, _len = userVMs.length; _len > _i; _i++) {
						vm = userVMs[_i];
						if (vm.groupSlug === currentGroup) return callback(_this.defaultVmName = vm.alias)
					}
					for (_j = 0, _len1 = groupVMs.length; _len1 > _j; _j++) {
						vm = groupVMs[_j];
						if (vm.groupSlug === currentGroup) return callback(_this.defaultVmName = vm.alias)
					}
					return callback()
				})
			}
		}(this))
	};
	VirtualizationController.prototype.createGroupVM = function (type, planCode, callback) {
		var defaultVMOptions, group, vmCreateCallback;
		null == type && (type = "user");
		null == callback && (callback = function () {});
		vmCreateCallback = function (err, vm) {
			var vmController;
			vmController = KD.getSingleton("vmController");
			if (err) {
				warn(err);
				return new KDNotificationView({
					title: err.message || "Something bad happened while creating VM"
				})
			}
			vmController.emit("VMListChanged");
			return vmController.showVMDetails(vm)
		};
		defaultVMOptions = {
			planCode: planCode
		};
		group = KD.getSingleton("groupsController").getCurrentGroup();
		return group.createVM({
			type: type,
			planCode: planCode
		}, vmCreateCallback)
	};
	VirtualizationController.prototype.getKite = function (_arg, type) {
		var groupId, hostnameAlias, region;
		region = _arg.region, hostnameAlias = _arg.hostnameAlias, groupId = _arg.groupId;
		null == type && (type = "os");
		if (KD.useNewKites) {
			console.warn("VirtualizationController#getKite called for new kites");
			return KD.singletons.kontrol.kites["os" === type ? "oskite" : type][hostnameAlias]
		}
		return KD.getSingleton("kiteController").getKite("" + type + "-" + region, hostnameAlias, type)
	};
	VirtualizationController.prototype.registerNewKite = function (name, correlationName, kite) {
		var _base;
		null == (_base = this.kites)[name] && (_base[name] = {});
		return this.kites[name][correlationName] = kite
	};
	VirtualizationController.prototype.createNewKite = function (name, vm) {
		var correlationName, groupId, kite, kiteExisted, kontrol, query, region;
		kontrol = KD.getSingleton("kontrol");
		correlationName = vm.hostnameAlias, region = vm.region, groupId = vm.groupId;
		query = {
			name: name,
			correlationName: correlationName,
			region: region,
			groupId: groupId
		};
		kiteExisted = kontrol.hasKite(query);
		kite = kontrol.getKite(query);
		if (!kiteExisted) {
			"oskite" === name && this.listenToVmState(vm, kite);
			this.registerNewKite(name, correlationName, kite)
		}
		return kite
	};
	VirtualizationController.prototype.registerNewKites = function (vms) {
		return Promise.all(vms.map(this.bound("instantiateNewKite")))
	};
	VirtualizationController.prototype.instantiateNewKite = function (vm) {
		return new Promise(function (_this) {
			return function (resolve) {
				var oskite;
				oskite = _this.createNewKite("oskite", vm);
				oskite.on("vmOn", function () {
					return _this.createNewKite("terminal", vm)
				});
				return resolve()
			}
		}(this))
	};
	VirtualizationController.prototype.registerKites = function (vms) {
		return Promise.all(vms.map(this.bound("registerKite")))
	};
	VirtualizationController.prototype.registerKite = function (vm, callback) {
		return new Promise(function (_this) {
			return function (resolve) {
				var alias, kite;
				alias = vm.hostnameAlias;
				kite = _this.getKite(vm, "os");
				_this.kites[alias] = kite;
				_this.listenToVmState(vm, kite);
				return resolve()
			}
		}(this)).nodeify(callback)
	};
	VirtualizationController.prototype.registerTerminalKite = function (vm) {
		return new Promise(function (_this) {
			return function (resolve) {
				var alias;
				alias = vm.hostnameAlias;
				return _this.kites[alias].ready(function () {
					_this.terminalKites[alias] = _this.getKite(vm, "terminal");
					return resolve()
				})
			}
		}(this))
	};
	VirtualizationController.prototype.listenToVmState = function (vm, kite) {
		var alias;
		alias = vm.hostnameAlias;
		kite.on("vm.progress.start", function (_this) {
			return function (update) {
				return _this.emit("vm.progress.start", {
					alias: alias,
					update: update
				})
			}
		}(this));
		kite.on("vm.progress.stop", function (_this) {
			return function (update) {
				return _this.emit("vm.progress.stop", {
					alias: alias,
					update: update
				})
			}
		}(this));
		kite.on("vm.state.info", function (_this) {
			return function (state) {
				return _this.emit("vm.state.info", {
					alias: alias,
					state: state
				})
			}
		}(this));
		return kite.on("vm.progress.error", function (_this) {
			return function (error) {
				return _this.emit("vm.progress.error", {
					alias: alias,
					error: error
				})
			}
		}(this))
	};
	VirtualizationController.prototype.getKiteByVmName = function (vmName) {
		return this.kites[vmName]
	};
	VirtualizationController.prototype.fetchVmNames = function (force, callback) {
		var _ref;
		null == callback && (_ref = [force, callback], callback = _ref[0], force = _ref[1]);
		return this.fetchVMs(force, function (err, vms) {
			var vm;
			return err ? callback(err) : callback(null, function () {
				var _i, _len, _results;
				_results = [];
				for (_i = 0, _len = vms.length; _len > _i; _i++) {
					vm = vms[_i];
					_results.push(vm.hostnameAlias)
				}
				return _results
			}())
		})
	};
	VirtualizationController.prototype.fetchVMs = function (waiting) {
		return function (force, callback) {
			var _ref;
			null == callback && (_ref = [force, callback], callback = _ref[0], force = _ref[1]);
			if (null != callback)
				if (force || !this.vms.length) {
					if (force || !(waiting.push(callback) > 1)) return KD.remote.api.JVM.fetchVmsByContext(function (_this) {
						return function (err, vms) {
							err || (_this.vms = vms);
							return force ? callback(err, vms) : _this.fetchDefaultVmName(function () {
								return _this.handleFetchedVms(vms, function (err) {
									var cb, _i, _len;
									if (err) return callback(err);
									for (_i = 0, _len = waiting.length; _len > _i; _i++) {
										cb = waiting[_i];
										cb(err, vms)
									}
									return waiting = []
								})
							})
						}
					}(this))
				} else this.utils.defer(function (_this) {
					return function () {
						return callback(null, _this.vms)
					}
				}(this))
		}
	}([]);
	VirtualizationController.prototype.getKiteHostname = function (vm) {
		return null == vm.hostKite ? null : vm.hostKite.split("|")[1]
	};
	VirtualizationController.prototype.shouldUseNewKites = function () {
		return new Promise(function (resolve, reject) {
			return KD.remote.api.JKiteStack.fetchInfo(function (err, info) {
				var useNewKites;
				if (info.useWebSockets) KD.useWebSockets = !0;
				else {
					KD.useWebSockets = !1;
					localStorage.disableWebSocket = "true"
				} if (null != KD.useNewKites) return resolve(info.isEnabled && KD.useNewKites);
				if (null != err) return reject(err);
				useNewKites = info.isEnabled && Math.random() <= info.ratio;
				KD.useNewKites = useNewKites;
				localStorage.useNewKites = useNewKites ? "1" : "0";
				useNewKites && KD.singletons.kontrol.reauthenticate();
				return resolve(useNewKites)
			})
		})
	};
	VirtualizationController.prototype.handleFetchedVms = function (vms, callback) {
		var vm, _i, _len;
		for (_i = 0, _len = vms.length; _len > _i; _i++) {
			vm = vms[_i];
			this.vmsInfo[vm.hostnameAlias] = vm
		}
		return this.shouldUseNewKites().then(function (_this) {
			return function (useNewKites) {
				return useNewKites ? _this.registerNewKites(vms) : _this.registerKites(vms).then(function () {
					Promise.map(vms, _this.bound("registerTerminalKite")).then(function () {
						return _this.emit("terminalsReady")
					})
				})
			}
		}(this))["catch"](warn).nodeify(callback)
	};
	VirtualizationController.prototype.fetchGroupVMs = function (force, callback) {
		null == callback && (callback = noop);
		return this.groupVms.length > 0 && !force ? this.utils.defer(function (_this) {
			return function () {
				return callback(null, _this.groupVms)
			}
		}(this)) : KD.remote.api.JVM.fetchVmsByContext(function (_this) {
			return function (err, vms) {
				err || (_this.groupVms = vms);
				return "function" == typeof callback ? callback(err, vms) : void 0
			}
		}(this))
	};
	VirtualizationController.prototype.fetchVMDomains = function (vmName, callback) {
		var domains;
		null == callback && (callback = noop);
		return (domains = this.vmDomains[vmName]) ? this.utils.defer(function () {
			return callback(null, domains)
		}) : KD.remote.api.JVM.fetchDomains(vmName, function (_this) {
			return function (err, domains) {
				null == domains && (domains = []);
				if (err) return callback(err, domains);
				_this.vmDomains[vmName] = domains.sort(function (x, y) {
					return x.length > y.length
				});
				return callback(null, _this.vmDomains[vmName])
			}
		}(this))
	};
	VirtualizationController.prototype.fetchVmInfo = function (name, callback) {
		return name in this.vmsInfo ? KD.utils.defer(function (_this) {
			return function () {
				return callback(null, _this.vmsInfo[name])
			}
		}(this)) : KD.remote.api.JVM.fetchVmInfo(name, callback)
	};
	VirtualizationController.prototype.fetchVmsByName = function (vmName, callback) {
		var JVM;
		JVM = KD.remote.api.JVM;
		return JVM.fetchVmsByName(vmName, function () {
			return function (err, vms) {
				return err ? callback(err) : callback(null, vms)
			}
		}(this))
	};
	VirtualizationController.prototype.resetVMData = function () {
		this.vms = [];
		this.groupVms = [];
		this.defaultVmName = null;
		this.vmDomains = {};
		return this.vmRegions = {}
	};
	VirtualizationController.prototype.fetchTotalVMCount = function (callback) {
		return KD.remote.api.JVM.count(function (err, count) {
			err && warn(err);
			return callback(null, null != count ? count : "0")
		})
	};
	VirtualizationController.prototype.fetchTotalLoC = function (callback) {
		return callback(null, "0")
	};
	VirtualizationController.prototype._cbWrapper = function (vm, callback) {
		return function (_this) {
			return function () {
				var rest;
				rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				return _this.info(vm, "function" == typeof callback ? callback.apply(null, rest) : void 0)
			}
		}(this)
	};
	VirtualizationController.prototype.fetchDiskUsage = function (vmName, callback) {
		var command;
		null == callback && (callback = noop);
		command = "df | grep aufs | awk '{print $2, $3}'";
		return this.run({
			vmName: vmName,
			withArgs: command
		}, function (err, res) {
			var current, max, _ref, _ref1;
			err || !res ? (_ref = [0, 0], max = _ref[0], current = _ref[1]) : (_ref1 = res.trim().split(" "), max = _ref1[0], current = _ref1[1]);
			err && warn(err);
			return callback({
				max: 1024 * parseInt(max, 10),
				current: 1024 * parseInt(current, 10)
			})
		})
	};
	VirtualizationController.prototype.fetchRamUsage = function (vmName, callback) {
		null == callback && (callback = noop);
		return this.info(vmName, function (err, vm, info) {
			var current, max, _ref, _ref1;
			err || "RUNNING" !== info.state ? (_ref = [0, 0], max = _ref[0], current = _ref[1]) : (_ref1 = [info.totalMemoryLimit, info.memoryUsage], max = _ref1[0], current = _ref1[1]);
			err && warn(err);
			return callback({
				max: max,
				current: current
			})
		})
	};
	VirtualizationController.prototype.hasDefaultVM = function (callback) {
		return KD.remote.api.JVM.fetchDefaultVm(callback)
	};
	VirtualizationController.prototype.createNewVM = function (stackId, callback, fireEvent) {
		null == fireEvent && (fireEvent = !0);
		return this.createPaidVM(stackId, function (_this) {
			return function (err) {
				fireEvent && _this.emit("VMListChanged");
				return callback(err)
			}
		}(this), fireEvent)
	};
	VirtualizationController.prototype.showVMDetails = function (vm) {
		var content, modal, url, vmName;
		vmName = vm.hostnameAlias;
		url = "http://" + vm.hostnameAlias;
		content = '<div class="item">\n  <span class="title">Name:</span>\n  <span class="value">' + vmName + '</span>\n</div>\n<div class="item">\n  <span class="title">Hostname:</span>\n  <span class="value">\n    <a target="_new" href="' + url + '">' + url + "</a>\n  </span>\n</div>";
		return modal = new KDModalView({
			title: "Your VM is ready",
			content: "<div class='modalformline'>" + content + "</div>",
			cssClass: "vm-details-modal",
			overlay: !0,
			buttons: {
				OK: {
					title: "OK",
					cssClass: "modal-clean-green",
					callback: function () {
						return function () {
							return modal.destroy()
						}
					}(this)
				}
			}
		})
	};
	VirtualizationController.prototype.createPaidVM = function (stackId, callback, fireEvent) {
		return this.payment.fetchActiveSubscription({
			tags: "vm"
		}, function (_this) {
			return function (err, subscription) {
				if (err) {
					"no subscription" === err.code && _this.showUpgradeModal();
					return callback(err)
				}
				if (!subscription) {
					_this.showUpgradeModal();
					return callback()
				}
				return KD.remote.api.JPaymentPack.one({
					tags: "vm"
				}, function (err, pack) {
					return err ? callback(err) : _this.provisionVm({
						stackId: stackId,
						subscription: subscription,
						productData: {
							pack: pack
						}
					}, function (err) {
						if (!err) return callback(err);
						if ("quota exceeded" === err.message) {
							if ("koding" === KD.getGroup().slug) {
								_this.showUpgradeModal();
								return callback()
							}
							return callback({
								message: "Your group is out of VM quota"
							})
						}
					}, fireEvent)
				})
			}
		}(this))
	};
	VirtualizationController.prototype.showUpgradeModal = function () {
		var modal, upgradeForm;
		modal = new KDModalView({
			title: "Create a new VM",
			cssClass: "create-vm",
			view: upgradeForm = this.payment.createUpgradeForm(),
			height: "auto",
			width: 500,
			showNav: !1,
			overlay: !0
		});
		upgradeForm.on("Cancel", modal.bound("destroy"));
		return modal
	};
	VirtualizationController.prototype.provisionVm = function (_arg, callback, fireEvent) {
		var JVM, pack, payment, paymentMethod, plan, productData, stackId, subscription;
		subscription = _arg.subscription, stackId = _arg.stackId, paymentMethod = _arg.paymentMethod, productData = _arg.productData;
		null == fireEvent && (fireEvent = !0);
		JVM = KD.remote.api.JVM;
		plan = productData.plan, pack = productData.pack;
		payment = KD.getSingleton("paymentController");
		if (!paymentMethod || subscription) return payment.debitSubscription(subscription, pack, function (_this) {
			return function (err, nonce) {
				var notify;
				if (err) return callback(err);
				fireEvent && (notify = new KDNotificationView({
					title: "Creating your VM...",
					overlay: {
						transparent: !1,
						destroyOnClick: !1
					},
					loader: {
						color: "white"
					},
					duration: 12e4
				}));
				return JVM.createVmByNonce(nonce, stackId, function (err, vm) {
					null != notify && notify.destroy();
					if (!KD.showError(err)) {
						if (fireEvent) {
							_this.emit("VMListChanged");
							_this.showVMDetails(vm)
						}
						return callback(null, nonce)
					}
				})
			}
		}(this));
		plan.subscribe(paymentMethod.paymentMethodId, function (_this) {
			return function (err, subscription) {
				return KD.showError(err) ? void 0 : _this.provisionVm({
					subscription: subscription,
					productData: productData,
					stackId: stackId
				}, callback)
			}
		}(this));
		return void 0
	};
	VirtualizationController.prototype.askForApprove = function (command, callback) {
		var button, content, modal;
		switch (command) {
		case "vm.stop":
		case "vm.shutdown":
			content = "<p>Turning off your VM will <b>stop</b> running Terminal\ninstances and all running processes that you have on\nyour VM. Do you want to continue?</p>";
			button = {
				title: "Turn off",
				style: "modal-clean-red"
			};
			break;
		case "vm.reinitialize":
			content = "<p>Re-initializing your VM will <b>reset</b> all of your\nsettings that you've done in root filesystem. This\nprocess will not remove any of your files under your\nhome directory. Do you want to continue?</p>";
			button = {
				title: "Re-initialize",
				style: "modal-clean-red"
			};
			break;
		case "vm.remove":
			content = "<p>Removing this VM will <b>destroy</b> all the data in\nthis VM including all other users in filesystem. <b>Please\nbe careful this process cannot be undone.</b></p>\n\n<p>Do you want to continue?</p>";
			button = {
				title: "Remove VM",
				style: "modal-clean-red"
			};
			break;
		default:
			return callback(!0)
		}
		return modal = new KDModalView({
			title: "Approval required",
			content: "<div class='modalformline'>" + content + "</div>",
			cssClass: "vm-approval",
			height: "auto",
			overlay: !0,
			buttons: {
				Action: {
					title: button.title,
					style: button.style,
					callback: function () {
						modal.destroy();
						return callback(!0)
					}
				},
				Cancel: {
					style: "modal-clean-gray",
					callback: function () {
						modal.destroy();
						return callback(!1)
					}
				}
			}
		})
	};
	VirtualizationController.prototype.askToTurnOn = function (options, callback) {
		var appName, content, modal, state, title, vmName, _ref, _runAppAfterStateChanged;
		"function" == typeof options && (_ref = [callback, options], options = _ref[0], callback = _ref[1]);
		appName = options.appName, vmName = options.vmName, state = options.state;
		title = "Your VM is turned off";
		content = "To " + (appName ? "run" : "do this") + " <b>" + appName + "</b>\nyou need to turn on your VM first, you can do that by\nclicking '<b>Turn ON VM</b>' button below.";
		if (!this.defaultVmName) {
			title = "You don't have any VM";
			content = "To " + (appName ? "use" : "do this") + "\n<b>" + (appName || "") + "</b> you need to have at lease one VM\ncreated, you can do that by clicking '<b>Create Default\nVM</b>' button below."
		}
		if ("MAINTENANCE" === state) {
			title = "Your VM is under maintenance";
			content = "Your VM <b>" + vmName + "</b> is <b>UNDER MAINTENANCE</b> now,\n" + (appName ? "to run <b>" + appName + "</b> app" : void 0) + " please try\nagain later."
		}
		_runAppAfterStateChanged = function (_this) {
			return function (appName, vmName) {
				var params;
				if (appName) {
					vmName && (params = {
						params: {
							vmName: vmName
						}
					});
					return _this.once("StateChanged", function (err, vm, info) {
						return !err && info && "RUNNING" === info.state && vm === vmName ? KD.utils.wait(1200, function () {
							return KD.getSingleton("appManager").open(appName, params)
						}) : void 0
					})
				}
			}
		}(this);
		modal = new KDModalView({
			title: title,
			content: "<div class='modalformline'><p>" + content + "</p></div>",
			height: "auto",
			overlay: !0,
			buttons: {
				"Turn ON VM": {
					style: "modal-clean-green",
					callback: function (_this) {
						return function () {
							_runAppAfterStateChanged(appName, vmName);
							return _this.start(vmName, function () {
								modal.destroy();
								return "function" == typeof callback ? callback() : void 0
							})
						}
					}(this)
				},
				"Create Default VM": {
					style: "modal-clean-green",
					callback: function (_this) {
						return function () {
							_runAppAfterStateChanged(appName);
							_this.createNewVM(callback);
							return modal.destroy()
						}
					}(this)
				},
				Cancel: {
					style: "modal-cancel",
					callback: function () {
						modal.destroy();
						return "function" == typeof callback ? callback({
							cancel: !0
						}) : void 0
					}
				}
			}
		});
		this.defaultVmName ? modal.buttons["Create Default VM"].destroy() : modal.buttons["Turn ON VM"].destroy();
		"MAINTENANCE" === state && modal.setButtons({
			Ok: {
				style: "modal-clean-gray",
				callback: function () {
					modal.destroy();
					return "function" == typeof callback ? callback({
						cancel: !0
					}) : void 0
				}
			}
		}, !0);
		return modal.once("KDModalViewDestroyed", function () {
			return "function" == typeof callback ? callback({
				destroy: !0
			}) : void 0
		})
	};
	VirtualizationController.prototype.fetchVMPlans = function (callback) {
		var JPaymentPlan;
		JPaymentPlan = KD.remote.api.JPaymentPlan;
		this.emit("VMPlansFetchStart");
		return JPaymentPlan.fetchPlans({
			tag: "vm"
		}, function (_this) {
			return function (err, plans) {
				if (err) return warn(err);
				plans && plans.sort(function (a, b) {
					return a.feeAmount - b.feeAmount
				});
				_this.emit("VMPlansFetchEnd");
				return callback(err, plans)
			}
		}(this))
	};
	VirtualizationController.prototype.sanitizeVMPlansForInputs = function (plans) {
		var descriptions, hostTypes;
		descriptions = plans.map(function (plan) {
			return plan.description
		});
		hostTypes = plans.map(function (plan, i) {
			return {
				title: plan.description.title,
				value: i,
				feeAmount: (plan.feeAmount / 100).toFixed(0)
			}
		});
		return {
			descriptions: descriptions,
			hostTypes: hostTypes
		}
	};
	VirtualizationController.prototype.parseAlias = function (alias) {
		var groupSlug, nickname, prefix, rest, result, uid, _i, _j;
		if (/^shared\-[0-9]+/.test(alias)) {
			result = alias.match(/(.*)\.([a-z0-9\-]+)\.kd\.io$/);
			if (result) {
				rest = 3 <= result.length ? __slice.call(result, 0, _i = result.length - 2) : (_i = 0, []), prefix = result[_i++], groupSlug = result[_i++];
				uid = parseInt(prefix.split(/-/)[1], 10);
				return {
					groupSlug: groupSlug,
					prefix: prefix,
					uid: uid,
					type: "group",
					alias: alias
				}
			}
		} else if (/^vm\-[0-9]+/.test(alias)) {
			result = alias.match(/(.*)\.([a-z0-9\-]+)\.([a-z0-9\-]+)\.kd\.io$/);
			if (result) {
				rest = 4 <= result.length ? __slice.call(result, 0, _j = result.length - 3) : (_j = 0, []), prefix = result[_j++], nickname = result[_j++], groupSlug = result[_j++];
				uid = parseInt(prefix.split(/-/)[1], 10);
				return {
					groupSlug: groupSlug,
					prefix: prefix,
					nickname: nickname,
					uid: uid,
					type: "user",
					alias: alias
				}
			}
		}
		return null
	};
	return VirtualizationController
}(KDController);
var ModalAppsListItemView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ModalAppsListItemView = function (_super) {
	function ModalAppsListItemView(options, data) {
		options.cssClass = "topic-item";
		ModalAppsListItemView.__super__.constructor.call(this, options, data);
		this.titleLink = new AppLinkView({
			expandable: !1
		}, data);
		this.titleLink.on("click", function (_this) {
			return function () {
				return _this.getDelegate().emit("CloseTopicsModal")
			}
		}(this));
		this.img = KD.utils.getAppIcon(this.getData(), "modal-app-icon")
	}
	__extends(ModalAppsListItemView, _super);
	JView.mixin(ModalAppsListItemView.prototype);
	ModalAppsListItemView.prototype.pistachio = function () {
		return '<div class="app-title">\n  {{> this.img}}\n  {{> this.titleLink}}\n</div>\n<div class="stats">\n  <p class="installs">\n    <span class="icon"></span>{{#(counts.installed) || 0}} Installs\n  </p>\n  <p class="fers">\n    <span class="icon"></span>{{#(counts.followers) || 0}} Followers\n  </p>\n</div>'
	};
	return ModalAppsListItemView
}(KDListItemView);
KD.config.apps = {
	Activity: {
		style: "/a/css/__social.css?1540",
		script: "/a/js/__social.js?1540",
		identifier: "app-social"
	},
	Members: {
		style: "/a/css/__social.css?1540",
		script: "/a/js/__social.js?1540",
		identifier: "app-social"
	},
	Topics: {
		style: "/a/css/__social.css?1540",
		script: "/a/js/__social.js?1540",
		identifier: "app-social"
	},
	Feeder: {
		style: "/a/css/__app.feeder.css?1540",
		script: "/a/js/__app.feeder.js?1540",
		identifier: "app-feeder"
	},
	Account: {
		style: "/a/css/__payment.css?1540",
		script: "/a/js/__payment.js?1540",
		identifier: "app-payment"
	},
	Login: {
		style: "/a/css/koding.css?1540",
		script: "/a/js/koding.js?1540",
		identifier: "app-koding"
	},
	Apps: {
		style: "/a/css/__social.css?1540",
		script: "/a/js/__social.js?1540",
		identifier: "app-social"
	},
	Kites: {
		style: "/a/css/__app.kites.css?1540",
		script: "/a/js/__app.kites.js?1540",
		identifier: "app-kites"
	},
	Terminal: {
		style: "/a/css/__teamwork.css?1540",
		script: "/a/js/__teamwork.js?1540",
		identifier: "app-teamworkbundle"
	},
	Ace: {
		style: "/a/css/__teamwork.css?1540",
		script: "/a/js/__teamwork.js?1540",
		identifier: "app-teamworkbundle"
	},
	Finder: {
		style: "/a/css/koding.css?1540",
		script: "/a/js/koding.js?1540",
		identifier: "app-koding"
	},
	Viewer: {
		style: "/a/css/__teamwork.css?1540",
		script: "/a/js/__teamwork.js?1540",
		identifier: "app-teamworkbundle"
	},
	Teamwork: {
		style: "/a/css/__teamwork.css?1540",
		script: "/a/js/__teamwork.js?1540",
		identifier: "app-teamworkbundle"
	},
	About: {
		style: "/a/css/__app.about.css?1540",
		script: "/a/js/__app.about.js?1540",
		identifier: "app-about"
	},
	Home: {
		style: "/a/css/__app.home.css?1540",
		script: "/a/js/__app.home.js?1540",
		identifier: "app-home"
	},
	Business: {
		style: "/a/css/__app.business.css?1540",
		script: "/a/js/__app.business.js?1540",
		identifier: "app-business"
	},
	Education: {
		style: "/a/css/__app.education.css?1540",
		script: "/a/js/__app.education.js?1540",
		identifier: "app-education"
	},
	Environments: {
		style: "/a/css/__payment.css?1540",
		script: "/a/js/__payment.js?1540",
		identifier: "app-payment"
	},
	Dashboard: {
		style: "/a/css/__payment.css?1540",
		script: "/a/js/__payment.js?1540",
		identifier: "app-payment"
	},
	Pricing: {
		style: "/a/css/__payment.css?1540",
		script: "/a/js/__payment.js?1540",
		identifier: "app-payment"
	},
	Bugs: {
		style: "/a/css/__social.css?1540",
		script: "/a/js/__social.js?1540",
		identifier: "app-social"
	},
	DevTools: {
		style: "/a/css/__teamwork.css?1540",
		script: "/a/js/__teamwork.js?1540",
		identifier: "app-teamworkbundle"
	}
};
! function () {
	var createContentDisplayHandler, createSectionHandler, getAction, handleRoot, requireLogin, requireLogout, routerReady;
	getAction = function (formName) {
		switch (formName) {
		case "login":
			return "log in";
		case "register":
			return "register"
		}
	};
	requireLogin = function (fn) {
		var router;
		router = KD.singletons.router;
		return KD.isLoggedIn() ? utils.defer(fn) : router.clear()
	};
	requireLogout = function (fn) {
		var router;
		router = KD.singletons.router;
		return KD.isLoggedIn() ? router.clear() : utils.defer(fn)
	};
	handleRoot = function () {
		var display, entryPoint, replaceState, router, _ref;
		if (!location.hash.length) {
			_ref = KD.singletons, display = _ref.display, router = _ref.router;
			entryPoint = KD.config.entryPoint;
			replaceState = !0;
			display.hideAllDisplays();
			return KD.isLoggedIn() ? router.handleRoute(router.userRoute || router.getDefaultRoute(), {
				replaceState: replaceState,
				entryPoint: entryPoint
			}) : router.handleRoute(router.getDefaultRoute(), {
				entryPoint: entryPoint
			})
		}
	};
	routerReady = function (fn) {
		var router;
		router = KD.singletons.router;
		return router ? fn() : KDRouter.on("RouterIsReady", fn)
	};
	createSectionHandler = function (sec) {
		return routerReady(function () {
			return function (_arg) {
				var name, query, router, slug, _ref;
				_ref = _arg.params, name = _ref.name, slug = _ref.slug, query = _arg.query;
				router = KD.singletons.router;
				return router.openSection(slug || sec, name, query)
			}
		})
	};
	createContentDisplayHandler = function (section, passOptions) {
		null == passOptions && (passOptions = !1);
		return function (_arg, models, route) {
			var contentDisplay, name, query, router, slug, _ref;
			_ref = _arg.params, name = _ref.name, slug = _ref.slug, query = _arg.query;
			router = KD.singletons.router;
			route || (route = name);
			contentDisplay = router.openRoutes[route.split("?")[0]];
			if (null != contentDisplay) {
				KD.singleton("display").hideAllDisplays(contentDisplay);
				return contentDisplay.emit("handleQuery", query)
			}
			return null != models ? router.openContent(name, section, models, route, query, passOptions) : router.loadContent(name, section, slug, route, query, passOptions)
		}
	};
	return KD.registerRoutes("KDMainApp", {
		"/": handleRoot,
		"": handleRoot,
		"/R/:username": function (_arg) {
			var username;
			username = _arg.params.username;
			KD.mixpanel("Visit referrer url, success", {
				username: username
			});
			return this.handleRoute(KD.isLoggedIn() ? "/Activity" : "/")
		},
		"/:name?/Logout": function (_arg) {
			var name;
			name = _arg.params.name;
			return requireLogin(function () {
				var mainController;
				mainController = KD.singletons.mainController;
				return mainController.doLogout()
			})
		},
		"/:name?/Topics/:slug": function (_arg) {
			var name, route, slug, _ref;
			_ref = _arg.params, name = _ref.name, slug = _ref.slug;
			route = "/Activity?q=" + slug;
			name && (route = "" + name + "/" + route);
			return this.handleRoute(route)
		},
		"/:slug/:name": function (_arg) {
			var params, query;
			params = _arg.params, query = _arg.query;
			return createContentDisplayHandler("Members").apply(null, arguments)
		},
		"/:name?/Invitation/:inviteCode": function (_arg) {
			var inviteCode, name, _ref;
			_ref = _arg.params, inviteCode = _ref.inviteCode, name = _ref.name;
			return this.handleRoute("/Redeem/" + inviteCode)
		},
		"/:name?/InviteFriends": function () {
			if (KD.isLoggedIn()) {
				this.handleRoute("/Activity", {
					entryPoint: KD.config.entryPoint
				});
				return new ReferrerModal
			}
			return this.handleRoute("/Login")
		},
		"/:name?/RegisterHostKey": KiteHelper.initiateRegistiration,
		"/member/:username": function (_arg) {
			var username;
			username = _arg.params.username;
			return this.handleRoute("/" + username, {
				replaceState: !0
			})
		},
		"/:name?/Unsubscribe/:token/:email/:opt?": function (_arg) {
			var email, opt, router, token, _ref;
			_ref = _arg.params, token = _ref.token, email = _ref.email, opt = _ref.opt;
			router = KD.singletons.router;
			opt = decodeURIComponent(opt);
			email = decodeURIComponent(email);
			token = decodeURIComponent(token);
			return ("email" === opt ? KD.remote.api.JMail : KD.remote.api.JMailNotification).unsubscribeWithId(token, email, opt, function (err, content) {
				var modal, title;
				if (err || !content) {
					title = "An error occured";
					content = "Invalid unsubscribe token provided.";
					log(err)
				} else title = "E-mail settings updated";
				modal = new KDModalView({
					title: title,
					overlay: !0,
					cssClass: "new-kdmodal",
					content: "<div class='modalformline'>" + content + "</div>",
					buttons: {
						Close: {
							style: "modal-clean-gray",
							callback: function () {
								return modal.destroy()
							}
						}
					}
				});
				return router.clear()
			})
		},
		"/:name?/Apps/:username/:app?": function (_arg) {
			var app, name, username, _ref;
			_ref = _arg.params, username = _ref.username, name = _ref.name;
			if (username[0] === username[0].toUpperCase()) {
				app = username;
				username = name;
				return KD.remote.api.JNewApp.one({
					slug: "" + username + "/Apps/" + app
				}, function (err, app) {
					return !err && app ? KodingAppsController.runExternalApp(app, {
						dontUseRouter: !0
					}) : void 0
				})
			}
		},
		"/:name": function () {
			var open;
			open = function (routeInfo, model) {
				var _ref;
				switch (null != model && null != (_ref = model.bongo_) ? _ref.constructorName : void 0) {
				case "JAccount":
					return createContentDisplayHandler("Members")(routeInfo, [model]);
				case "JGroup":
					return createSectionHandler("Activity")(routeInfo, model);
				case "JNewApp":
					return KodingAppsController.runApprovedApp(model, {
						dontUseRouter: !0
					});
				default:
					return this.handleNotFound(routeInfo.params.name)
				}
			};
			return function (routeInfo, state) {
				return null != state ? open.call(this, routeInfo, state) : KD.remote.cacheable(routeInfo.params.name, function (_this) {
					return function (err, models) {
						return null != models ? open.call(_this, routeInfo, models.first) : _this.handleNotFound(routeInfo.params.name)
					}
				}(this))
			}
		}()
	})
}();
! function () {
	var createContentDisplayHandler;
	createContentDisplayHandler = function (section, passOptions) {
		null == passOptions && (passOptions = !1);
		return function (_arg, models, route) {
			var contentDisplay, name, query, router, slug, _ref;
			_ref = _arg.params, name = _ref.name, slug = _ref.slug, query = _arg.query;
			router = KD.singletons.router;
			route || (route = name);
			contentDisplay = router.openRoutes[route.split("?")[0]];
			if (null != contentDisplay) {
				KD.singleton("display").hideAllDisplays(contentDisplay);
				return contentDisplay.emit("handleQuery", query)
			}
			return null != models ? router.openContent(name, section, models, route, query, passOptions) : router.loadContent(name, section, slug, route, query, passOptions)
		}
	};
	return KD.registerRoutes("Activity", {
		"/:name?/Activity/:slug?": function (_arg) {
			var appManager, name, query, router, slug, _ref, _ref1;
			_ref = _arg.params, name = _ref.name, slug = _ref.slug, query = _arg.query;
			_ref1 = KD.singletons, router = _ref1.router, appManager = _ref1.appManager;
			return slug ? createContentDisplayHandler("Activity").apply(null, arguments) : router.openSection("Activity", name, query)
		}
	})
}();
! function () {
	var handler;
	handler = function (callback) {
		var appManager, _ref;
		if (KD.isLoggedIn()) {
			appManager = KD.singleton("appManager");
			return "Account" === (null != (_ref = appManager.getFrontApp()) ? _ref.getOption("name") : void 0) ? callback(appManager.getFrontApp()) : appManager.open("Account", callback)
		}
		return KD.singletons.router.handleRoute("/")
	};
	return KD.registerRoutes("Account", {
		"/:name?/Account": function () {
			return KD.singletons.router.handleRoute("/Account/Profile")
		},
		"/:name?/Account/:section": function (_arg) {
			var section;
			section = _arg.params.section;
			return handler(function (app) {
				return app.openSection(section)
			})
		},
		"/:name?/Account/Referrer": function () {
			return KD.singletons.router.handleRoute("/")
		}
	})
}();
! function () {
	var handleFinishRegistration, handleRecovery, handleRedeemRoute, handleResetRoute, handleVerifyRoute, handler;
	handler = function (callback) {
		return function () {
			return KD.isLoggedIn() ? KD.getSingleton("router").handleRoute("/Activity") : KD.singleton("appManager").open("Login", function (app) {
				return callback(app)
			})
		}
	};
	handleResetRoute = function (_arg) {
		var token;
		token = _arg.params.token;
		return KD.singleton("appManager").open("Login", function (app) {
			if (KD.isLoggedIn()) return KD.remote.api.JUser.fetchUser(function (err, user) {
				return KD.getSingleton("router").handleRoute(user && "valid" === user.passwordStatus ? "/Activity" : "/Account/Profile?focus=password&token=" + token)
			});
			app.getView().setCustomDataToForm("reset", {
				recoveryToken: token
			});
			return app.getView().animateToForm("reset")
		})
	};
	handleVerifyRoute = function (_arg) {
		var router, token;
		token = _arg.params.token;
		router = KD.getSingleton("router");
		return token ? KD.singleton("appManager").open("Login", function () {
			return KD.remote.api.JPasswordRecovery.validate(token, function () {
				return function (err, isValid) {
					if (err) return KD.notify_(err.message);
					if (isValid) {
						KD.notify_("Thanks for confirming your email address");
						return router.handleRoute("/Login")
					}
					KD.notify_("Token is not valid");
					return router.handleRoute("/Login")
				}
			}(this))
		}) : router.handleRoute("/Login")
	};
	handleRedeemRoute = function (_arg) {
		var name, token, _ref;
		_ref = _arg.params, name = _ref.name, token = _ref.token;
		token = decodeURIComponent(token);
		return KD.remote.api.JInvitation.byCode(token, function (err, invite) {
			var _ref1;
			return err ? callback(err) : KD.isLoggedIn() ? KD.remote.cacheable(invite.group, function (err, _arg1) {
				var group;
				group = _arg1[0];
				return group.redeemInvitation(token, function (err) {
					if (err) {
						KD.notify_(err.message || err);
						return window.location.href = "/"
					}
					new KDNotificationView({
						title: "Success!",
						type: "tray"
					});
					KD.getSingleton("router").handleRoute("/" + group.slug);
					return KD.getSingleton("mainController").accountChanged(KD.whoami())
				})
			}) : err || null == invite || "active" !== (_ref1 = invite.status) && "sent" !== _ref1 ? KD.singleton("appManager").open("Login", function (app) {
				new KDNotificationView({
					title: "Invalid invitation code!"
				});
				return app.getView().animateToForm("login")
			}) : KD.singleton("appManager").open("Login", function (app) {
				app.getView().animateToForm("login");
				return app.headBannerShowInvitation(invite)
			})
		})
	};
	handleFinishRegistration = function (_arg) {
		var token;
		token = _arg.params.token;
		return KD.singleton("appManager").open("Login", function (app) {
			return KD.isLoggedIn() ? void 0 : app.prepareFinishRegistrationForm(token)
		})
	};
	handleRecovery = function () {
		return KD.singleton("appManager").open("Login", function (app) {
			return app.getView().animateToForm("recover")
		})
	};
	return KD.registerRoutes("Login", {
		"/:name?/Login/:token?": handler(function (app) {
			return app.getView().animateToForm("login")
		}),
		"/:name?/Redeem": handler(function (app) {
			return app.getView().animateToForm("redeem")
		}),
		"/:name?/Register": handler(function (app) {
			return app.getView().animateToForm("register")
		}),
		"/:name?/Register/:token": handleFinishRegistration,
		"/:name?/Recover": handleRecovery,
		"/:name?/Reset": handler(function (app) {
			return app.getView().animateToForm("reset")
		}),
		"/:name?/Reset/:token": handleResetRoute,
		"/:name?/Confirm/:token": handleResetRoute,
		"/:name?/Verify/:token?": handleVerifyRoute,
		"/:name?/Redeem/:token": handleRedeemRoute,
		"/:name?/ResendToken": handler(function (app) {
			return app.getView().animateToForm("resendEmail")
		})
	})
}();
! function () {
	var handler;
	handler = function (callback) {
		return KD.singleton("appManager").open("Apps", callback)
	};
	return KD.registerRoutes("Apps", {
		"/:name?/Apps": function (_arg) {
			var params, query;
			params = _arg.params, query = _arg.query;
			return handler(function (app) {
				return app.handleQuery(query)
			})
		},
		"/:name?/Apps/:username/:app?": function (route) {
			var username;
			username = route.params.username;
			return username[0] !== username[0].toUpperCase() ? handler(function (app) {
				return app.handleRoute(route)
			}) : void 0
		}
	})
}();
! function () {
	return KD.registerRoutes("Terminal", {
		"/:name?/Terminal": function (_arg) {
			var name, query, router, _ref;
			_ref = _arg.params, name = _ref.name, query = _arg.query;
			router = KD.getSingleton("router");
			return router.openSection("Terminal", name, query)
		}
	})
}();
! function () {
	return KD.registerRoutes("Ace", {
		"/:name?/Ace": function (_arg) {
			var name, query, router, _ref;
			_ref = _arg.params, name = _ref.name, query = _arg.query;
			router = KD.getSingleton("router");
			return router.openSection("Ace", name, query)
		}
	})
}();
! function () {
	var handler;
	handler = function (group, callback) {
		return KD.getSingleton("groupsController").ready(function () {
			return KD.singleton("appManager").open("Dashboard", callback)
		})
	};
	return KD.registerRoutes("Dashboard", {
		"/:name?/Dashboard": function (_arg) {
			var name, section, _ref;
			_ref = _arg.params, section = _ref.section, name = _ref.name;
			return handler(name, function (app) {
				return app.loadSection({
					title: "Settings"
				})
			})
		},
		"/:name?/Dashboard/:section": function (_arg) {
			var name, section, _ref;
			_ref = _arg.params, section = _ref.section, name = _ref.name;
			return handler(name, function (app) {
				return app.loadSection({
					title: decodeURIComponent(section)
				})
			})
		}
	})
}();
! function () {
	var handler;
	handler = function (callback) {
		return KD.singleton("appManager").open("Pricing", callback)
	};
	return KD.registerRoutes("Pricing", {
		"/:name?/Pricing": function () {
			return KD.getSingleton("router").handleRoute("/Pricing/Developer", {
				replaceState: !0
			})
		},
		"/:name?/Pricing/:section": function (_arg) {
			var section;
			section = _arg.params.section;
			return handler(function (app) {
				return app.getView().productForm.showSection(section)
			})
		},
		"/:name?/Pricing/CreateGroup": function () {
			return KD.remote.api.JGroupPlan.hasGroupCredit(function (err, hasCredit) {
				return hasCredit ? handler(function (app) {
					return app.getView().showGroupForm()
				}) : KD.getSingleton("router").handleRoute("/Pricing/Team", {
					replaceState: !0
				})
			})
		}
	})
}();
var Status, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
Status = function (_super) {
	function Status() {
		Status.__super__.constructor.apply(this, arguments);
		this.registerSingleton("status", this);
		this.state = NOTSTARTED;
		this.connectionState = DOWN;
		this.remote = KD.remote;
		this.remote.on("connected", this.bound("connected"));
		this.remote.on("disconnected", this.bound("disconnected"));
		this.remote.on("sessionTokenChanged", this.bound("sessionTokenChanged"));
		this.remote.on("loggedInStateChanged", this.bound("loggedInStateChanged"))
	}
	var CONNECTED, DISCONNECTED, DOWN, NOTSTARTED, RECONNECTED, UP, _ref, _ref1;
	__extends(Status, _super);
	_ref = [1, 2, 3, 4], NOTSTARTED = _ref[0], CONNECTED = _ref[1], RECONNECTED = _ref[2], DISCONNECTED = _ref[3];
	_ref1 = [1, 2, 3], NOTSTARTED = _ref1[0], UP = _ref1[1], DOWN = _ref1[2];
	Status.prototype.resetLocals = function () {
		return delete this.disconnectOptions
	};
	Status.prototype.connect = function () {
		return this.remote.connect()
	};
	Status.prototype.disconnect = function (options) {
		var autoReconnect;
		null == options && (options = {});
		"boolean" == typeof options && (options = {
			autoReconnect: options
		});
		log("status", options);
		autoReconnect = options.autoReconnect;
		this.remote.disconnect(autoReconnect);
		this.disconnectOptions = options;
		return this.disconnected()
	};
	Status.prototype.connected = function () {
		this.connectionState = UP;
		if (this.state === NOTSTARTED) {
			this.state = CONNECTED;
			return this.emit("connected")
		}
		this.state = RECONNECTED;
		this.emit("reconnected", this.disconnectOptions);
		this.startPingingKites();
		return this.resetLocals()
	};
	Status.prototype.startPingingKites = function () {
		return this.eachKite(function (channel) {
			return channel.setStartPinging()
		})
	};
	Status.prototype.disconnected = function () {
		if (this.connectionState === DOWN) return "already disconnected";
		this.stopPingingKites();
		this.connectionState = DOWN;
		this.state = DISCONNECTED;
		return this.emit("disconnected", this.disconnectOptions)
	};
	Status.prototype.stopPingingKites = function () {
		return this.eachKite(function (channel) {
			return channel.setStopPinging()
		})
	};
	Status.prototype.eachKite = function (callback) {
		var channel, channelName, kiteChannels, _results;
		kiteChannels = KD.getSingleton("kiteController").channels;
		_results = [];
		for (channelName in kiteChannels)
			if (__hasProp.call(kiteChannels, channelName)) {
				channel = kiteChannels[channelName];
				_results.push(callback(channel))
			}
		return _results
	};
	Status.prototype.internetUp = function () {
		return this.connectionState === DOWN ? this.connected() : void 0
	};
	Status.prototype.internetDown = function () {
		return this.connectionState === UP ? this.disconnect({
			autoReconnect: !0,
			reason: "internetDown"
		}) : void 0
	};
	Status.prototype.loggedInStateChanged = function (account) {
		return this.emit("bongoConnected", account)
	};
	Status.prototype.registerBongoAndBroker = function () {
		var bongo, broker, monitorItems;
		bongo = KD.remote;
		broker = KD.remote.mq;
		monitorItems = KD.getSingleton("monitorItems");
		return monitorItems.register({
			bongo: bongo,
			broker: broker
		})
	};
	Status.prototype.registerKites = function () {
		var kite, monitorItems;
		monitorItems = KD.getSingleton("monitorItems");
		kite = KD.getSingleton("kiteController");
		kite.on("channelAdded", function (channel, name) {
			monitorItems.getItems()[name] = channel;
			return channel.on("unresponsive", function () {
				return KD.troubleshoot(!1)
			})
		});
		return kite.on("channelDeleted", function (channel, name) {
			return delete monitorItems.getItems()[name]
		})
	};
	Status.prototype.sessionTokenChanged = function (token) {
		return this.emit("sessionTokenChanged", token)
	};
	return Status
}(KDController);
! function () {
	var currentNotif, destroyCurrentNotif, firstLoad, mainController, modals, showNotif, smallDisconnectedNotif, status;
	status = new Status;
	mainController = new MainController;
	currentNotif = null;
	firstLoad = !0;
	mainController.tempStorage = {};
	status.on("bongoConnected", function (account) {
		KD.socketConnected();
		mainController.accountChanged(account, firstLoad);
		return firstLoad = !1
	});
	status.on("sessionTokenChanged", function () {});
	status.on("connected", function () {
		destroyCurrentNotif();
		return log("kd remote connected")
	});
	status.on("reconnected", function (options) {
		null == options && (options = {});
		destroyCurrentNotif();
		return log("kd remote re-connected")
	});
	status.on("disconnected", function (options) {
		null == options && (options = {});
		return log("kd remote disconnected")
	});
	KD.remote.connect();
	KD.exportKDFramework();
	smallDisconnectedNotif = function () {
		return currentNotif = new KDNotificationView({
			title: "Looks like your Internet Connection is down",
			type: "tray",
			closeManually: !0,
			content: "<p>Koding will continue trying to reconnect but while your connection is down, <br> no changes you make will be saved back to your VM. Please save your work locally as well.</p>",
			duration: 0
		})
	};
	modals = {
		small: {
			disconnected: smallDisconnectedNotif
		}
	};
	showNotif = function (size, state) {
		var modal;
		destroyCurrentNotif();
		modal = modals[size][state];
		return "function" == typeof modal ? modal() : void 0
	};
	destroyCurrentNotif = function () {
		null != currentNotif && currentNotif.destroy();
		return currentNotif = null
	};
	if (null != window.navigator.onLine) return KD.utils.repeat(1e4, function () {
		if (window.navigator.onLine) {
			if (currentNotif) return destroyCurrentNotif()
		} else if (!currentNotif) return showNotif("small", "disconnected")
	});
	window.connectionCheckerReponse = function () {};
	return KD.utils.repeat(3e4, function () {
		var item;
		item = new ConnectionChecker({
			jsonp: "connectionCheckerReponse",
			crossDomain: !0,
			fail: function () {
				return currentNotif ? void 0 : showNotif("small", "disconnected")
			}
		}, "https://s3.amazonaws.com/koding-ping/ping.json");
		return item.ping(function () {
			return currentNotif ? destroyCurrentNotif() : void 0
		})
	})
}();
KD.logToExternal = function () {
	console.warn("Rollbar is temporarily disabled")
};
KD.logToExternalWithTime = function (name, options) {
	return KD.troubleshoot(function (times) {
		return KD.logToExternal("" + name + " timed out", {
			options: options,
			pings: times,
			protocol: KD.remote.mq.ws.protocol
		})
	})
};
var __slice = [].slice;
KD.config.logToExternal && ! function () {
	return KD.getSingleton("mainController").on("AccountChanged", function (account) {
		return KD.isLoggedIn() && account && analytics ? account.fetchEmail(function (err, email) {
			var createdAt, firstName, lastName, meta, nickname, profile, type;
			err && console.log(err);
			type = account.type, meta = account.meta, profile = account.profile;
			createdAt = meta.createdAt;
			firstName = profile.firstName, lastName = profile.lastName, nickname = profile.nickname;
			return analytics.identify(nickname, {
				$username: nickname,
				$first_name: firstName,
				$last_name: lastName,
				$email: email,
				$created: createdAt,
				Status: type,
				Randomizer: KD.utils.getRandomNumber(4)
			})
		}) : void 0
	})
}();
KD.mixpanel = function () {
	var args, me;
	args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	if (analytics && KD.config.logToExternal) {
		args.length < 2 && args.push({});
		me = KD.whoami();
		if (me) {
			KD.gaEvent(args[0]);
			return me.fetchEmail(function (err, email) {
				err && console.log(err);
				args[1].username = me.profile.nickname;
				args[1].email = email;
				return analytics.track.apply(analytics, args)
			})
		}
	}
};
KD.mixpanel.alias = function () {
	var args;
	args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	return analytics && KD.config.logToExternal ? analytics.alias.apply(analytics, args) : void 0
};
var __hasProp = {}.hasOwnProperty,
	__slice = [].slice;
! function () {
	return KD.singleton("router").on("RouteInfoHandled", function (argsForMixpanel) {
		var _, _ref;
		KD.gaPageView(argsForMixpanel.path);
		_ref = argsForMixpanel.query;
		for (_ in _ref)
			if (__hasProp.call(_ref, _)) {
				KD.mixpanel("Visit page, success", argsForMixpanel);
				break
			}
		return KD.singletons.mainController.ready(function () {
			var _ref1, _ref2, _ref3;
			argsForMixpanel.username = null != (_ref1 = KD.whoami()) && null != (_ref2 = _ref1.profile) ? _ref2.nickname : void 0;
			argsForMixpanel.userAgent = window.navigator.userAgent;
			argsForMixpanel.protocol = KD.remote.mq.ws.protocol;
			return KD.config.logToInternal && null != (_ref3 = KD.remoteLog) ? _ref3.api.JPageHit.create(argsForMixpanel, function () {}) : void 0
		})
	})
}();
! function () {
	var gaHeartbeat, gaSend, idleUserDetector, lastGAMessage, threshold, userIdle;
	lastGAMessage = null;
	userIdle = !1;
	threshold = KD.config.troubleshoot.idleTime;
	idleUserDetector = new IdleUserDetector({
		threshold: threshold
	});
	idleUserDetector.on("userIdle", function () {
		return userIdle = !0
	});
	idleUserDetector.on("userBack", function () {
		return gaHeartbeat()
	});
	KD.gaPageView = function () {
		var args;
		args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
		return gaSend.apply(null, ["pageview"].concat(__slice.call(args)))
	};
	gaHeartbeat = function () {
		return KD.gaEvent("Heartbeat")
	};
	KD.gaEvent = function () {
		var args;
		args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
		return gaSend.apply(null, ["event"].concat(__slice.call(args)))
	};
	gaSend = function () {
		var args;
		args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
		if (ga && KD.config.logToExternal) {
			lastGAMessage = new Date;
			return ga.apply(null, ["send"].concat(__slice.call(args)))
		}
	};
	return setInterval(function () {
		return new Date - lastGAMessage > threshold && !userIdle ? gaHeartbeat() : void 0
	}, threshold)
}();
var ErrorLog;
ErrorLog = function () {
	function ErrorLog() {}
	ErrorLog.create = function () {
		var idle, idleUserDetector;
		idle = !1;
		idleUserDetector = new IdleUserDetector;
		idleUserDetector.on("userIdle", function () {
			return idle = !0
		});
		idleUserDetector.on("userBack", function () {
			return idle = !1
		});
		return KD.utils.throttle(500, function (error, params) {
			var codeVersion, osVersion, protocol, terminalVersion, userAgent, _ref, _ref1, _ref2, _ref3;
			null == params && (params = {});
			if (KD.config.logToInternal) {
				_ref = KD.config, _ref1 = _ref.kites, _ref2 = _ref1.os, osVersion = _ref2.version, _ref3 = _ref1.terminal, terminalVersion = _ref3.version, codeVersion = _ref.version;
				userAgent = window.navigator.userAgent;
				protocol = KD.remote.mq.ws.protocol;
				error = $.extend({
					error: error,
					terminalVersion: terminalVersion,
					codeVersion: codeVersion,
					userAgent: userAgent,
					idle: idle,
					protocol: protocol,
					useNewKites: KD.useNewKites,
					osKiteVersion: osVersion
				}, params);
				return KD.remoteLog.api.JErrorLog.create(error, function () {})
			}
		})
	}();
	return ErrorLog
}();
var Metric;
Metric = function () {
	function Metric() {}
	Metric.create = KD.utils.throttle(500, function (metric, params) {
		var userAgent;
		null == params && (params = {});
		if (KD.config.logToInternal) {
			userAgent = window.navigator.userAgent;
			metric = $.extend({
				metric: metric,
				userAgent: userAgent
			}, params);
			return KD.remoteLog.api.JMetric.create(metric, function () {})
		}
	});
	return Metric
}();
var FinderController, VMListItem, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
FinderController = function (_super) {
	function FinderController(options, data) {
		options.appInfo = {
			name: "Finder"
		};
		FinderController.__super__.constructor.call(this, options, data)
	}
	__extends(FinderController, _super);
	KD.registerAppClass(FinderController, {
		name: "Finder",
		background: !0
	});
	FinderController.prototype.createFileFromPath = function () {
		return FSHelper.createFileFromPath.apply(FSHelper, arguments)
	};
	FinderController.prototype.create = function (options) {
		null == options && (options = {});
		null == options.useStorage && (options.useStorage = !0);
		null == options.addOrphansToRoot && (options.addOrphansToRoot = !1);
		null == options.delegate && (options.delegate = this);
		this.controller = new NFinderController(options);
		this.controller.getView().addSubView(this.getAppTitleView());
		this.controller.getView().addSubView(this.getUploader());
		this.controller.getView().addSubView(this.getMountVMButton());
		return this.controller
	};
	FinderController.prototype.getAppTitleView = function () {
		return new KDCustomHTMLView({
			cssClass: "app-header",
			partial: "Ace Editor"
		})
	};
	FinderController.prototype.getMountVMButton = function () {
		return new KDButtonView({
			title: "Mount other VMs",
			cssClass: "finder-mountvm clean-gray",
			callback: this.bound("showMountVMModal")
		})
	};
	FinderController.prototype.getUploader = function () {
		var treeController;
		this.uploaderPlaceholder = new KDView({
			domId: "finder-dnduploader",
			cssClass: "hidden"
		});
		this.uploaderPlaceholder.addSubView(this.uploader = new DNDUploader({
			hoverDetect: !1,
			delegate: this
		}));
		treeController = this.controller.treeController;
		treeController.on("dragEnter", this.bound("onDrag"));
		treeController.on("dragOver", this.bound("onDrag"));
		this.uploader.on("dragleave", function (_this) {
			return function () {
				return _this.uploaderPlaceholder.hide()
			}
		}(this)).on("drop", function (_this) {
			return function () {
				return _this.uploaderPlaceholder.hide()
			}
		}(this)).on("uploadProgress", function (_arg) {
			var file, filePath, percent, _ref;
			file = _arg.file, percent = _arg.percent;
			filePath = "[" + file.vmName + "]" + file.path;
			return null != (_ref = treeController.nodes[filePath]) ? _ref.showProgressView(percent) : void 0
		}).on("uploadComplete", function (_this) {
			return function (_arg) {
				var parentPath;
				parentPath = _arg.parentPath;
				return _this.controller.expandFolders(FSHelper.getPathHierarchy(parentPath))
			}
		}(this)).on("cancel", function (_this) {
			return function () {
				_this.uploader.setPath();
				return _this.uploaderPlaceholder.hide()
			}
		}(this));
		return this.uploaderPlaceholder
	};
	FinderController.prototype.onDrag = function () {
		if (!this.controller.treeController.internalDragging) {
			this.uploaderPlaceholder.show();
			return this.uploader.unsetClass("hover")
		}
	};
	FinderController.prototype.showMountVMModal = function () {
		var list, modal, vmController, vmListController;
		modal = new KDModalView({
			width: 620,
			cssClass: "modal-with-text mount-vm",
			title: "Mount VMs",
			overlay: !0
		});
		vmListController = new KDListViewController({
			view: list = new KDListView({
				itemClass: VMListItem,
				type: "vmlist"
			})
		});
		vmController = KD.singletons.vmController;
		list.on("VmStateChanged", function (_this) {
			return function (options) {
				return vmController.fetchVmInfo(options.hostnameAlias, function (err, info) {
					return err ? KD.showError(err) : options.state ? _this.controller.mountVm(info) : _this.controller.unmountVm(info.hostnameAlias)
				})
			}
		}(this));
		list.once("viewAppended", function () {
			return function () {
				vmListController.showLazyLoader();
				return vmController.fetchVMs(function (err, vms) {
					vmListController.hideLazyLoader();
					return err ? KD.showError(err) : vmListController.instantiateListItems(vms)
				})
			}
		}(this));
		return modal.addSubView(vmListController.getView())
	};
	return FinderController
}(KDController);
VMListItem = function (_super) {
	function VMListItem(options, data) {
		null == options && (options = {});
		VMListItem.__super__.constructor.call(this, options, data)
	}
	__extends(VMListItem, _super);
	VMListItem.prototype.viewAppended = function () {
		var hostnameAlias, loader;
		this.addSubView(loader = new KDLoaderView({
			showLoader: !0
		}));
		hostnameAlias = this.getData().hostnameAlias;
		return KD.singletons.vmController.info(hostnameAlias, function (_this) {
			return function (err, name, info) {
				var vmLabel, vmSwitch;
				loader.hide();
				if (err) return KD.showError(err);
				_this.addSubView(vmLabel = new KDLabelView({
					title: hostnameAlias
				}));
				return _this.addSubView(vmSwitch = new KodingSwitch({
					cssClass: "dark",
					defaultValue: "RUNNING" === info.state,
					callback: function (state) {
						return _this.getDelegate().emit("VmStateChanged", {
							state: state,
							hostnameAlias: hostnameAlias
						})
					}
				}))
			}
		}(this))
	};
	return VMListItem
}(KDListItemView);

var DNDUploader, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
DNDUploader = function (_super) {
	function DNDUploader(options, data) {
		null == options && (options = {});
		options.cssClass = KD.utils.curry("file-droparea", options.cssClass);
		options.bind = "dragenter dragover dragleave dragend drop";
		null == options.hoverDetect && (options.hoverDetect = !0);
		null == options.uploadToVM && (options.uploadToVM = !0);
		options.defaultPath || (options.defaultPath = "/home/" + KD.nick() + "/Uploads");
		DNDUploader.__super__.constructor.call(this, options, data);
		this.reset();
		options.path && this.setPath(options.path);
		if (options.hoverDetect) {
			this.on("dragenter", function (_this) {
				return function () {
					return _this.setClass("hover")
				}
			}(this));
			this.on("dragover", function (_this) {
				return function () {
					return _this.setClass("hover")
				}
			}(this));
			this.on("dragleave", function (_this) {
				return function () {
					return _this.unsetClass("hover")
				}
			}(this));
			this.on("drop", function (_this) {
				return function () {
					return _this.unsetClass("hover")
				}
			}(this))
		}
		this.on("uploadFile", function (_this) {
			return function (fsFile, percent) {
				return _this.emit("uploadProgress", {
					file: fsFile,
					percent: percent
				})
			}
		}(this));
		this.on("uploadStart", function (_this) {
			return function (fsFile) {
				var filePath, parentPath;
				filePath = "[" + fsFile.vmName + "]" + fsFile.path;
				parentPath = "[" + fsFile.vmName + "]" + fsFile.parentPath;
				return fsFile.save("", function () {
					return _this.emit("uploadComplete", {
						filePath: filePath,
						parentPath: parentPath
					})
				})
			}
		}(this))
	}
	__extends(DNDUploader, _super);
	DNDUploader.prototype.viewAppended = function () {
		return DNDUploader.__super__.viewAppended.apply(this, arguments)
	};
	DNDUploader.prototype.reset = function () {
		var defaultPath, title, uploadToVM, _ref;
		_ref = this.getOptions(), uploadToVM = _ref.uploadToVM, defaultPath = _ref.defaultPath, title = _ref.title;
		this.setPath();
		this.updatePartial('<div class="file-drop">\n  ' + (title || "Drop files here!") + "\n  <small>" + (uploadToVM ? defaultPath : "") + "</small>\n</div>");
		return this._uploaded = {}
	};
	DNDUploader.prototype.drop = function (event) {
		var entry, files, item, items, _i, _len, _ref, _ref1, _results;
		DNDUploader.__super__.drop.apply(this, arguments);
		_ref = event.originalEvent.dataTransfer, files = _ref.files, items = _ref.items;
		files.length >= 20 && KD.notify_("Too many files to transfer!<br>\nArchive your files and try again.", "error", "Max 20 files allowed to upload at once.\nYou can archive your files and try again.");
		if (null != items && "function" == typeof items.item && null != (_ref1 = items.item(0)) ? _ref1.webkitGetAsEntry : void 0) {
			_results = [];
			for (_i = 0, _len = items.length; _len > _i; _i++) {
				item = items[_i];
				entry = item.webkitGetAsEntry();
				_results.push(entry.isDirectory ? this.walkDirectory(entry.filesystem.root, function (_this) {
					return function (file) {
						return _this.uploadFiles([file], event)
					}
				}(this), function (_this) {
					return function () {
						return _this.uploadFiles(files, event)
					}
				}(this)) : entry.isFile ? entry.file(function (_this) {
					return function (file) {
						return _this.uploadFiles([file], event)
					}
				}(this)) : void 0)
			}
			return _results
		}
		return this.uploadFiles(files, event)
	};
	DNDUploader.prototype.uploadFiles = function (files, event) {
		var basename, file, fsFile, index, internalData, item, lastFile, lastItem, multipleItems, reader, sizeInMb, _i, _j, _len, _len1, _results, _results1;
		this._uploaded || (this._uploaded = {});
		if (null != files ? files.length : void 0) {
			lastFile = files.last;
			_results = [];
			for (index = _i = 0, _len = files.length; _len > _i; index = ++_i) {
				file = files[index];
				sizeInMb = file.size / 1024 / 1024;
				if (sizeInMb > 100 && this.getOptions().uploadToVM) KD.notify_("Too big file to upload.", "error", "Max 100MB allowed per file.");
				else {
					reader = new FileReader;
					reader.onloadend = function (_this) {
						return function (file) {
							return function (readEvent) {
								var fileName, fsFile;
								fileName = file.fileName || file.name;
								if (file.relativePath) {
									if (_this._uploaded[file.relativePath + fileName]) return;
									_this._uploaded[file.relativePath + fileName] = !0
								}
								_this.getOptions().uploadToVM && (fsFile = _this.upload(fileName, readEvent.target.result, file.relativePath));
								_this.emit("dropFile", {
									origin: "external",
									filename: fileName,
									path: file.relativePath || !1,
									instance: fsFile,
									content: readEvent.target.result,
									isLast: file === lastFile
								}, event, readEvent);
								return file === lastFile ? _this.reset() : void 0
							}
						}
					}(this)(files[index]);
					_results.push(reader.readAsBinaryString(file))
				}
			}
			return _results
		}
		internalData = event.originalEvent.dataTransfer.getData("Text");
		if (internalData) {
			multipleItems = internalData.split(",");
			lastItem = multipleItems.last;
			_results1 = [];
			for (_j = 0, _len1 = multipleItems.length; _len1 > _j; _j++) {
				item = multipleItems[_j];
				basename = KD.getPathInfo(item).basename;
				fsFile = FSHelper.createFileFromPath(item);
				this.emit("dropFile", {
					origin: "internal",
					filename: basename,
					instance: fsFile,
					content: null,
					isLast: item === lastItem
				}, event, !1);
				_results1.push(item === lastItem ? this.reset() : void 0)
			}
			return _results1
		}
	};
	DNDUploader.prototype.walkDirectory = function (dirEntry, callback, error) {
		var dirReader, relative;
		dirReader = dirEntry.createReader();
		relative = FSHelper.convertToRelative(dirEntry.fullPath);
		return dirReader.readEntries(function (_this) {
			return function (entries) {
				var entry, _i, _len, _results;
				_results = [];
				for (_i = 0, _len = entries.length; _len > _i; _i++) {
					entry = entries[_i];
					_results.push(entry.isFile ? entry.file(function (file) {
						file.relativePath = relative + file.name;
						return callback(file)
					}) : _this.walkDirectory(entry, callback, error))
				}
				return _results
			}
		}(this), error)
	};
	DNDUploader.prototype.setPath = function (path) {
		var title, uploadToVM, _ref;
		this.path = null != path ? path : this.getOptions().defaultPath;
		_ref = this.getOptions(), uploadToVM = _ref.uploadToVM, title = _ref.title;
		this.updatePartial('<div class="file-drop">\n  ' + (title || "Drop files here!") + "\n  <small>" + (uploadToVM ? FSHelper.getVMNameFromPath(this.path) || "" : "") + "</small>\n  <small>" + (uploadToVM ? FSHelper.plainPath(this.path) : "") + "</small>\n</div>");
		this.showCancel();
		return uploadToVM && this.finder ? this.finder.expandFolders(FSHelper.getPathHierarchy(this.path)) : void 0
	};
	DNDUploader.prototype.showCancel = function () {
		return this.addSubView(new KDCustomHTMLView({
			tagName: "a",
			partial: "cancel",
			cssClass: "cancel",
			attributes: {
				href: "#"
			},
			click: function (_this) {
				return function () {
					return _this.emit("cancel")
				}
			}(this)
		}))
	};
	DNDUploader.prototype.saveFile = function (fsFile, data) {
		this.emit("uploadStart", fsFile);
		return fsFile.saveBinary(data, function (_this) {
			return function (err, res, progress) {
				progress || (progress = res);
				return err ? void 0 : res.finished ? _this.emit("uploadEnd", fsFile) : res.abort ? _this.emit("uploadAbort", fsFile) : _this.emit("uploadFile", fsFile, progress.percent)
			}
		}(this))
	};
	DNDUploader.prototype.upload = function (fileName, contents, relativePath) {
		var folder, fsFileItem, fsFolderItem, modalStack, upload;
		folder = relativePath && relativePath !== fileName ? "" + this.path + "/" + relativePath.replace(/\/[^\/]*$/, "") : this.path;
		modalStack = KDModalView.createStack({
			lastToFirst: !0
		});
		fsFolderItem = FSHelper.createFileFromPath(folder, "folder");
		fsFileItem = FSHelper.createFileFromPath("" + folder + "/" + fileName);
		if (!FSHelper.isUnwanted(fsFolderItem.path) && !FSHelper.isUnwanted(fsFileItem.path, !0)) {
			upload = function (_this) {
				return function () {
					return fsFileItem.exists(function (err, exists) {
						var modal;
						return exists && null == fsFileItem.getLocalFileInfo().lastUploadedChunk ? modalStack.addModal(modal = new KDModalView({
							overlay: !1,
							title: "Overwrite File?",
							content: '<div class="modalformline">\nYou already have the file <code>' + fsFileItem.path + "</code>. Do you want\nto overwrite it?\n</div>",
							buttons: {
								Overwrite: {
									cssClass: "modal-clean-green",
									callback: function () {
										_this.saveFile(fsFileItem, contents);
										return modal.destroy()
									}
								},
								cancel: {
									cssClass: "modal-cancel",
									callback: function () {
										return modal.destroy()
									}
								},
								"cancel all": {
									cssClass: "modal-cancel",
									callback: function () {
										return modalStack.destroy()
									}
								}
							}
						})) : _this.saveFile(fsFileItem, contents)
					})
				}
			}(this);
			fsFolderItem.exists(function () {
				return function (err, exists) {
					return exists ? upload() : FSHelper.createRecursiveFolder(fsFolderItem, function () {
						return upload()
					})
				}
			}(this));
			return fsFileItem
		}
	};
	return DNDUploader
}(KDView);
var OpenWithModalItem, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
OpenWithModalItem = function (_super) {
	function OpenWithModalItem(options, data) {
		null == options && (options = {});
		options.cssClass = "app";
		OpenWithModalItem.__super__.constructor.call(this, options, data);
		this.img = KD.utils.getAppIcon(this.getData());
		this.getOptions().supported || this.setClass("not-supported");
		this.on("click", function (_this) {
			return function () {
				var delegate;
				delegate = _this.getDelegate();
				delegate.selectedApp && delegate.selectedApp.unsetClass("selected");
				_this.setClass("selected");
				return delegate.selectedApp = _this
			}
		}(this))
	}
	__extends(OpenWithModalItem, _super);
	OpenWithModalItem.prototype.pistachio = function () {
		return "{{> this.img}}\n<div class='app-name'>" + this.getData() + "</div>"
	};
	return OpenWithModalItem
}(JView);
var OpenWithModal, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
OpenWithModal = function (_super) {
	function OpenWithModal(options, data) {
		var appManager, appName, apps, fileExtension, fileName, label, manifest, modal, nodeView, supportedApps, _i, _len, _ref;
		null == options && (options = {});
		OpenWithModal.__super__.constructor.call(this, options, data);
		_ref = this.getData(), nodeView = _ref.nodeView, apps = _ref.apps;
		appManager = KD.getSingleton("appManager");
		fileName = FSHelper.getFileNameFromPath(nodeView.getData().path);
		fileExtension = FSItem.getFileExtension(fileName);
		modal = new KDModalView({
			title: "Choose application to open " + fileName,
			cssClass: "open-with-modal",
			overlay: !0,
			width: 400,
			buttons: {
				Open: {
					title: "Open",
					style: "modal-clean-green",
					callback: function () {
						return function () {
							var appName;
							appName = modal.selectedApp.getData();
							appManager.openFileWithApplication(appName, nodeView.getData());
							return modal.destroy()
						}
					}(this)
				},
				Cancel: {
					title: "Cancel",
					style: "modal-cancel",
					callback: function () {
						return function () {
							return modal.destroy()
						}
					}(this)
				}
			}
		});
		supportedApps = ["Ace"];
		for (_i = 0, _len = supportedApps.length; _len > _i; _i++) {
			appName = supportedApps[_i];
			modal.addSubView(new OpenWithModalItem({
				supported: !0,
				delegate: modal
			}, appName))
		}
		modal.addSubView(new KDView({
			cssClass: "separator"
		}));
		for (appName in apps)
			if (__hasProp.call(apps, appName)) {
				manifest = apps[appName]; - 1 === supportedApps.indexOf(appName) && modal.addSubView(new OpenWithModalItem({
					delegate: modal
				}, manifest))
			}
		label = new KDLabelView({
			title: "Always open with..."
		});
		this.alwaysOpenWith = new KDInputView({
			label: label,
			type: "checkbox"
		});
		modal.buttonHolder.addSubView(this.alwaysOpenWith);
		modal.buttonHolder.addSubView(label)
	}
	__extends(OpenWithModal, _super);
	return OpenWithModal
}(KDObject);
var VmDangerModalView, __bind = function (fn, me) {
		return function () {
			return fn.apply(me, arguments)
		}
	},
	__hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
VmDangerModalView = function (_super) {
	function VmDangerModalView(options, data) {
		null == options && (options = {});
		this.checkVmName = __bind(this.checkVmName, this);
		options.action || (options.action = "Danger Zone");
		options.title || (options.title = options.action);
		options.content || (options.content = "<div class='modalformline'><p><strong>CAUTION! </strong>This will destroy the <strong>" + options.name + "</strong> VM including all its data. This action <strong>CANNOT</strong> be undone.</p><br><p>Please enter <strong>" + data + "</strong> into the field below to continue: </p></div>");
		null == options.callback && (options.callback = function () {
			return log("" + options.action + " performed")
		});
		null == options.overlay && (options.overlay = !0);
		null == options.width && (options.width = 500);
		null == options.height && (options.height = "auto");
		null == options.cssClass && (options.cssClass = "danger-modal");
		null == options.tabs && (options.tabs = {
			forms: {
				dangerForm: {
					callback: function (_this) {
						return function () {
							var callback;
							callback = function () {
								return _this.modalTabs.forms.dangerForm.buttons.confirmButton.hideLoader()
							};
							return options.callback(callback)
						}
					}(this),
					buttons: {
						confirmButton: {
							title: options.action,
							style: "modal-clean-red",
							type: "submit",
							disabled: !0,
							loader: {
								color: "#E94835"
							},
							callback: function () {
								return this.showLoader()
							}
						},
						Cancel: {
							style: "modal-cancel",
							callback: this.bound("destroy")
						}
					},
					fields: {
						vmSlug: {
							itemClass: KDInputView,
							placeholder: "Enter '" + data + "' to confirm...",
							validate: {
								rules: {
									required: !0,
									slugCheck: function (_this) {
										return function (input) {
											return _this.checkVmName(input, !1)
										}
									}(this),
									finalCheck: function (_this) {
										return function (input) {
											return _this.checkVmName(input)
										}
									}(this)
								},
								messages: {
									required: "Please enter vm name"
								},
								events: {
									required: "blur",
									slugCheck: "keyup",
									finalCheck: "blur"
								}
							}
						}
					}
				}
			}
		});
		VmDangerModalView.__super__.constructor.apply(this, arguments)
	}
	__extends(VmDangerModalView, _super);
	VmDangerModalView.prototype.checkVmName = function (input, showError) {
		null == showError && (showError = !0);
		if (input.getValue() === this.getData()) {
			input.setValidationResult("slugCheck", null);
			return this.modalTabs.forms.dangerForm.buttons.confirmButton.enable()
		}
		this.modalTabs.forms.dangerForm.buttons.confirmButton.disable();
		return input.setValidationResult("slugCheck", "Sorry, entered value does not match vm name!", showError)
	};
	return VmDangerModalView
}(KDModalViewWithForms);
var NFinderController, VMMountStateWidget, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
NFinderController = function (_super) {
	function NFinderController(options, data) {
		var TreeControllerClass, mainController, nickname, treeOptions, vmc;
		null == options && (options = {});
		nickname = KD.whoami().profile.nickname;
		options.view = new KDView({
			cssClass: "nfinder file-container"
		});
		treeOptions = {};
		treeOptions.treeItemClass = options.treeItemClass || (options.treeItemClass = NFinderItem);
		treeOptions.nodeIdPath = options.nodeIdPath || (options.nodeIdPath = "path");
		treeOptions.nodeParentIdPath = options.nodeParentIdPath || (options.nodeParentIdPath = "parentPath");
		treeOptions.dragdrop = null != options.dragdrop ? options.dragdrop : options.dragdrop = !0;
		treeOptions.foldersOnly = null != options.foldersOnly ? options.foldersOnly : options.foldersOnly = !1;
		treeOptions.hideDotFiles = null != options.hideDotFiles ? options.hideDotFiles : options.hideDotFiles = !1;
		treeOptions.multipleSelection = null != options.multipleSelection ? options.multipleSelection : options.multipleSelection = !0;
		treeOptions.addOrphansToRoot = null != options.addOrphansToRoot ? options.addOrphansToRoot : options.addOrphansToRoot = !1;
		treeOptions.putDepthInfo = null != options.putDepthInfo ? options.putDepthInfo : options.putDepthInfo = !0;
		treeOptions.contextMenu = null != options.contextMenu ? options.contextMenu : options.contextMenu = !0;
		treeOptions.maxRecentFolders = options.maxRecentFolders || (options.maxRecentFolders = 10);
		treeOptions.useStorage = null != options.useStorage ? options.useStorage : options.useStorage = !1;
		treeOptions.loadFilesOnInit = null != options.loadFilesOnInit ? options.loadFilesOnInit : options.loadFilesOnInit = !1;
		treeOptions.delegate = this;
		NFinderController.__super__.constructor.call(this, options, data);
		TreeControllerClass = options.treeControllerClass || NFinderTreeController;
		this.treeController = new TreeControllerClass(treeOptions, []);
		this.appStorage = KD.getSingleton("appStorageController").storage("Finder", "1.2");
		this.watchers = {};
		mainController = KD.getSingleton("mainController");
		mainController.on("accountChanged.to.loggedIn", this.bound("reset"));
		options.useStorage && this.appStorage.ready(function (_this) {
			return function () {
				_this.treeController.on("file.opened", _this.bound("setRecentFile"));
				_this.treeController.on("folder.expanded", function (folder) {
					return _this.setRecentFolder(folder.path)
				});
				return _this.treeController.on("folder.collapsed", function (_arg) {
					var path;
					path = _arg.path;
					_this.unsetRecentFolder(path);
					return _this.stopWatching(path)
				})
			}
		}(this));
		this.noVMFoundWidget = new VMMountStateWidget;
		this.cleanup();
		vmc = KD.getSingleton("vmController");
		vmc.on("StateChanged", this.bound("checkVMState"));
		vmc.on("VMDestroyed", this.bound("unmountVm"))
	}
	var parseSavedVms;
	__extends(NFinderController, _super);
	NFinderController.prototype.registerWatcher = function (path, stopWatching) {
		return this.watchers[path] = {
			stop: stopWatching
		}
	};
	NFinderController.prototype.stopAllWatchers = function () {
		var path, watcher, _ref;
		_ref = this.watchers;
		for (path in _ref)
			if (__hasProp.call(_ref, path)) {
				watcher = _ref[path];
				watcher.stop()
			}
		return this.watchers = {}
	};
	NFinderController.prototype.stopWatching = function (pathToStop) {
		var path, watcher, _ref, _results;
		_ref = this.watchers;
		_results = [];
		for (path in _ref)
			if (__hasProp.call(_ref, path)) {
				watcher = _ref[path];
				if (0 === path.indexOf(pathToStop)) {
					watcher.stop();
					_results.push(delete this.watchers[path])
				}
			}
		return _results
	};
	NFinderController.prototype.loadView = function (mainView) {
		mainView.addSubView(this.treeController.getView());
		mainView.addSubView(this.noVMFoundWidget);
		this.viewLoaded = !0;
		return this.getOptions().loadFilesOnInit ? this.reset() : void 0
	};
	NFinderController.prototype.reset = function () {
		return KD.singletons.vmController.ready(function (_this) {
			return function () {
				return _this.getOptions().useStorage ? _this.appStorage.ready(function () {
					return _this.loadVms()
				}) : _this.utils.defer(function () {
					return _this.loadVms()
				})
			}
		}(this))
	};
	NFinderController.prototype.mountVms = function (vms) {
		var vm, _i, _len, _results;
		if (Array.isArray(vms)) {
			this.cleanup();
			_results = [];
			for (_i = 0, _len = vms.length; _len > _i; _i++) {
				vm = vms[_i];
				_results.push(this.mountVm(vm))
			}
			return _results
		}
	};
	parseSavedVms = function (vms) {
		return vms.reduce(function (memo, str) {
			var path, vmName, _ref;
			_ref = str.split(":"), vmName = _ref[0], path = _ref[1];
			memo[0].push(vmName);
			memo[1].push(path);
			return memo
		}, [
			[],
			[]
		])
	};
	NFinderController.prototype.fetchSavedVms = function (savedVms, callback) {
		var paths, vmNames, _ref;
		_ref = parseSavedVms(savedVms), vmNames = _ref[0], paths = _ref[1];
		return KD.getSingleton("vmController").fetchVmsByName(vmNames, function () {
			return function (err, vms) {
				var i, _, _i, _len;
				if (err) return "function" == typeof callback ? callback(err) : void 0;
				for (i = _i = 0, _len = vms.length; _len > _i; i = ++_i) {
					_ = vms[i];
					vms[i].path = paths[i]
				}
				return callback(null, vms)
			}
		}(this))
	};
	NFinderController.prototype.loadVms = function (vmNames, callback) {
		var JVM, groupSlug;
		null == callback && (callback = function () {});
		JVM = KD.remote.api.JVM;
		if (vmNames) return this.fetchSavedVms(vmNames, function (_this) {
			return function (err, vms) {
				return err ? callback(err) : _this.mountVms(vms)
			}
		}(this));
		groupSlug = KD.getSingleton("groupsController").getGroupSlug();
		null == groupSlug && (groupSlug = KD.defaultSlug);
		return this.appStorage.fetchValue("mountedVM", function (_this) {
			return function (vms) {
				var groupVms;
				vms || (vms = {});
				vms[groupSlug] || (vms[groupSlug] = []);
				groupVms = vms[groupSlug];
				return groupVms.length > 0 ? _this.fetchSavedVms(groupVms, function (err, vms) {
					return err ? callback(err) : _this.mountVms(vms)
				}) : JVM.fetchVmsByContext({}, function (err, vms) {
					return err ? callback(err) : vms && 0 !== vms.length ? _this.mountVms(vms) : KD.getSingleton("vmController").fetchDefaultVmName(function (vm) {
						return vm ? _this.mountVms([vm]) : _this.noVMFoundWidget.show()
					})
				})
			}
		}(this))
	};
	NFinderController.prototype.getVmNode = function (vmName) {
		var path, vmItem, _ref, _ref1;
		if (!vmName) return null;
		_ref = this.treeController.nodes;
		for (path in _ref)
			if (__hasProp.call(_ref, path)) {
				vmItem = _ref[path];
				if ("vm" === (null != (_ref1 = vmItem.data) ? _ref1.type : void 0) && vmItem.data.vmName === vmName) return vmItem
			}
	};
	NFinderController.prototype.updateMountState = function (vmName, state) {
		var groupSlug, items, vms;
		if (!KD.isGuest()) {
			groupSlug = KD.getSingleton("groupsController").getGroupSlug();
			null == groupSlug && (groupSlug = KD.defaultSlug);
			vms = this.appStorage.getValue("mountedVM") || {};
			vms[groupSlug] || (vms[groupSlug] = []);
			items = vms[groupSlug];
			state && __indexOf.call(items, vmName) < 0 ? items.push(vmName) : !state && __indexOf.call(items, vmName) >= 0 && items.splice(items.indexOf(vmName), 1);
			return this.appStorage.setValue("mountedVM", vms)
		}
	};
	NFinderController.prototype.checkVMState = function (err, vm, info) {
		if (err || !info) return warn(err);
		switch (info.state) {
		case "MAINTENANCE":
			return this.unmountVm(vm)
		}
	};
	NFinderController.prototype.mountVm = function (vm, fetchContent) {
		var path, pipedVm, region, vmItem, vmName, vmRoots;
		null == fetchContent && (fetchContent = !0);
		region = vm.region, vmName = vm.hostnameAlias, path = vm.path;
		vmRoots = this.appStorage.getValue("vmRoots") || {};
		pipedVm = this._pipedVmName(vmName);
		null == path && (path = "/home/" + KD.nick());
		if (vmItem = this.getVmNode(vmName)) return warn("VM " + vmName + " is already mounted!");
		this.updateMountState(vmName, !0);
		this.vms.push(FSHelper.createFile({
			name: "" + path,
			path: "[" + vmName + "]" + path,
			type: "vm",
			vmName: vmName,
			vm: vm,
			treeController: this.treeController
		}));
		this.noVMFoundWidget.hide();
		this.treeController.addNode(this.vms.last);
		vmItem = this.getVmNode(vmName);
		return fetchContent && vmItem ? this.utils.defer(function (_this) {
			return function () {
				return _this.treeController.expandFolder(vmItem, function (err) {
					if ("VMNotFoundError" === (null != err ? err.name : void 0)) return _this.unmountVm(vmName);
					_this.treeController.selectNode(vmItem);
					return _this.utils.defer(function () {
						return _this.getOptions().useStorage ? _this.reloadPreviousState(vmName) : void 0
					})
				}, !0)
			}
		}(this)) : void 0
	};
	NFinderController.prototype.unmountVm = function (vmName) {
		var vmItem;
		vmItem = this.getVmNode(vmName);
		if (!vmItem) return warn("No such VM!");
		this.updateMountState(vmName, !1);
		this.stopWatching(vmItem.data.path);
		FSHelper.unregisterVmFiles(vmName);
		this.treeController.removeNodeView(vmItem);
		this.vms = this.vms.filter(function (vmData) {
			return vmData !== vmItem.data
		});
		if (0 === this.vms.length) {
			this.noVMFoundWidget.show();
			return this.emit("EnvironmentsTabRequested")
		}
	};
	NFinderController.prototype.updateVMRoot = function (vmName, path, callback) {
		var pipedVm, vmRoots;
		if (!vmName && !path) return warn("VM name and new path required!");
		this.unmountVm(vmName);
		"function" == typeof callback && callback();
		vmRoots = this.appStorage.getValue("vmRoots") || {};
		pipedVm = this._pipedVmName(vmName);
		vmRoots[pipedVm] = path;
		this.getOptions().useStorage && this.appStorage.setValue("vmRoots", vmRoots);
		return KD.singleton("vmController").fetchVmsByName([vmName], function (_this) {
			return function (err, _arg) {
				var vm;
				vm = _arg[0];
				if (err) return KD.showError(err);
				vm.path = path;
				return _this.mountVm(vm)
			}
		}(this))
	};
	NFinderController.prototype.cleanup = function () {
		this.treeController.removeAllNodes();
		FSHelper.resetRegistry();
		this.stopAllWatchers();
		return this.vms = []
	};
	NFinderController.prototype.setRecentFile = function (_arg) {
		var path, recentFiles;
		path = _arg.path;
		recentFiles = this.appStorage.getValue("recentFiles");
		Array.isArray(recentFiles) || (recentFiles = []);
		if (__indexOf.call(recentFiles, path) < 0) {
			recentFiles.length === this.treeController.getOptions().maxRecentFiles && recentFiles.pop();
			recentFiles.unshift(path)
		}
		return this.appStorage.setValue("recentFiles", recentFiles.slice(0, 10), function (_this) {
			return function () {
				return _this.emit("recentfiles.updated", recentFiles)
			}
		}(this))
	};
	NFinderController.prototype.hideDotFiles = function (vmName) {
		var file, node, path, _ref, _results;
		if (vmName) {
			this.setNodesHidden(vmName, !0);
			_ref = this.treeController.nodes;
			_results = [];
			for (path in _ref)
				if (__hasProp.call(_ref, path)) {
					node = _ref[path];
					file = node.getData();
					if (file.vmName === vmName && file.isHidden()) {
						this.stopWatching(file.path);
						_results.push(this.treeController.removeNodeView(node))
					} else _results.push(void 0)
				}
			return _results
		}
	};
	NFinderController.prototype.showDotFiles = function (vmName) {
		var node, path, _ref;
		if (vmName) {
			this.setNodesHidden(vmName, !1);
			_ref = this.treeController.nodes;
			for (path in _ref)
				if (__hasProp.call(_ref, path)) {
					node = _ref[path];
					if ("vm" === node.getData().type && node.getData().vmName === vmName) return this.treeController.collapseFolder(node, function (_this) {
						return function () {
							return _this.reloadPreviousState(vmName)
						}
					}(this), !0)
				}
		}
	};
	NFinderController.prototype.isNodesHiddenFor = function (vmName) {
		var pipedVm;
		if (this.getOption("hideDotFiles")) return !0;
		pipedVm = this._pipedVmName(vmName);
		return (this.appStorage.getValue("vmsDotFileChoices") || {})[pipedVm]
	};
	NFinderController.prototype.setNodesHidden = function (vmName, state) {
		var pipedVm, prefs;
		pipedVm = this._pipedVmName(vmName);
		prefs = this.appStorage.getValue("vmsDotFileChoices") || {};
		prefs[pipedVm] = state;
		return this.appStorage.setValue("vmsDotFileChoices", prefs)
	};
	NFinderController.prototype.getRecentFolders = function () {
		var recentFolders;
		recentFolders = this.appStorage.getValue("recentFolders");
		Array.isArray(recentFolders) || (recentFolders = []);
		return recentFolders
	};
	NFinderController.prototype.setRecentFolder = function (folderPath, callback) {
		var recentFolders;
		recentFolders = this.getRecentFolders();
		__indexOf.call(recentFolders, folderPath) < 0 && recentFolders.push(folderPath);
		recentFolders.sort(function (path) {
			return path === folderPath ? -1 : 0
		});
		return this.appStorage.setValue("recentFolders", recentFolders, callback)
	};
	NFinderController.prototype.unsetRecentFolder = function (folderPath, callback) {
		var recentFolders;
		recentFolders = this.getRecentFolders();
		recentFolders = recentFolders.filter(function (path) {
			return 0 !== path.indexOf(folderPath)
		});
		recentFolders.sort(function (path) {
			return path === folderPath ? -1 : 0
		});
		return this.appStorage.setValue("recentFolders", recentFolders, callback)
	};
	NFinderController.prototype.expandFolder = function (folderPath, callback) {
		var node, path, _ref;
		null == callback && (callback = noop);
		if (folderPath) {
			_ref = this.treeController.nodes;
			for (path in _ref)
				if (__hasProp.call(_ref, path)) {
					node = _ref[path];
					if (path === folderPath) return this.treeController.expandFolder(node, callback)
				}
			return callback({
				message: "Folder not exists: " + folderPath
			})
		}
	};
	NFinderController.prototype.expandFolders = function (paths, callback) {
		var path;
		null == callback && (callback = noop);
		"string" == typeof paths && (paths = FSHelper.getPathHierarchy(paths));
		path = paths.pop();
		return this.expandFolder(path, function (_this) {
			return function (err) {
				err && _this.unsetRecentFolder(path);
				return 0 === paths.length ? callback(null, _this.treeController.nodes[path]) : _this.expandFolders(paths, callback)
			}
		}(this))
	};
	NFinderController.prototype.reloadPreviousState = function (vmName) {
		var recentFolders;
		recentFolders = this.getRecentFolders();
		if (vmName) {
			recentFolders = recentFolders.filter(function (folder) {
				return folder.indexOf("[" + vmName + "]" === 0)
			});
			0 === recentFolders.length && (recentFolders = ["[" + vmName + "]/home/" + KD.nick()])
		}
		return this.expandFolders(recentFolders)
	};
	NFinderController.prototype.uploadTo = function (path) {
		var uploader, uploaderPlaceholder, _ref;
		_ref = this.getDelegate(), uploader = _ref.uploader, uploaderPlaceholder = _ref.uploaderPlaceholder;
		uploader.setPath(path);
		return uploaderPlaceholder.show()
	};
	NFinderController.prototype._pipedVmName = function (vmName) {
		return vmName.replace(/\./g, "|")
	};
	return NFinderController
}(KDViewController);
VMMountStateWidget = function (_super) {
	function VMMountStateWidget() {
		VMMountStateWidget.__super__.constructor.call(this, {
			cssClass: "no-vm-found-widget"
		});
		this.loader = new KDLoaderView({
			size: {
				width: 20
			},
			loaderOptions: {
				speed: .7,
				FPS: 24
			}
		});
		this.warning = new KDCustomHTMLView({
			partial: "There is no attached VM"
		})
	}
	__extends(VMMountStateWidget, _super);
	VMMountStateWidget.prototype.pistachio = function () {
		return "{{> this.loader}}\n{{> this.warning}}"
	};
	VMMountStateWidget.prototype.showMessage = function (message) {
		message || (message = "There is no VM attached to filetree, you can\nattach or create one from environment menu below.");
		this.warning.updatePartial(message);
		this.warning.show();
		return this.loader.hide()
	};
	VMMountStateWidget.prototype.show = function () {
		var group;
		this.setClass("visible");
		this.warning.hide();
		this.loader.show();
		if (KD.getSingleton("groupsController").getGroupSlug() === KD.defaultSlug) return this.showMessage();
		if (__indexOf.call(KD.config.roles, "admin") >= 0 || __indexOf.call(KD.config.roles, "owner") >= 0) {
			group = KD.getSingleton("groupsController").getCurrentGroup();
			return group.checkPayment(function (_this) {
				return function (err, payments) {
					err && warn(err);
					return _this.showMessage(0 === payments.length ? "There is no VM attached for this group, you can\nattach one or you can <b>pay</b> and create\na new one from environment menu below." : "There is no VM attached for this group, you can\nattach one or you can create a new one from\nenvironment menu below.")
				}
			}(this))
		}
		return this.showMessage("There is no VM for this group or not attached to\nfiletree yet, you can attach one from environment\nmenu below.")
	};
	VMMountStateWidget.prototype.hide = function () {
		this.unsetClass("visible");
		return this.loader.hide()
	};
	return VMMountStateWidget
}(JView);
var NFinderTreeController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
NFinderTreeController = function (_super) {
	function NFinderTreeController() {
		var mainController;
		NFinderTreeController.__super__.constructor.apply(this, arguments);
		if (this.getOptions().contextMenu) {
			this.contextMenuController = new NFinderContextMenuController;
			this.contextMenuController.on("ContextMenuItemClicked", function (_this) {
				return function (_arg) {
					var contextMenuItem, fileView;
					fileView = _arg.fileView, contextMenuItem = _arg.contextMenuItem;
					return _this.contextMenuItemSelected(fileView, contextMenuItem)
				}
			}(this))
		} else this.getView().setClass("no-context-menu");
		this.appManager = KD.getSingleton("appManager");
		mainController = KD.getSingleton("mainController");
		mainController.on("NewFileIsCreated", this.bound("navigateToNewFile"));
		mainController.on("SelectedFileChanged", this.bound("highlightFile"))
	}
	var autoTriedOnce, lastEnteredNode, notification;
	__extends(NFinderTreeController, _super);
	NFinderTreeController.prototype.addNode = function (nodeData, index) {
		var fc, item;
		fc = this.getDelegate();
		return this.getOption("foldersOnly") && "file" === nodeData.type || nodeData.isHidden() && fc.isNodesHiddenFor(nodeData.vmName) ? void 0 : item = NFinderTreeController.__super__.addNode.call(this, nodeData, index)
	};
	NFinderTreeController.prototype.highlightFile = function (view) {
		this.selectNode(this.nodes[view.data.path], null, !1);
		return null != view.ace ? null != view.ace.editor ? view.ace.editor.focus() : view.ace.on("ace.ready", function () {
			return view.ace.editor.focus()
		}) : void 0
	};
	NFinderTreeController.prototype.navigateToNewFile = function (newFile) {
		return this.navigateTo(newFile.parentPath, function (_this) {
			return function () {
				return _this.selectNode(_this.nodes[newFile.path])
			}
		}(this))
	};
	NFinderTreeController.prototype.getOpenFolders = function () {
		return Object.keys(this.listControllers).slice(1)
	};
	NFinderTreeController.prototype.openItem = function (nodeView, callback) {
		var nodeData, options;
		options = this.getOptions();
		nodeData = nodeView.getData();
		switch (nodeData.type) {
		case "folder":
		case "mount":
		case "vm":
			return this.toggleFolder(nodeView, callback);
		case "file":
			this.openFile(nodeView);
			this.emit("file.opened", nodeData);
			return this.setBlurState()
		}
	};
	NFinderTreeController.prototype.openFileWithApp = function (nodeView, contextMenuItem) {
		var app;
		if (!contextMenuItem) return warn("no app passed to open this file");
		app = contextMenuItem.getData().title;
		return KD.getSingleton("appManager").openFileWithApplication(app, nodeView.getData())
	};
	NFinderTreeController.prototype.openFile = function (nodeView) {
		var file;
		if (nodeView) {
			file = nodeView.getData();
			return this.getDelegate().emit("FileNeedsToBeOpened", file)
		}
	};
	NFinderTreeController.prototype.previewFile = function (nodeView) {
		var path, vmName, _ref;
		_ref = nodeView.getData(), vmName = _ref.vmName, path = _ref.path;
		return this.appManager.open("Viewer", {
			params: {
				path: path,
				vmName: vmName
			}
		})
	};
	NFinderTreeController.prototype.resetVm = function (nodeView) {
		var vmName;
		vmName = nodeView.data.vmName;
		return KD.getSingleton("vmController").reinitialize(vmName)
	};
	NFinderTreeController.prototype.unmountVm = function (nodeView) {
		var vmName;
		vmName = nodeView.data.vmName;
		return this.getDelegate().unmountVm(vmName)
	};
	NFinderTreeController.prototype.openVmTerminal = function (nodeView) {
		var vmName;
		vmName = nodeView.data.vmName;
		return this.appManager.open("Terminal", {
			params: {
				vmName: vmName
			},
			forceNew: !0
		})
	};
	NFinderTreeController.prototype.toggleDotFiles = function (nodeView) {
		var finder, path, vmName, _ref;
		finder = this.getDelegate();
		_ref = nodeView.getData(), vmName = _ref.vmName, path = _ref.path;
		return finder.isNodesHiddenFor(vmName) ? finder.showDotFiles(vmName) : finder.hideDotFiles(vmName)
	};
	NFinderTreeController.prototype.makeTopFolder = function (nodeView) {
		var finder, path, vmName, _ref;
		_ref = nodeView.getData(), vmName = _ref.vmName, path = _ref.path;
		finder = this.getDelegate();
		return finder.updateVMRoot(vmName, FSHelper.plainPath(path))
	};
	NFinderTreeController.prototype.refreshFolder = function (nodeView, callback) {
		var folder;
		this.notify("Refreshing...");
		folder = nodeView.getData();
		folder.emit("fs.job.finished", []);
		return this.collapseFolder(nodeView, function (_this) {
			return function () {
				return _this.expandFolder(nodeView, function () {
					notification.destroy();
					return "function" == typeof callback ? callback() : void 0
				})
			}
		}(this))
	};
	NFinderTreeController.prototype.toggleFolder = function (nodeView, callback) {
		return nodeView.expanded ? this.collapseFolder(nodeView, callback) : this.expandFolder(nodeView, callback)
	};
	NFinderTreeController.prototype.expandFolder = function (nodeView, callback, silence) {
		var failCallback, folder;
		null == silence && (silence = !1);
		if (nodeView && !nodeView.isLoading) {
			if (!nodeView.expanded) {
				folder = nodeView.getData();
				if (folder.depth > 10) {
					this.notify("Folder is nested deeply, making it top folder");
					this.makeTopFolder(nodeView)
				}
				failCallback = function (_this) {
					return function (err) {
						var message, _ref;
						if (!silence) {
							if (null != err && null != (_ref = err.message) ? _ref.match(/permission denied/i) : void 0) {
								message = "Permission denied!";
								KD.logToExternal("filetree: Couldn't fetch files, permission denied")
							} else {
								message = "Couldn't fetch files! Click to retry";
								KD.logToExternalWithTime("filetree: Couldn't fetch files")
							}
							_this.notify(message, "clickable", "Sorry, a problem occured while communicating with servers,\nplease try again later.", !0);
							_this.once("fs.retry.scheduled", function () {
								return _this.expandFolder(nodeView, callback)
							})
						}
						folder.emit("fs.job.finished", []);
						return "function" == typeof callback ? callback(err) : void 0
					}
				}(this);
				return folder.fetchContents(!1, KD.utils.getTimedOutCallback(function (_this) {
					return function (err, files) {
						if (err) return failCallback(err);
						nodeView.expand();
						files && _this.addNodes(files);
						"function" == typeof callback && callback(null, nodeView);
						silence || _this.emit("folder.expanded", nodeView.getData());
						_this.emit("fs.retry.success");
						return _this.hideNotification()
					}
				}(this), failCallback, KD.config.fileFetchTimeout))
			}
			"function" == typeof callback && callback(null, nodeView)
		}
	};
	NFinderTreeController.prototype.collapseFolder = function (nodeView, callback, silence) {
		var folder, path;
		null == silence && (silence = !1);
		if (nodeView) {
			folder = nodeView.getData();
			path = folder.path;
			silence || this.emit("folder.collapsed", folder);
			if (this.listControllers[path]) return this.listControllers[path].getView().collapse(function (_this) {
				return function () {
					_this.removeChildNodes(path);
					nodeView.collapse();
					return "function" == typeof callback ? callback(nodeView) : void 0
				}
			}(this));
			nodeView.collapse();
			return "function" == typeof callback ? callback(nodeView) : void 0
		}
	};
	NFinderTreeController.prototype.navigateTo = function (path, callback) {
		var index, lastPath, _expand;
		if (path) {
			path = path.split("/");
			"" === path[0] && path.shift();
			"" === path[path.length - 1] && path.pop();
			path[1] = "/" + path[0] + "/" + path[1];
			path.shift();
			index = 0;
			lastPath = "";
			_expand = function (_this) {
				return function (path) {
					var nextPath;
					nextPath = path.slice(0, ++index).join("/");
					if (lastPath !== nextPath) return _this.expandFolder(_this.nodes[nextPath], function () {
						lastPath = nextPath;
						return _expand(path)
					});
					_this.refreshFolder(_this.nodes[nextPath], function () {
						return "function" == typeof callback ? callback() : void 0
					});
					return void 0
				}
			}(this);
			return _expand(path)
		}
	};
	NFinderTreeController.prototype.confirmDelete = function (nodeView) {
		var extension, _ref;
		extension = (null != (_ref = nodeView.data) ? _ref.getExtension() : void 0) || null;
		if (this.selectedNodes.length > 1) return new NFinderDeleteDialog({}, {
			items: this.selectedNodes,
			callback: function (_this) {
				return function (confirmation) {
					confirmation && _this.deleteFiles(_this.selectedNodes);
					return _this.setKeyView()
				}
			}(this)
		});
		this.beingEdited = nodeView;
		return nodeView.confirmDelete(function (_this) {
			return function (confirmation) {
				confirmation && _this.deleteFiles([nodeView]);
				_this.setKeyView();
				return _this.beingEdited = null
			}
		}(this))
	};
	NFinderTreeController.prototype.deleteFiles = function (nodes, callback) {
		var deletedNodes, results;
		deletedNodes = [];
		results = nodes.map(function (node) {
			return node.getData().remove().then(function () {
				node.emit("ItemBeingDeleted");
				return deletedNodes.push(node)
			})
		});
		return Promise.all(results).then(function (_this) {
			return function () {
				var node, _i, _len, _results;
				_this.notify("" + deletedNodes.length + " item" + (deletedNodes.length > 1 ? "s" : "") + " deleted!", "success");
				_results = [];
				for (_i = 0, _len = deletedNodes.length; _len > _i; _i++) {
					node = deletedNodes[_i];
					_results.push(_this.removeNodeView(node))
				}
				return _results
			}
		}(this))["catch"](function (_this) {
			return function (err) {
				return _this.notify(null, null, err)
			}
		}(this)).nodeify(callback)
	};
	NFinderTreeController.prototype.showRenameDialog = function (nodeView) {
		var nodeData, oldPath;
		this.beingEdited = nodeView;
		nodeData = nodeView.getData();
		oldPath = nodeData.path;
		return nodeView.showRenameView(function (_this) {
			return function (newValue) {
				if (newValue !== nodeData.name) {
					nodeData.rename({
						name: newValue
					}, function (err) {
						return err ? _this.notify(null, null, err) : void 0
					});
					return _this.beingEdited = null
				}
			}
		}(this))
	};
	NFinderTreeController.prototype.createFile = function (nodeView, type) {
		var nodeData, parentPath, path, vmName;
		null == type && (type = "file");
		this.notify("creating a new " + type + "!");
		nodeData = nodeView.getData();
		vmName = nodeData.vmName;
		parentPath = "file" === nodeData.type ? nodeData.parentPath : nodeData.path;
		path = FSHelper.plainPath("" + parentPath + "/New" + type.capitalize() + ("file" === type ? ".txt" : ""));
		return FSItem.create({
			path: path,
			type: type,
			vmName: vmName,
			treeController: this
		}, function (_this) {
			return function (err, file) {
				return err ? _this.notify(null, null, err) : _this.refreshFolder(_this.nodes[parentPath], function () {
					var node;
					_this.notify("" + type + " created!", "success");
					node = _this.nodes["[" + file.vmName + "]" + file.path];
					_this.selectNode(node);
					return _this.showRenameDialog(node)
				})
			}
		}(this))
	};
	NFinderTreeController.prototype.moveFiles = function (nodesToBeMoved, targetNodeView, callback) {
		var movedNodes, results, targetItem;
		targetItem = targetNodeView.getData();
		if ("file" === targetItem.type) {
			targetNodeView = this.nodes[targetNodeView.getData().parentPath];
			targetItem = targetNodeView.getData()
		}
		movedNodes = [];
		results = nodesToBeMoved.map(function (node) {
			var sourceItem;
			sourceItem = node.getData();
			return FSItem.move(sourceItem, targetItem).then(function () {
				return movedNodes.push(node)
			})
		});
		return Promise.all(results).then(function (_this) {
			return function () {
				var node, _i, _len;
				_this.notify("" + movedNodes.length + " item" + (movedNodes.length > 1 ? "s" : "") + " moved!", "success");
				for (_i = 0, _len = movedNodes.length; _len > _i; _i++) {
					node = movedNodes[_i];
					_this.removeNodeView(node)
				}
				return _this.refreshFolder(targetNodeView)
			}
		}(this))["catch"](function (_this) {
			return function (err) {
				return _this.notify(null, null, err)
			}
		}(this)).nodeify(callback)
	};
	NFinderTreeController.prototype.copyFiles = function (nodesToBeCopied, targetNodeView, callback) {
		var copiedNodes, results, targetItem;
		targetItem = targetNodeView.getData();
		if ("file" === targetItem.type) {
			targetNodeView = this.nodes[targetNodeView.getData().parentPath];
			targetItem = targetNodeView.getData()
		}
		copiedNodes = [];
		results = nodesToBeCopied.map(function (node) {
			var sourceItem;
			sourceItem = node.getData();
			return FSItem.copy(sourceItem, targetItem).then(function () {
				return copiedNodes.push(node)
			})
		});
		return Promise.all(results).then(function (_this) {
			return function () {
				_this.notify("" + copiedNodes.length + " item" + (copiedNodes.length > 1 ? "s" : "") + " copied!", "success");
				return _this.refreshFolder(targetNodeView)
			}
		}(this))["catch"](function (_this) {
			return function (err) {
				return _this.notify(null, null, err)
			}
		}(this)).nodeify(callback)
	};
	NFinderTreeController.prototype.duplicateFiles = function (nodes, callback) {
		var duplicatedNodes, results;
		duplicatedNodes = [];
		results = nodes.map(function (_this) {
			return function (node) {
				var sourceItem, targetItem;
				sourceItem = node.getData();
				targetItem = _this.nodes[sourceItem.parentPath].getData();
				return FSItem.copy(sourceItem, targetItem).then(function () {
					return duplicatedNodes.push(node)
				})
			}
		}(this));
		return Promise.all(results).then(function (_this) {
			return function () {
				var parentNode, parentNodes, _i, _len, _results;
				_this.notify("" + duplicatedNodes.length + " item" + (duplicatedNodes.length > 1 ? "s" : "") + " duplicated!", "success");
				parentNodes = [];
				duplicatedNodes.forEach(function (node) {
					var parentNode;
					parentNode = _this.nodes[node.getData().parentPath];
					return __indexOf.call(parentNodes, parentNode) < 0 ? parentNodes.push(parentNode) : void 0
				});
				_results = [];
				for (_i = 0, _len = parentNodes.length; _len > _i; _i++) {
					parentNode = parentNodes[_i];
					_results.push(_this.refreshFolder(parentNode))
				}
				return _results
			}
		}(this))["catch"](function (_this) {
			return function (err) {
				return _this.notify(null, null, err)
			}
		}(this)).nodeify(callback)
	};
	NFinderTreeController.prototype.compressFiles = function (nodeView, type) {
		var file;
		file = nodeView.getData();
		return FSItem.compress(file, type, function (_this) {
			return function (err) {
				if (err) return _this.notify(null, null, err);
				_this.notify("" + file.type.capitalize() + " compressed!", "success");
				return _this.refreshFolder(_this.nodes[file.parentPath])
			}
		}(this))
	};
	NFinderTreeController.prototype.extractFiles = function (nodeView) {
		var file;
		file = nodeView.getData();
		return FSItem.extract(file, function (_this) {
			return function (err, response) {
				if (err) return _this.notify(null, null, err);
				_this.notify("" + file.type.capitalize() + " extracted!", "success");
				return _this.refreshFolder(_this.nodes[file.parentPath], function () {
					return _this.selectNode(_this.nodes[response.path])
				})
			}
		}(this))
	};
	NFinderTreeController.prototype.compileApp = function (nodeView, callback) {
		var folder;
		folder = nodeView.getData();
		folder.emit("fs.job.started");
		return KodingAppsController.compileAppOnServer(folder.path, function (_this) {
			return function (err) {
				folder.emit("fs.job.finished");
				if (err) return warn(err);
				_this.notify("App compiled!", "success");
				_this.utils.wait(500, function () {
					return _this.refreshFolder(nodeView, function () {
						return _this.utils.defer(function () {
							return _this.selectNode(_this.nodes["" + folder.path + "/index.js"])
						})
					})
				});
				return "function" == typeof callback ? callback(err) : void 0
			}
		}(this))
	};
	NFinderTreeController.prototype.publishApp = function (nodeView) {
		var folder;
		folder = nodeView.getData();
		folder.emit("fs.job.started");
		return KodingAppsController.createJApp({
			path: folder.path
		}, function (err, app) {
			folder.emit("fs.job.finished");
			if (err || !app) {
				warn(err);
				return new KDNotificationView({
					title: "Failed to publish"
				})
			}
			new KDNotificationView({
				title: "Published successfully!"
			});
			return KD.singletons.router.handleRoute("/Apps/" + app.manifest.authorNick + "/" + app.name)
		})
	};
	NFinderTreeController.prototype.makeNewApp = function () {
		return KD.getSingleton("kodingAppsController").makeNewApp()
	};
	NFinderTreeController.prototype.cloneRepo = function (nodeView) {
		var folder, modal;
		folder = nodeView.getData();
		modal = new CloneRepoModal({
			vmName: folder.vmName,
			path: folder.path
		});
		return modal.on("RepoClonedSuccessfully", function (_this) {
			return function () {
				return _this.notify("Repo cloned successfully.", "success")
			}
		}(this))
	};
	NFinderTreeController.prototype.openTerminalFromHere = function (nodeView) {
		return this.appManager.open("Terminal", function (_this) {
			return function () {
				var path, terminalView;
				path = nodeView.getData().path;
				terminalView = _this.appManager.getFrontApp().getView().tabView.getActivePane().getOptions().terminalView;
				return terminalView.on("WebTermConnected", function (server) {
					return server.input("cd " + path + "\n")
				})
			}
		}(this))
	};
	NFinderTreeController.prototype.cmExpand = function () {
		var node, _i, _len, _ref, _results;
		_ref = this.selectedNodes;
		_results = [];
		for (_i = 0, _len = _ref.length; _len > _i; _i++) {
			node = _ref[_i];
			_results.push(this.expandFolder(node))
		}
		return _results
	};
	NFinderTreeController.prototype.cmCollapse = function () {
		var node, _i, _len, _ref, _results;
		_ref = this.selectedNodes;
		_results = [];
		for (_i = 0, _len = _ref.length; _len > _i; _i++) {
			node = _ref[_i];
			_results.push(this.collapseFolder(node))
		}
		return _results
	};
	NFinderTreeController.prototype.cmMakeTopFolder = function (nodeView) {
		return this.makeTopFolder(nodeView)
	};
	NFinderTreeController.prototype.cmRefresh = function (nodeView) {
		return this.refreshFolder(nodeView)
	};
	NFinderTreeController.prototype.cmToggleDotFiles = function (nodeView) {
		return this.toggleDotFiles(nodeView)
	};
	NFinderTreeController.prototype.cmResetVm = function (nodeView) {
		return this.resetVm(nodeView)
	};
	NFinderTreeController.prototype.cmUnmountVm = function (nodeView) {
		return this.unmountVm(nodeView)
	};
	NFinderTreeController.prototype.cmOpenVmTerminal = function (nodeView) {
		return this.openVmTerminal(nodeView)
	};
	NFinderTreeController.prototype.cmCreateFile = function (nodeView) {
		return this.createFile(nodeView)
	};
	NFinderTreeController.prototype.cmCreateFolder = function (nodeView) {
		return this.createFile(nodeView, "folder")
	};
	NFinderTreeController.prototype.cmRename = function (nodeView) {
		return this.showRenameDialog(nodeView)
	};
	NFinderTreeController.prototype.cmDelete = function (nodeView) {
		return this.confirmDelete(nodeView)
	};
	NFinderTreeController.prototype.cmDuplicate = function () {
		return this.duplicateFiles(this.selectedNodes)
	};
	NFinderTreeController.prototype.cmExtract = function (nodeView) {
		return this.extractFiles(nodeView)
	};
	NFinderTreeController.prototype.cmZip = function (nodeView) {
		return this.compressFiles(nodeView, "zip")
	};
	NFinderTreeController.prototype.cmTarball = function (nodeView) {
		return this.compressFiles(nodeView, "tar.gz")
	};
	NFinderTreeController.prototype.cmUpload = function (nodeView) {
		return this.uploadFile(nodeView)
	};
	NFinderTreeController.prototype.cmDownload = function () {
		return this.appManager.notify()
	};
	NFinderTreeController.prototype.cmGitHubClone = function () {
		return this.appManager.notify()
	};
	NFinderTreeController.prototype.cmOpenFile = function (nodeView) {
		return this.openFile(nodeView)
	};
	NFinderTreeController.prototype.cmPreviewFile = function (nodeView) {
		return this.previewFile(nodeView)
	};
	NFinderTreeController.prototype.cmCompile = function (nodeView) {
		return this.compileApp(nodeView)
	};
	NFinderTreeController.prototype.cmMakeNewApp = function (nodeView) {
		return this.makeNewApp(nodeView)
	};
	NFinderTreeController.prototype.cmPublish = function (nodeView) {
		return this.publishApp(nodeView)
	};
	NFinderTreeController.prototype.cmOpenFileWithApp = function (nodeView, contextMenuItem) {
		return this.openFileWithApp(nodeView, contextMenuItem)
	};
	NFinderTreeController.prototype.cmCloneRepo = function (nodeView) {
		return this.cloneRepo(nodeView)
	};
	NFinderTreeController.prototype.cmDropboxChooser = function (nodeView) {
		return this.chooseFromDropbox(nodeView)
	};
	NFinderTreeController.prototype.cmOpenTerminal = function (nodeView) {
		return this.openTerminalFromHere(nodeView)
	};
	NFinderTreeController.prototype.cmOpenFileWithCodeMirror = function () {
		return this.appManager.notify()
	};
	NFinderTreeController.prototype.createContextMenu = function (nodeView, event) {
		var contextMenu;
		event.stopPropagation();
		event.preventDefault();
		if (!nodeView.beingDeleted && !nodeView.beingEdited) {
			if (__indexOf.call(this.selectedNodes, nodeView) >= 0) contextMenu = this.contextMenuController.getContextMenu(this.selectedNodes, event);
			else {
				this.selectNode(nodeView);
				contextMenu = this.contextMenuController.getContextMenu([nodeView], event)
			}
			return !1
		}
	};
	NFinderTreeController.prototype.contextMenuItemSelected = function (nodeView, contextMenuItem) {
		var action, _name;
		action = contextMenuItem.getData().action;
		if (action) {
			null != this["cm" + action.capitalize()] && this.contextMenuController.destroyContextMenu();
			return "function" == typeof this[_name = "cm" + action.capitalize()] ? this[_name](nodeView, contextMenuItem) : void 0
		}
	};
	NFinderTreeController.prototype.resetBeingEditedItems = function () {
		return this.beingEdited.resetView()
	};
	NFinderTreeController.prototype.organizeSelectedNodes = function (listController, nodes, event) {
		null == event && (event = {});
		this.beingEdited && this.resetBeingEditedItems();
		return NFinderTreeController.__super__.organizeSelectedNodes.apply(this, arguments)
	};
	NFinderTreeController.prototype.showDragOverFeedback = function () {
		return NFinderTreeController.__super__.showDragOverFeedback.apply(this, arguments)
	};
	NFinderTreeController.prototype.clearDragOverFeedback = function () {
		return NFinderTreeController.__super__.clearDragOverFeedback.apply(this, arguments)
	};
	NFinderTreeController.prototype.clearAllDragFeedback = function () {
		return NFinderTreeController.__super__.clearAllDragFeedback.apply(this, arguments)
	};
	NFinderTreeController.prototype.click = function (nodeView, event) {
		if ($(event.target).is(".chevron")) {
			this.contextMenu(nodeView, event);
			return !1
		}
		if ($(event.target).is(".arrow")) {
			this.openItem(nodeView);
			return !1
		}
		return NFinderTreeController.__super__.click.apply(this, arguments)
	};
	NFinderTreeController.prototype.dblClick = function (nodeView) {
		return this.openItem(nodeView)
	};
	NFinderTreeController.prototype.contextMenu = function (nodeView, event) {
		return this.getOptions().contextMenu ? this.createContextMenu(nodeView, event) : void 0
	};
	NFinderTreeController.prototype.dragOver = function (nodeView, event) {
		this.showDragOverFeedback(nodeView, event);
		return NFinderTreeController.__super__.dragOver.apply(this, arguments)
	};
	NFinderTreeController.prototype.dragStart = function (nodeView, event) {
		var dndDownload, name, path, type, url, vmName, warningText, _ref;
		NFinderTreeController.__super__.dragStart.apply(this, arguments);
		this.internalDragging = !0;
		_ref = nodeView.data, name = _ref.name, vmName = _ref.vmName, path = _ref.path;
		warningText = "You should move " + name + " file to Web folder to download using drag and drop. -- Koding";
		type = "application/octet-stream";
		url = KD.getPublicURLOfPath(path);
		if (!url) {
			url = "data:" + type + ";base64," + btoa(warningText);
			name += ".txt"
		}
		dndDownload = "" + type + ":" + name + ":" + url;
		return event.originalEvent.dataTransfer.setData("DownloadURL", dndDownload)
	};
	lastEnteredNode = null;
	NFinderTreeController.prototype.dragEnter = function (nodeView, event) {
		var e, _ref, _ref1, _ref2;
		if (lastEnteredNode === nodeView || __indexOf.call(this.selectedNodes, nodeView) >= 0) return nodeView;
		lastEnteredNode = nodeView;
		clearTimeout(this.expandTimeout);
		("folder" === (_ref = nodeView.getData().type) || "mount" === _ref || "vm" === _ref) && (this.expandTimeout = setTimeout(function (_this) {
			return function () {
				return _this.expandFolder(nodeView)
			}
		}(this), 800));
		this.showDragOverFeedback(nodeView, event);
		e = event.originalEvent;
		this.boundaries.top > (_ref1 = e.pageY) && _ref1 > this.boundaries.top + 20 && log("trigger top scroll");
		this.boundaries.top + this.boundaries.height < (_ref2 = e.pageY) && _ref2 < this.boundaries.top + this.boundaries.height + 20 && log("trigger down scroll");
		return NFinderTreeController.__super__.dragEnter.apply(this, arguments)
	};
	NFinderTreeController.prototype.dragLeave = function (nodeView, event) {
		this.clearDragOverFeedback(nodeView, event);
		return NFinderTreeController.__super__.dragLeave.apply(this, arguments)
	};
	NFinderTreeController.prototype.dragEnd = function () {
		this.clearAllDragFeedback();
		this.internalDragging = !1;
		return NFinderTreeController.__super__.dragEnd.apply(this, arguments)
	};
	NFinderTreeController.prototype.drop = function (nodeView, event) {
		var _ref;
		if (!(__indexOf.call(this.selectedNodes, nodeView) >= 0 || "folder" !== (_ref = "function" == typeof nodeView.getData ? nodeView.getData().type : void 0) && "mount" !== _ref && "vm" !== _ref)) {
			this.selectedNodes = this.selectedNodes.filter(function (node) {
				var sourcePath, targetPath;
				targetPath = "function" == typeof nodeView.getData ? nodeView.getData().path : void 0;
				sourcePath = "function" == typeof node.getData ? node.getData().parentPath : void 0;
				return targetPath !== sourcePath
			});
			event.altKey ? this.copyFiles(this.selectedNodes, nodeView) : this.moveFiles(this.selectedNodes, nodeView);
			this.internalDragging = !1;
			return NFinderTreeController.__super__.drop.apply(this, arguments)
		}
	};
	NFinderTreeController.prototype.keyEventHappened = function () {
		return NFinderTreeController.__super__.keyEventHappened.apply(this, arguments)
	};
	NFinderTreeController.prototype.performDownKey = function (nodeView, event) {
		var offset;
		if (event.altKey) {
			offset = nodeView.$(".chevron").offset();
			event.pageY = offset.top;
			event.pageX = offset.left;
			return this.contextMenu(nodeView, event)
		}
		return NFinderTreeController.__super__.performDownKey.apply(this, arguments)
	};
	NFinderTreeController.prototype.performBackspaceKey = function (nodeView, event) {
		event.preventDefault();
		event.stopPropagation();
		this.confirmDelete(nodeView, event);
		return !1
	};
	NFinderTreeController.prototype.performEnterKey = function (nodeView) {
		this.selectNode(nodeView);
		return this.openItem(nodeView)
	};
	NFinderTreeController.prototype.performRightKey = function (nodeView) {
		var type;
		type = nodeView.getData().type;
		return /mount|folder|vm/.test(type) ? this.expandFolder(nodeView) : void 0
	};
	NFinderTreeController.prototype.performUpKey = function () {
		return NFinderTreeController.__super__.performUpKey.apply(this, arguments)
	};
	NFinderTreeController.prototype.performLeftKey = function (nodeView) {
		if (nodeView.expanded) {
			this.collapseFolder(nodeView);
			return !1
		}
		return NFinderTreeController.__super__.performLeftKey.apply(this, arguments)
	};
	notification = null;
	autoTriedOnce = !0;
	NFinderTreeController.prototype.hideNotification = function () {
		return notification ? notification.destroy() : void 0
	};
	NFinderTreeController.prototype.notify = function (msg, style, details, reconnect) {
		var duration;
		null == reconnect && (reconnect = !1);
		if (null != this.getView().parent) {
			notification && notification.destroy();
			details && !msg && /Permission denied/i.test(null != details ? details.message : void 0) && (msg = "Permission denied!");
			details && (style || (style = "error"));
			duration = reconnect ? 0 : details ? 5e3 : 2500;
			return notification = new KDNotificationView({
				title: msg || "Something went wrong",
				type: "finder-notification",
				cssClass: "" + style,
				container: this.getView().parent,
				duration: duration,
				details: details,
				click: function (_this) {
					return function () {
						if (reconnect) {
							_this.emit("fs.retry.scheduled");
							notification.notificationSetTitle("Attempting to fetch files");
							notification.notificationSetPositions();
							notification.setClass("loading");
							_this.utils.wait(6e3, notification.bound("destroy"));
							_this.once("fs.retry.success", notification.bound("destroy"))
						} else if (notification.getOptions().details) {
							details = new KDNotificationView({
								title: "Error details",
								content: notification.getOptions().details,
								type: "growl",
								duration: 0,
								click: function () {
									return details.destroy()
								}
							});
							KD.getSingleton("windowController").addLayer(details);
							return details.on("ReceivedClickElsewhere", function () {
								return details.destroy()
							})
						}
					}
				}(this)
			})
		}
	};
	NFinderTreeController.prototype.refreshTopNode = function () {
		var nickname;
		nickname = KD.whoami().profile.nickname;
		return this.refreshFolder(this.nodes["/home/" + nickname], function (_this) {
			return function () {
				return _this.emit("fs.retry.success")
			}
		}(this))
	};
	NFinderTreeController.prototype.chooseFromDropbox = function (nodeView) {
		var fileItemViews, filePath, kallback, modal;
		fileItemViews = [];
		filePath = FSHelper.plainPath(nodeView.getData().path);
		modal = null;
		kallback = function () {
			var file;
			file = fileItemViews[0];
			if (file) {
				file.emit("FileNeedsToBeDownloaded", filePath);
				return file.on("FileDownloadDone", function () {
					fileItemViews.shift();
					if (fileItemViews.length) return kallback();
					modal.destroy();
					return new KDNotificationView({
						title: "Your download has been completed",
						type: "mini",
						cssClass: "success",
						duration: 4e3
					})
				})
			}
		};
		return Dropbox.choose({
			linkType: "direct",
			multiselect: !0,
			success: function (files) {
				var file, fileItemView, _i, _len, _results;
				modal = new KDModalView({
					overlay: !0,
					title: "Download from Dropbox",
					buttons: {
						Start: {
							title: "Start",
							cssClass: "modal-clean-green",
							callback: function () {
								return kallback()
							}
						},
						Cancel: {
							title: "Cancel",
							cssClass: "modal-cancel",
							callback: function () {
								return modal.destroy()
							}
						}
					}
				});
				_results = [];
				for (_i = 0, _len = files.length; _len > _i; _i++) {
					file = files[_i];
					fileItemView = modal.addSubView(new DropboxDownloadItemView({
						nodeView: nodeView
					}, file));
					_results.push(fileItemViews.push(fileItemView))
				}
				return _results
			}
		})
	};
	NFinderTreeController.prototype.uploadFile = function (nodeView) {
		var finderController, path;
		finderController = this.getDelegate();
		path = nodeView.data.path;
		return path ? finderController.uploadTo(path) : void 0
	};
	return NFinderTreeController
}(JTreeViewController);
var NFinderContextMenuController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NFinderContextMenuController = function (_super) {
	function NFinderContextMenuController() {
		return NFinderContextMenuController.__super__.constructor.apply(this, arguments)
	}
	__extends(NFinderContextMenuController, _super);
	NFinderContextMenuController.prototype.getMenuItems = function (fileViews) {
		var fileView;
		if (fileViews.length > 1) return this.getMutilpleItemMenu(fileViews);
		fileView = fileViews[0];
		switch (fileView.getData().type) {
		case "vm":
			return this.getVmMenu(fileView);
		case "file":
			return this.getFileMenu(fileView);
		case "folder":
			return this.getFolderMenu(fileView);
		case "mount":
			return this.getMountMenu(fileView);
		case "brokenLink":
			return this.getBrokenLinkMenu(fileView)
		}
	};
	NFinderContextMenuController.prototype.getContextMenu = function (fileViews, event) {
		var fileView, items;
		this.contextMenu && this.contextMenu.destroy();
		items = this.getMenuItems(fileViews);
		fileView = fileViews[0];
		if (items) {
			this.contextMenu = new KDContextMenu({
				event: event,
				delegate: fileView,
				cssClass: "finder"
			}, items);
			this.contextMenu.on("ContextMenuItemReceivedClick", function (_this) {
				return function (contextMenuItem) {
					return _this.handleContextMenuClick(fileView, contextMenuItem)
				}
			}(this));
			return this.contextMenu
		}
		return !1
	};
	NFinderContextMenuController.prototype.destroyContextMenu = function () {
		return this.contextMenu.destroy()
	};
	NFinderContextMenuController.prototype.handleContextMenuClick = function (fileView, contextMenuItem) {
		return this.emit("ContextMenuItemClicked", {
			fileView: fileView,
			contextMenuItem: contextMenuItem
		})
	};
	NFinderContextMenuController.prototype.getFileMenu = function (fileView) {
		var fileData, items;
		fileData = fileView.getData();
		items = {
			"Open file": {
				separator: !0,
				action: "openFile"
			},
			Delete: {
				action: "delete",
				separator: !0
			},
			Rename: {
				action: "rename"
			},
			Duplicate: {
				action: "duplicate"
			},
			"Set permissions": {
				children: {
					customView: new NSetPermissionsView({}, fileData)
				}
			},
			Extract: {
				action: "extract"
			},
			Compress: {
				separator: !0,
				children: {
					"as .zip": {
						action: "zip"
					},
					"as .tar.gz": {
						action: "tarball"
					}
				}
			},
			"Public URL...": {
				separator: !0
			},
			"New file": {
				action: "createFile"
			},
			"New folder": {
				action: "createFolder"
			}
		};
		"archive" !== FSItem.getFileType(FSItem.getFileExtension(fileData.name)) ? delete items.Extract : delete items.Compress;
		FSHelper.isPublicPath(fileData.path) ? items["Public URL..."].children = {
			customView: new NCopyUrlView({}, fileData)
		} : delete items["Public URL..."];
		return items
	};
	NFinderContextMenuController.prototype.getFolderMenu = function (fileView) {
		var fileData, items, nickname;
		fileData = fileView.getData();
		items = {
			Expand: {
				action: "expand",
				separator: !0
			},
			Collapse: {
				action: "collapse",
				separator: !0
			},
			"Open with...": {
				children: this.getOpenWithMenuItems(fileView)
			},
			"Make this the top folder": {
				action: "makeTopFolder",
				separator: !0
			},
			Delete: {
				action: "delete",
				separator: !0
			},
			Rename: {
				action: "rename"
			},
			Duplicate: {
				action: "duplicate"
			},
			Compress: {
				children: {
					"as .zip": {
						action: "zip"
					},
					"as .tar.gz": {
						action: "tarball"
					}
				}
			},
			"Set permissions": {
				separator: !0,
				children: {
					customView: new NSetPermissionsView({}, fileData)
				}
			},
			"New file": {
				action: "createFile"
			},
			"New folder": {
				action: "createFolder"
			},
			"Upload file...": {
				action: "upload"
			},
			"Clone a repo here": {
				action: "cloneRepo",
				separator: !0
			},
			"Public URL...": {
				separator: !0
			},
			Refresh: {
				action: "refresh"
			}
		};
		fileView.expanded ? delete items.Expand : delete items.Collapse;
		FSHelper.isPublicPath(fileData.path) ? items["Public URL..."].children = {
			customView: new NCopyUrlView({}, fileData)
		} : delete items["Public URL..."];
		nickname = KD.whoami().profile.nickname;
		if (RegExp("/home/" + nickname + "/Applications$").test(fileData.path)) {
			items.Refresh.separator = !0;
			items["Make a new Application"] = {
				action: "makeNewApp"
			}
		}
		if ("kdapp" === fileData.getExtension()) {
			items.Refresh.separator = !0;
			items["Application menu"] = {
				children: {
					Compile: {
						action: "compile"
					},
					"Publish to app catalog": {
						action: "publish"
					}
				}
			}
		} else delete items["Open with..."];
		return items
	};
	NFinderContextMenuController.prototype.getBrokenLinkMenu = function (fileView) {
		var fileData, items;
		fileData = fileView.getData();
		items = {
			Delete: {
				action: "delete"
			}
		};
		return items
	};
	NFinderContextMenuController.prototype.getVmMenu = function (fileView) {
		var fileData, items;
		fileData = fileView.getData();
		items = {
			Refresh: {
				action: "refresh",
				separator: !0
			},
			"Unmount VM": {
				action: "unmountVm"
			},
			"Open VM terminal": {
				action: "openVmTerminal",
				separator: !0
			},
			Expand: {
				action: "expand",
				separator: !0
			},
			Collapse: {
				action: "collapse",
				separator: !0
			},
			"Toggle invisible files": {
				action: "toggleDotFiles",
				separator: !0
			},
			"New file": {
				action: "createFile"
			},
			"New folder": {
				action: "createFolder"
			},
			"Upload file...": {
				action: "upload"
			}
		};
		fileView.expanded ? delete items.Expand : delete items.Collapse;
		return items
	};
	NFinderContextMenuController.prototype.getMountMenu = function (fileView) {
		var fileData, items;
		fileData = fileView.getData();
		items = {
			Refresh: {
				action: "refresh",
				separator: !0
			},
			Expand: {
				action: "expand",
				separator: !0
			},
			Collapse: {
				action: "collapse",
				separator: !0
			},
			"New file": {
				action: "createFile"
			},
			"New folder": {
				action: "createFolder"
			},
			"Upload file...": {
				action: "upload"
			}
		};
		fileView.expanded ? delete items.Expand : delete items.Collapse;
		return items
	};
	NFinderContextMenuController.prototype.getMutilpleItemMenu = function (fileViews) {
		var fileView, items, types, _i, _len;
		types = {
			file: !1,
			folder: !1,
			mount: !1
		};
		for (_i = 0, _len = fileViews.length; _len > _i; _i++) {
			fileView = fileViews[_i];
			types[fileView.getData().type] = !0
		}
		if (types.file && !types.folder && !types.mount) return this.getMultipleFileMenu(fileViews);
		if (!types.file && types.folder && !types.mount) return this.getMultipleFolderMenu(fileViews);
		items = {
			Delete: {
				action: "delete",
				separator: !0
			},
			Duplicate: {
				action: "duplicate"
			},
			Compress: {
				children: {
					"as .zip": {
						action: "zip"
					},
					"as .tar.gz": {
						action: "tarball"
					}
				}
			}
		};
		return items
	};
	NFinderContextMenuController.prototype.getMultipleFolderMenu = function (folderViews) {
		var allCollapsed, allExpanded, folderView, items, multipleText, _i, _len;
		items = {
			Expand: {
				action: "expand",
				separator: !0
			},
			Collapse: {
				action: "collapse",
				separator: !0
			},
			Delete: {
				action: "delete",
				separator: !0
			},
			Duplicate: {
				action: "duplicate"
			},
			"Set permissions": {
				children: {
					customView: new NSetPermissionsView({}, {
						mode: "000",
						type: "multiple"
					})
				}
			},
			Compress: {
				children: {
					"as .zip": {
						action: "zip"
					},
					"as .tar.gz": {
						action: "tarball"
					}
				}
			}
		};
		multipleText = "Delete " + folderViews.length + " folders";
		items.Delete = items[multipleText] = {
			action: "delete"
		};
		allCollapsed = allExpanded = !0;
		for (_i = 0, _len = folderViews.length; _len > _i; _i++) {
			folderView = folderViews[_i];
			folderView.expanded ? allCollapsed = !1 : allExpanded = !1
		}
		allCollapsed && delete items.Collapse;
		allExpanded && delete items.Expand;
		return items
	};
	NFinderContextMenuController.prototype.getMultipleFileMenu = function (fileViews) {
		var items, multipleText;
		items = {
			"Open files": {
				action: "openFile"
			},
			Delete: {
				action: "delete",
				separator: !0
			},
			Duplicate: {
				action: "duplicate"
			},
			"Set permissions": {
				children: {
					customView: new NSetPermissionsView({}, {
						mode: "000"
					})
				}
			},
			Compress: {
				children: {
					"as .zip": {
						action: "zip"
					},
					"as .tar.gz": {
						action: "tarball"
					}
				}
			}
		};
		multipleText = "Delete " + fileViews.length + " files";
		items.Delete = items[multipleText] = {
			action: "delete"
		};
		return items
	};
	NFinderContextMenuController.prototype.getOpenWithMenuItems = function (fileView) {
		var fileExtension, items, path, plainPath, reWebHome, type, _ref;
		items = {};
		reWebHome = RegExp("/home/" + KD.nick() + "/Web/");
		_ref = fileView.getData(), path = _ref.path, type = _ref.type;
		plainPath = FSHelper.plainPath(path);
		fileExtension = FSItem.getFileExtension(path);
		plainPath.match(reWebHome) && (items.Viewer = {
			action: "previewFile"
		});
		"kdapp" === fileExtension && "folder" === type && (items.DevTools = {
			action: "openFileWithApp"
		});
		items.separator = {
			type: "separator"
		};
		items["Other apps"] = {
			disabled: !0
		};
		items["Search the app store"] = {
			disabled: !0
		};
		return items
	};
	return NFinderContextMenuController
}(KDController);
var NFinderItem, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NFinderItem = function (_super) {
	function NFinderItem(options, data) {
		var childConstructor;
		null == options && (options = {});
		options.tagName || (options.tagName = "li");
		options.type || (options.type = "finderitem");
		NFinderItem.__super__.constructor.call(this, options, data);
		this.isLoading = !1;
		this.beingDeleted = !1;
		this.beingEdited = !1;
		this.beingProgress = !1;
		childConstructor = function () {
			switch (data.type) {
			case "vm":
				return NVMItemView;
			case "folder":
				return NFolderItemView;
			case "section":
				return NSectionItemView;
			case "mount":
				return NMountItemView;
			case "brokenLink":
				return NBrokenLinkItemView;
			default:
				return NFileItemView
			}
		}();
		this.childView = new childConstructor({
			delegate: this
		}, data);
		this.childView.$().css("margin-left", 14 * data.depth);
		null != data.name && data.name.length > 20 - data.depth && this.childView.setAttribute("title", FSHelper.plainPath(data.name));
		this.on("ItemBeingDeleted", function () {
			return function () {
				return data.removeLocalFileInfo()
			}
		}(this));
		this.on("viewAppended", function (_this) {
			return function () {
				var fileInfo, lastUploadedChunk, totalChunks;
				fileInfo = data.getLocalFileInfo();
				if (fileInfo.lastUploadedChunk) {
					lastUploadedChunk = fileInfo.lastUploadedChunk, totalChunks = fileInfo.totalChunks;
					lastUploadedChunk === totalChunks && data.removeLocalFileInfo();
					return _this.showProgressView(100 * lastUploadedChunk / totalChunks)
				}
			}
		}(this))
	}
	__extends(NFinderItem, _super);
	JView.mixin(NFinderItem.prototype);
	NFinderItem.prototype.mouseDown = function () {
		return !0
	};
	NFinderItem.prototype.resetView = function () {
		if (this.deleteView) {
			this.deleteView.destroy();
			delete this.deleteView
		}
		if (this.renameView) {
			this.renameView.destroy();
			delete this.renameView
		}
		if (this.progressView) {
			this.progressView.destroy();
			delete this.progressView
		}
		this.childView.show();
		this.beingDeleted = !1;
		this.beingEdited = !1;
		this.beingProgress = !1;
		this.callback = null;
		this.unsetClass("being-deleted being-edited progress");
		return this.getDelegate().setKeyView()
	};
	NFinderItem.prototype.confirmDelete = function (callback) {
		this.callback = callback;
		return this.showDeleteView()
	};
	NFinderItem.prototype.showDeleteView = function () {
		var data;
		if (!this.deleteView) {
			this.setClass("being-deleted");
			this.beingDeleted = !0;
			this.childView.hide();
			data = this.getData();
			this.addSubView(this.deleteView = new NFinderItemDeleteView({}, data));
			this.deleteView.on("FinderDeleteConfirmation", function (_this) {
				return function (confirmation) {
					"function" == typeof _this.callback && _this.callback(confirmation);
					return _this.resetView()
				}
			}(this));
			return this.deleteView.setKeyView()
		}
	};
	NFinderItem.prototype.showRenameView = function (callback) {
		var data;
		if (!this.renameView) {
			this.setClass("being-edited");
			this.beingEdited = !0;
			this.callback = callback;
			this.childView.hide();
			data = this.getData();
			this.addSubView(this.renameView = new NFinderItemRenameView({}, data));
			this.renameView.$().css("margin-left", 10 * (data.depth + 1) + 2);
			this.renameView.on("FinderRenameConfirmation", function (_this) {
				return function (newValue) {
					"function" == typeof _this.callback && _this.callback(newValue);
					return _this.resetView()
				}
			}(this));
			return this.renameView.input.setFocus()
		}
	};
	NFinderItem.prototype.showProgressView = function (percent, determinate) {
		null == percent && (percent = 0);
		null == determinate && (determinate = !0);
		this.progressView || this.addSubView(this.progressView = new KDProgressBarView);
		this.progressView.setOption("determinate", determinate);
		this.progressView.updateBar(percent, "%", "");
		return percent >= 0 && 100 > percent ? this.setClass("progress") : this.utils.wait(1e3, function (_this) {
			return function () {
				return _this.resetView()
			}
		}(this))
	};
	NFinderItem.prototype.pistachio = function () {
		return "{{> this.childView}}"
	};
	return NFinderItem
}(JTreeItemView);
var NFileItemView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NFileItemView = function (_super) {
	function NFileItemView(options, data) {
		var eventName, fileData, _i, _len;
		null == options && (options = {});
		options.tagName || (options.tagName = "div");
		options.cssClass || (options.cssClass = "file");
		NFileItemView.__super__.constructor.call(this, options, data);
		fileData = this.getData();
		this.loader = new KDLoaderView({
			size: {
				width: 16
			},
			loaderOptions: {
				color: "#71BAA2",
				shape: "rect",
				diameter: 16,
				density: 12,
				range: 1,
				speed: 1,
				FPS: 24
			}
		});
		this.icon = new KDCustomHTMLView({
			tagName: "span",
			cssClass: "icon"
		});
		for (_i = 0, _len = loaderRequiredEvents.length; _len > _i; _i++) {
			eventName = loaderRequiredEvents[_i];
			fileData.on("fs." + eventName + ".started", function (_this) {
				return function () {
					return _this.showLoader()
				}
			}(this));
			fileData.on("fs." + eventName + ".finished", function (_this) {
				return function () {
					return _this.hideLoader()
				}
			}(this))
		}
	}
	var loaderRequiredEvents;
	__extends(NFileItemView, _super);
	JView.mixin(NFileItemView.prototype);
	loaderRequiredEvents = ["job", "remove", "save", "saveAs"];
	NFileItemView.prototype.destroy = function () {
		var eventName, fileData, _i, _len;
		fileData = this.getData();
		for (_i = 0, _len = loaderRequiredEvents.length; _len > _i; _i++) {
			eventName = loaderRequiredEvents[_i];
			fileData.off("fs." + eventName + ".started");
			fileData.off("fs." + eventName + ".finished")
		}
		return NFileItemView.__super__.destroy.apply(this, arguments)
	};
	NFileItemView.prototype.decorateItem = function () {
		var extension, fileType;
		extension = FSItem.getFileExtension(this.getData().name);
		if (extension) {
			fileType = FSItem.getFileType(extension);
			return this.icon.$().attr("class", "icon " + extension + " " + fileType)
		}
	};
	NFileItemView.prototype.render = function () {
		NFileItemView.__super__.render.apply(this, arguments);
		return this.decorateItem()
	};
	NFileItemView.prototype.mouseDown = function () {
		return !0
	};
	NFileItemView.prototype.viewAppended = function () {
		this.setTemplate(this.pistachio());
		this.template.update();
		this.hideLoader();
		return this.decorateItem()
	};
	NFileItemView.prototype.showLoader = function () {
		var _ref;
		null != (_ref = this.parent) && (_ref.isLoading = !0);
		this.icon.hide();
		return this.loader.show()
	};
	NFileItemView.prototype.hideLoader = function () {
		var _ref;
		null != (_ref = this.parent) && (_ref.isLoading = !1);
		this.icon.show();
		return this.loader.hide()
	};
	NFileItemView.prototype.pistachio = function () {
		var data, name, path;
		data = this.getData();
		path = FSHelper.plainPath(data.path);
		name = Encoder.XSSEncode(data.name);
		return "{{> this.icon}}\n{{> this.loader}}\n<span class='title' title=\"" + path + '">' + name + "</span>\n<span class='chevron'></span>"
	};
	return NFileItemView
}(KDCustomHTMLView);
var NFolderItemView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NFolderItemView = function (_super) {
	function NFolderItemView(options, data) {
		null == options && (options = {});
		options.cssClass || (options.cssClass = "folder");
		NFolderItemView.__super__.constructor.call(this, options, data)
	}
	__extends(NFolderItemView, _super);
	return NFolderItemView
}(NFileItemView);
var NMountItemView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NMountItemView = function (_super) {
	function NMountItemView(options, data) {
		null == options && (options = {});
		options.cssClass || (options.cssClass = "mount");
		NMountItemView.__super__.constructor.call(this, options, data)
	}
	__extends(NMountItemView, _super);
	return NMountItemView
}(NFileItemView);
var NBrokenLinkItemView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NBrokenLinkItemView = function (_super) {
	function NBrokenLinkItemView(options, data) {
		null == options && (options = {});
		options.cssClass || (options.cssClass = "broken");
		NBrokenLinkItemView.__super__.constructor.call(this, options, data)
	}
	__extends(NBrokenLinkItemView, _super);
	return NBrokenLinkItemView
}(NFileItemView);
var NSectionItemView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NSectionItemView = function (_super) {
	function NSectionItemView(options, data) {
		null == options && (options = {});
		options.cssClass || (options.cssClass = "section");
		NSectionItemView.__super__.constructor.call(this, options, data)
	}
	__extends(NSectionItemView, _super);
	return NSectionItemView
}(NFileItemView);
var NVMItemView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NVMItemView = function (_super) {
	function NVMItemView(options, data) {
		null == options && (options = {});
		options.cssClass || (options.cssClass = "vm");
		NVMItemView.__super__.constructor.call(this, options, data);
		this.vm = KD.getSingleton("vmController");
		this.vm.on("StateChanged", this.bound("checkVMState"));
		this.changePathButton = new KDCustomHTMLView({
			tagName: "span",
			cssClass: "path-select",
			delegate: this,
			click: this.bound("createRootContextMenu")
		});
		this.vmInfo = new KDCustomHTMLView({
			tagName: "span",
			cssClass: "vm-info",
			partial: "on <strong>" + data.vmName + "</strong> VM"
		});
		this.vm.fetchVMDomains(data.vmName, function (_this) {
			return function (err, domains) {
				return !err && domains.length > 0 ? _this.vmInfo.updatePartial('on <a id="open-vm-page-' + data.vmName + '"\nhref="http://' + domains.first + '" target="_blank">\n' + domains.first + "</a> VM") : void 0
			}
		}(this))
	}
	__extends(NVMItemView, _super);
	NVMItemView.prototype.showLoader = function () {
		var _ref;
		null != (_ref = this.parent) && (_ref.isLoading = !0);
		return this.loader.show()
	};
	NVMItemView.prototype.hideLoader = function () {
		var _ref;
		null != (_ref = this.parent) && (_ref.isLoading = !1);
		return this.loader.hide()
	};
	NVMItemView.prototype.createRootContextMenu = function () {
		var contextMenu, currentPath, finder, nodes, offset, parents, path, vm, width, x, _i, _ref;
		offset = this.changePathButton.$().offset();
		currentPath = this.getData().path;
		width = 30 + 3 * currentPath.length;
		contextMenu = new KDContextMenu({
			menuWidth: width,
			delegate: this.changePathButton,
			x: offset.left - 106,
			y: offset.top + 22,
			arrow: {
				placement: "top",
				margin: 108
			},
			lazyLoad: !0
		}, {});
		parents = [];
		nodes = currentPath.split("/");
		for (x = _i = 0, _ref = nodes.length - 1; _ref >= 0 ? _ref > _i : _i > _ref; x = _ref >= 0 ? ++_i : --_i) {
			nodes = currentPath.split("/");
			path = nodes.splice(1, x).join("/");
			parents.push("/" + path)
		}
		parents.reverse();
		vm = this.getData().vmName;
		finder = this.getData().treeController.getDelegate();
		return this.utils.defer(function () {
			parents.forEach(function (path) {
				return contextMenu.treeController.addNode({
					title: path,
					callback: function () {
						return null != finder ? finder.updateVMRoot(vm, path, contextMenu.bound("destroy")) : void 0
					}
				})
			});
			contextMenu.positionContextMenu();
			return contextMenu.treeController.selectFirstNode()
		})
	};
	NVMItemView.prototype.checkVMState = function (err, vm, info) {
		if (vm === this.getData().vmName) {
			if (err || !info) {
				this.unsetClass("online");
				return warn(err)
			}
			return "RUNNING" === info.state ? this.setClass("online") : this.unsetClass("online")
		}
	};
	NVMItemView.prototype.viewAppended = function () {
		var _ref;
		NVMItemView.__super__.viewAppended.apply(this, arguments);
		return null != (_ref = this.getData().getKite()) ? _ref.vmInfo().nodeify(this.bound("checkVMState")) : void 0
	};
	NVMItemView.prototype.pistachio = function () {
		var path;
		path = FSHelper.plainPath(this.getData().path);
		return '{{> this.icon}}\n{{> this.loader}}\n{span.title[title="' + path + "\"]{ #(name)}}\n{{> this.changePathButton}}\n{{> this.vmInfo}}\n<span class='chevron'></span>"
	};
	return NVMItemView
}(NFileItemView);
var NFinderItemDeleteView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NFinderItemDeleteView = function (_super) {
	function NFinderItemDeleteView() {
		NFinderItemDeleteView.__super__.constructor.apply(this, arguments);
		this.setClass("delete-container");
		this.button = new KDButtonView({
			title: "Delete",
			style: "clean-red",
			callback: function (_this) {
				return function () {
					return _this.emit("FinderDeleteConfirmation", !0)
				}
			}(this)
		});
		this.cancel = new KDCustomHTMLView({
			tagName: "a",
			attributes: {
				href: "#",
				title: "Cancel"
			},
			cssClass: "cancel",
			click: function (_this) {
				return function () {
					return _this.emit("FinderDeleteConfirmation", !1)
				}
			}(this)
		});
		this.label = new KDLabelView({
			title: "Are you sure?"
		})
	}
	__extends(NFinderItemDeleteView, _super);
	NFinderItemDeleteView.prototype.viewAppended = function () {
		NFinderItemDeleteView.__super__.viewAppended.apply(this, arguments);
		return this.button.$().focus()
	};
	NFinderItemDeleteView.prototype.pistachio = function () {
		return "{{> this.label}}\n{{> this.button}}\n{{> this.cancel}}"
	};
	NFinderItemDeleteView.prototype.keyDown = function (event) {
		switch (event.which) {
		case 27:
			this.emit("FinderDeleteConfirmation", !1);
			return !1;
		case 9:
			if (!this.button.$().is(":focus")) {
				this.button.$().focus();
				return !1
			}
		}
	};
	return NFinderItemDeleteView
}(JView);
var NFinderDeleteDialog, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NFinderDeleteDialog = function (_super) {
	function NFinderDeleteDialog(options, data) {
		var callback, items, numFiles;
		null == options && (options = {});
		items = data.items;
		callback = data.callback;
		numFiles = "" + items.length + " item" + (items.length > 1 ? "s" : "");
		options.title = "Do you really want to delete " + numFiles;
		options.content = "";
		options.overlay = !0;
		options.cssClass = "new-kdmodal";
		options.width = 500;
		options.height = "auto";
		options.buttons = {};
		options.buttons["Yes, delete " + numFiles] = {
			style: "modal-clean-red",
			callback: function (_this) {
				return function () {
					"function" == typeof callback && callback(!0);
					return _this.destroy()
				}
			}(this)
		};
		options.buttons.cancel = {
			style: "modal-cancel",
			callback: function (_this) {
				return function () {
					"function" == typeof callback && callback(!1);
					return _this.destroy()
				}
			}(this)
		};
		NFinderDeleteDialog.__super__.constructor.call(this, options, data);
		KD.getSingleton("windowController").setKeyView(null)
	}
	__extends(NFinderDeleteDialog, _super);
	NFinderDeleteDialog.prototype.viewAppended = function () {
		var fileView, item, items, scrollView, _i, _len;
		items = this.getData().items;
		this.$().css({
			top: 75
		});
		scrollView = new KDScrollView({
			cssClass: "modalformline file-container"
		});
		scrollView.$().css({
			maxHeight: KD.getSingleton("windowController").winHeight - 250
		});
		for (_i = 0, _len = items.length; _len > _i; _i++) {
			item = items[_i];
			scrollView.addSubView(fileView = new KDCustomHTMLView({
				tagName: "p",
				cssClass: "delete-file " + item.getData().type,
				partial: "<span class='icon'></span>" + item.getData().name
			}))
		}
		return this.addSubView(scrollView)
	};
	NFinderDeleteDialog.prototype.destroy = function () {
		KD.getSingleton("windowController").revertKeyView();
		return NFinderDeleteDialog.__super__.destroy.apply(this, arguments)
	};
	return NFinderDeleteDialog
}(KDModalView);
var NFinderItemRenameView, NFinderRenameInput, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NFinderItemRenameView = function (_super) {
	function NFinderItemRenameView(options, data) {
		NFinderItemRenameView.__super__.constructor.apply(this, arguments);
		this.setClass("rename-container");
		this.input = new NFinderRenameInput({
			defaultValue: data.name,
			type: "text",
			callback: function (_this) {
				return function (newValue) {
					return _this.emit("FinderRenameConfirmation", newValue)
				}
			}(this),
			keyup: function (_this) {
				return function (event) {
					return 27 === event.which ? _this.emit("FinderRenameConfirmation", data.name) : void 0
				}
			}(this)
		});
		KD.getSingleton("windowController").addLayer(this.input);
		this.cancel = new KDCustomHTMLView({
			tagName: "a",
			attributes: {
				href: "#",
				title: "Cancel"
			},
			cssClass: "cancel",
			click: function (_this) {
				return function () {
					return _this.emit("FinderRenameConfirmation", data.name)
				}
			}(this)
		})
	}
	__extends(NFinderItemRenameView, _super);
	NFinderItemRenameView.prototype.pistachio = function () {
		return "{{> this.input}}\n{{> this.cancel}}"
	};
	return NFinderItemRenameView
}(JView);
NFinderRenameInput = function (_super) {
	function NFinderRenameInput(options, data) {
		null == options && (options = {});
		NFinderRenameInput.__super__.constructor.call(this, options, data);
		this.once("viewAppended", this.bound("selectAll"))
	}
	__extends(NFinderRenameInput, _super);
	NFinderRenameInput.prototype.click = function () {
		return !1
	};
	NFinderRenameInput.prototype.dblClick = function () {
		return !1
	};
	return NFinderRenameInput
}(KDHitEnterInputView);
var NSetPermissionsView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NSetPermissionsView = function (_super) {
	function NSetPermissionsView() {
		NSetPermissionsView.__super__.constructor.apply(this, arguments);
		this.switches = [];
		this.setPermissionsButton = new KDButtonView({
			title: "Set",
			style: "solid green small",
			callback: function (_this) {
				return function () {
					var file, permissions, recursive;
					permissions = _this.getPermissions();
					recursive = _this.recursive.getValue() || !1;
					file = _this.getData();
					return file.chmod({
						permissions: permissions,
						recursive: recursive
					}, function (err) {
						return err ? void 0 : _this.displayOldOctalPermissions()
					})
				}
			}(this)
		});
		this.recursive = new KodingSwitch({
			size: "tiny"
		})
	}
	var permissionsToOctalString;
	__extends(NSetPermissionsView, _super);
	permissionsToOctalString = function (permissions) {
		var str;
		str = permissions.toString(8);
		for (; str.length < 3;) str = "0" + str;
		return str.slice(-3)
	};
	NSetPermissionsView.prototype.createSwitches = function (permission) {
		var i, _i, _results;
		_results = [];
		for (i = _i = 0; 9 > _i; i = ++_i) _results.push(this.switches.push(new KodingSwitch({
			size: "tiny",
			defaultValue: 0 !== (permission & 1 << i),
			callback: function (_this) {
				return function () {
					return _this.displayOctalPermissions()
				}
			}(this)
		})));
		return _results
	};
	NSetPermissionsView.prototype.getPermissions = function () {
		var i, permissions, s, _i, _len, _ref;
		permissions = 0;
		_ref = this.switches;
		for (i = _i = 0, _len = _ref.length; _len > _i; i = ++_i) {
			s = _ref[i];
			s.getValue() && (permissions |= 1 << i)
		}
		return permissions
	};
	NSetPermissionsView.prototype.displayOctalPermissions = function () {
		return this.$("footer p.new em").html(permissionsToOctalString(this.getPermissions()))
	};
	NSetPermissionsView.prototype.displayOldOctalPermissions = function () {
		return this.$("footer p.old em").html(permissionsToOctalString(this.getData().mode))
	};
	NSetPermissionsView.prototype.viewAppended = function () {
		var _ref;
		this.setClass("set-permissions-wrapper");
		this.applyExistingPermissions();
		NSetPermissionsView.__super__.viewAppended.apply(this, arguments);
		return "folder" === (_ref = this.getData().type) || "multiple" === _ref ? this.$(".recursive").removeClass("hidden") : void 0
	};
	NSetPermissionsView.prototype.pistachio = function () {
		var mode;
		mode = this.getData().mode;
		return null == mode ? '<header class="clearfix"><div>Unknown file permissions</div></header>' : '<header class="clearfix"><span>Read</span><span>Write</span><span>Execute</span></header>\n<aside class="permissions"><p>Owner:</p><p>Group:</p><p>Everyone:</p></aside>\n<section class="switch-holder clearfix">\n  <div class="kdview switcher-group">\n    {{> this.switches[8]}}\n    {{> this.switches[5]}}\n    {{> this.switches[2]}}\n  </div>\n  <div class="kdview switcher-group">\n    {{> this.switches[7]}}\n    {{> this.switches[4]}}\n    {{> this.switches[1]}}\n  </div>\n  <div class="kdview switcher-group">\n    {{> this.switches[6]}}\n    {{> this.switches[3]}}\n    {{> this.switches[0]}}\n  </div>\n</section>\n<footer class="clearfix">\n  <div class="recursive hidden">\n    <label>Apply to Enclosed Items</label>\n    {{> this.recursive}}\n  </div>\n  <p class="old">Old: <em></em></p>\n  <p class="new">New: <em></em></p>\n  {{> this.setPermissionsButton}}\n</footer>'
	};
	NSetPermissionsView.prototype.applyExistingPermissions = function () {
		var mode, setPermissionsView;
		setPermissionsView = this;
		mode = this.getData().mode;
		this.getData().newMode = mode;
		this.createSwitches(mode);
		return setTimeout(function (_this) {
			return function () {
				_this.displayOctalPermissions();
				return _this.displayOldOctalPermissions()
			}
		}(this), 0)
	};
	return NSetPermissionsView
}(JView);
var NVMToggleButtonView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NVMToggleButtonView = function (_super) {
	function NVMToggleButtonView(options, data) {
		NVMToggleButtonView.__super__.constructor.call(this, {
			cssClass: "vm-toggle-menu"
		}, data);
		this.vm = KD.getSingleton("vmController");
		this.vm.on("StateChanged", this.bound("checkVMState"));
		this.menuTitle = new KDCustomHTMLView({
			tagName: "span",
			partial: "Fetching VM state..."
		});
		this.toggle = new KDOnOffSwitch({
			cssClass: "tiny vm-toggle-item hidden",
			callback: function (_this) {
				return function (state) {
					return state ? _this.vm.start(_this.getData().vmName) : _this.vm.stop(_this.getData().vmName)
				}
			}(this)
		});
		this.loader = new KDLoaderView({
			cssClass: "vm-toggle-item",
			showLoader: !0,
			size: {
				width: 12
			},
			loaderOptions: {
				speed: .7,
				FPS: 24
			}
		})
	}
	__extends(NVMToggleButtonView, _super);
	NVMToggleButtonView.prototype.checkVMState = function (err, vm, info) {
		var _ref;
		if (vm === this.getData().vmName) {
			if (err || !info) {
				null != (_ref = this.notification) && _ref.destroy();
				this.notification = new KDNotificationView({
					type: "mini",
					cssClass: "error",
					duration: 5e3,
					title: "Still waiting... This VM is booting slowly."
				});
				this.toggle.setDefaultValue(!1);
				return warn(err)
			}
			this.toggle.setDefaultValue("RUNNING" === info.state ? !0 : !1);
			this.menuTitle.updatePartial("Change state");
			this.toggle.show();
			return this.loader.hide()
		}
	};
	NVMToggleButtonView.prototype.pistachio = function () {
		return "{{> this.menuTitle}}{{> this.toggle}}{{> this.loader}}"
	};
	NVMToggleButtonView.prototype.viewAppended = function () {
		NVMToggleButtonView.__super__.viewAppended.apply(this, arguments);
		this.loader.show();
		return this.vm.info(this.getData().vmName, this.bound("checkVMState"))
	};
	return NVMToggleButtonView
}(JView);
var NMountToggleButtonView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
NMountToggleButtonView = function (_super) {
	function NMountToggleButtonView(options, data) {
		var _ref;
		NMountToggleButtonView.__super__.constructor.call(this, {
			cssClass: "vm-toggle-menu",
			defaultLabel: null != (_ref = options.defaultLabel) ? _ref : "<span>Show in Filetree</span>"
		}, data);
		this.toggle = new KDOnOffSwitch({
			cssClass: "tiny vm-toggle-item",
			callback: function (_this) {
				return function (state) {
					var fc;
					fc = KD.getSingleton("finderController");
					return state ? fc.mountVm(_this.getData().vmName) : fc.unmountVm(_this.getData().vmName)
				}
			}(this)
		})
	}
	__extends(NMountToggleButtonView, _super);
	NMountToggleButtonView.prototype.checkMountState = function () {
		return this.toggle.setDefaultValue(!1)
	};
	NMountToggleButtonView.prototype.pistachio = function () {
		return "" + this.getOption("defaultLabel") + "{{> this.toggle}}"
	};
	NMountToggleButtonView.prototype.viewAppended = function () {
		NMountToggleButtonView.__super__.viewAppended.apply(this, arguments);
		return this.checkMountState()
	};
	return NMountToggleButtonView
}(JView);
var NCopyUrlView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__slice = [].slice;
NCopyUrlView = function (_super) {
	function NCopyUrlView() {
		var hostname, path;
		NCopyUrlView.__super__.constructor.apply(this, arguments);
		path = this.getData().path;
		hostname = FSHelper.getVMNameFromPath(path);
		this.publicPath = FSHelper.isPublicPath(path);
		this.inputUrlLabel = new KDLabelView({
			cssClass: "public-url-label",
			title: "Public URL",
			click: function (_this) {
				return function () {
					return _this.focusAndSelectAll()
				}
			}(this)
		});
		this.inputUrl = new KDInputView({
			label: this.inputUrlLabel,
			cssClass: "public-url-input",
			attributes: {
				readonly: !0
			}
		});
		KD.getSingleton("vmController").fetchVMDomains(hostname, function (_this) {
			return function (err, domains) {
				var URI, match, pathrest, rest, subdomain, user, _i;
				if ((null != domains ? domains.length : void 0) > 0 && !err) {
					path = FSHelper.plainPath(path);
					match = path.match(/home\/(\w+)\/Web\/(.*)/);
					if (!match) return;
					rest = 3 <= match.length ? __slice.call(match, 0, _i = match.length - 2) : (_i = 0, []), user = match[_i++], pathrest = match[_i++];
					subdomain = /^shared-/.test(hostname) ? user !== KD.nick() ? "" : "" + user + "." : "";
					_this.publicPath = "" + subdomain + domains.first + "/" + pathrest;
					URI = "http://" + _this.publicPath;
					_this.inputUrl.setValue(URI);
					_this.focusAndSelectAll();
					if (!_this.newPageLink) return _this.addSubView(_this.newPageLink = new CustomLinkView({
						cssClass: "icon-link",
						title: "",
						href: URI,
						target: URI,
						icon: {
							cssClass: "new-page",
							placement: "right"
						}
					}))
				}
			}
		}(this))
	}
	__extends(NCopyUrlView, _super);
	NCopyUrlView.prototype.focusAndSelectAll = function () {
		this.inputUrl.setFocus();
		return this.inputUrl.selectAll()
	};
	NCopyUrlView.prototype.viewAppended = function () {
		this.setClass("copy-url-wrapper");
		return NCopyUrlView.__super__.viewAppended.apply(this, arguments)
	};
	NCopyUrlView.prototype.pistachio = function () {
		return this.publicPath ? "{{> this.inputUrlLabel}}\n{{> this.inputUrl}}" : '<div class="public-url-warning">This ' + this.getData().type + " can not be reached over a public URL</div>"
	};
	return NCopyUrlView
}(JView);
var FSHelper, __hasProp = {}.hasOwnProperty;
FSHelper = function () {
	function FSHelper() {}
	var getFileName, parseWatcherFile;
	parseWatcherFile = function (_arg) {
		var createdAt, file, group, mode, name, osKite, parentPath, path, size, treeController, type, user, vmName;
		vmName = _arg.vmName, parentPath = _arg.parentPath, file = _arg.file, user = _arg.user, treeController = _arg.treeController, osKite = _arg.osKite;
		name = file.name, size = file.size, mode = file.mode;
		type = file.isBroken ? "brokenLink" : file.isDir ? "folder" : "file";
		path = parentPath === "[" + vmName + "]/" ? "[" + vmName + "]/" + name : "" + parentPath + "/" + name;
		group = user;
		createdAt = file.time;
		return {
			size: size,
			user: user,
			group: group,
			createdAt: createdAt,
			mode: mode,
			type: type,
			parentPath: parentPath,
			path: path,
			name: name,
			vmName: vmName,
			treeController: treeController,
			osKite: osKite
		}
	};
	FSHelper.handleStdErr = function () {
		return function (result) {
			var exitStatus, stderr, stdout;
			stdout = result.stdout, stderr = result.stderr, exitStatus = result.exitStatus;
			if (exitStatus > 0) throw new Error("std error: " + stderr);
			return result
		}
	};
	FSHelper.parseWatcher = function (_arg) {
		var data, file, files, nickname, osKite, parentPath, partition, sortFiles, sortedFiles, treeController, vmName, _i, _len, _ref;
		vmName = _arg.vmName, parentPath = _arg.parentPath, files = _arg.files, treeController = _arg.treeController, osKite = _arg.osKite;
		data = [];
		if (!files) return data;
		Array.isArray(files) || (files = [files]);
		_ref = KD.utils, partition = _ref.partition, sortFiles = _ref.sortFiles;
		sortedFiles = partition(files.sort(sortFiles), function (file) {
			return file.isDir
		}).reduce(function (acc, next) {
			return acc.concat(next)
		});
		nickname = KD.nick();
		for (_i = 0, _len = sortedFiles.length; _len > _i; _i++) {
			file = sortedFiles[_i];
			data.push(FSHelper.createFile(parseWatcherFile({
				vmName: vmName,
				parentPath: parentPath,
				file: file,
				nickname: nickname,
				treeController: treeController
			})))
		}
		return data
	};
	FSHelper.folderOnChange = function (_arg) {
		var change, file, node, npath, path, treeController, vmName, _ref, _results;
		vmName = _arg.vmName, path = _arg.path, change = _arg.change, treeController = _arg.treeController;
		if (treeController) {
			file = this.parseWatcher({
				vmName: vmName,
				parentPath: path,
				files: change.file,
				treeController: treeController
			})[0];
			switch (change.event) {
			case "added":
				return treeController.addNode(file);
			case "removed":
				_ref = treeController.nodes;
				_results = [];
				for (npath in _ref)
					if (__hasProp.call(_ref, npath)) {
						node = _ref[npath];
						if (npath === file.path) {
							treeController.removeNodeView(node);
							break
						}
						_results.push(void 0)
					}
				return _results
			}
		}
	};
	FSHelper.plainPath = function (path) {
		return path.replace(/^\[.*\]/, "")
	};
	FSHelper.getVMNameFromPath = function (path) {
		var _ref;
		return null != (_ref = /^\[([^\]]+)\]/g.exec(path)) ? _ref[1] : void 0
	};
	FSHelper.minimizePath = function (path) {
		return this.plainPath(path).replace(RegExp("^/home/" + KD.nick()), "~")
	};
	FSHelper.exists = function (path, vmName, callback) {
		null == callback && (callback = noop);
		return this.getInfo(path, vmName, function (err, res) {
			return callback(err, null != res)
		})
	};
	FSHelper.getInfo = function (path, vmName, callback) {
		null == callback && (callback = noop);
		return KD.getSingleton("vmController").run({
			method: "fs.getInfo",
			vmName: vmName,
			withArgs: {
				path: path,
				vmName: vmName
			}
		}, callback)
	};
	FSHelper.glob = function (pattern, vmName, callback) {
		var _ref;
		"function" == typeof vmName && (_ref = [callback, vmName], vmName = _ref[0], callback = _ref[1]);
		return KD.getSingleton("vmController").run({
			method: "fs.glob",
			vmName: vmName,
			withArgs: {
				pattern: pattern,
				vmName: vmName
			}
		}, callback)
	};
	FSHelper.uniquePath = function (path, vmName, callback) {
		null == callback && (callback = noop);
		return KD.getSingleton("vmController").run({
			method: "fs.uniquePath",
			vmName: vmName,
			withArgs: {
				path: path,
				vmName: vmName
			}
		}, callback)
	};
	FSHelper.registry = {};
	FSHelper.resetRegistry = function () {
		return this.registry = {}
	};
	FSHelper.register = function (file) {
		this.setFileListeners(file);
		return this.registry[file.path] = file
	};
	FSHelper.unregister = function (path) {
		return delete this.registry[path]
	};
	FSHelper.unregisterVmFiles = function (vmName) {
		var file, path, _ref, _results;
		_ref = this.registry;
		_results = [];
		for (path in _ref)
			if (__hasProp.call(_ref, path)) {
				file = _ref[path];
				0 === path.indexOf("[" + vmName + "]") && _results.push(this.unregister(path))
			}
		return _results
	};
	FSHelper.updateInstance = function (fileData) {
		var prop, value, _results;
		_results = [];
		for (prop in fileData)
			if (__hasProp.call(fileData, prop)) {
				value = fileData[prop];
				_results.push(this.registry[fileData.path][prop] = value)
			}
		return _results
	};
	FSHelper.setFileListeners = function (file) {
		return file.on("fs.job.finished", function () {
			return function () {}
		}(this))
	};
	FSHelper.getFileNameFromPath = getFileName = function (path) {
		return path.split("/").pop()
	};
	FSHelper.trimExtension = function (path) {
		var name;
		name = getFileName(path);
		return name.split(".").shift()
	};
	FSHelper.getParentPath = function (path) {
		var parentPath;
		"/" === path.substr(-1) && (path = path.substr(0, path.length - 1));
		parentPath = path.split("/");
		parentPath.pop();
		return parentPath.join("/")
	};
	FSHelper.createFileFromPath = function (path, type, dummy) {
		var name, parentPath, vmName;
		null == type && (type = "file");
		null == dummy && (dummy = !1);
		if (!path) return warn("pass a path to create a file instance");
		vmName = this.getVMNameFromPath(path) || null;
		vmName && (path = this.plainPath(path));
		parentPath = this.getParentPath(path);
		name = this.getFileNameFromPath(path);
		return this.createFile({
			path: path,
			parentPath: parentPath,
			name: name,
			type: type,
			vmName: vmName,
			dummy: dummy
		})
	};
	FSHelper.createFile = function (options) {
		var constructor, instance;
		if (!(options && options.type && options.path)) return warn("pass a path and type to create a file instance");
		null == options.vmName && (options.vmName = KD.getSingleton("vmController").defaultVmName);
		if (this.registry[options.path]) {
			instance = this.registry[options.path];
			this.updateInstance(options)
		} else {
			constructor = function () {
				switch (options.type) {
				case "vm":
					return FSVm;
				case "folder":
					return FSFolder;
				case "mount":
					return FSMount;
				case "symLink":
					return FSFolder;
				case "brokenLink":
					return FSBrokenLink;
				default:
					return FSFile
				}
			}();
			instance = new constructor(options);
			this.register(instance)
		}
		return instance
	};
	FSHelper.createRecursiveFolder = function (_arg, callback) {
		var path, vmName;
		path = _arg.path, vmName = _arg.vmName;
		null == callback && (callback = noop);
		return path ? KD.getSingleton("vmController").run({
			method: "fs.createDirectory",
			withArgs: {
				recursive: !0,
				path: path
			},
			vmName: vmName
		}, callback) : warn("Pass a path to create folders recursively")
	};
	FSHelper.isValidFileName = function (name) {
		return /^([a-zA-Z]:\\)?[^\x00-\x1F"<>\|:\*\?/]+$/.test(name)
	};
	FSHelper.isEscapedPath = function (path) {
		return /^\s\"/.test(path)
	};
	FSHelper.escapeFilePath = function (name) {
		return FSHelper.plainPath(name.replace(/\'/g, "\\'").replace(/\"/g, '\\"').replace(/\ /g, "\\ "))
	};
	FSHelper.unescapeFilePath = function (name) {
		return name.replace(/^(\s\")/g, "").replace(/(\"\s)$/g, "").replace(/\\\'/g, "'").replace(/\\"/g, '"')
	};
	FSHelper.isPublicPath = function (path) {
		return /^\/home\/.*\/Web\//.test(FSHelper.plainPath(path))
	};
	FSHelper.convertToRelative = function (path) {
		return path.replace(/^\//, "").replace(/(.+?)\/?$/, "$1/")
	};
	FSHelper.isUnwanted = function (path, isFile) {
		var dummyFilePatterns, dummyFolderPatterns;
		null == isFile && (isFile = !1);
		dummyFilePatterns = /\.DS_Store|Thumbs.db/;
		dummyFolderPatterns = /\.git|__MACOSX/;
		return isFile ? dummyFilePatterns.test(path) : dummyFolderPatterns.test(path)
	};
	FSHelper.s3 = {
		get: function (name) {
			return "" + KD.config.uploadsUri + "/" + KD.whoami().getId() + "/" + name
		},
		getGroupRelated: function (group, name) {
			return "" + KD.config.uploadsUriForGroup + "/" + group + "/" + name
		},
		upload: function (name, content, bucket, path, callback) {
			var args;
			args = {
				name: name,
				bucket: bucket,
				path: path,
				content: content
			};
			return KD.getSingleton("vmController").run({
				method: "s3.store",
				withArgs: args
			}, function (err) {
				var filePath;
				if (err) return callback(err);
				filePath = "groups" === bucket ? FSHelper.s3.getGroupRelated(path, name) : FSHelper.s3.get(name);
				return callback(null, filePath)
			})
		},
		remove: function (name, callback) {
			var vmController;
			vmController = KD.getSingleton("vmController");
			return vmController.run({
				method: "s3.delete",
				withArgs: {
					name: name
				}
			}, callback)
		}
	};
	FSHelper.getPathHierarchy = function (fullPath) {
		var node, nodes, path, queue, subPath, vmName, _ref;
		_ref = KD.getPathInfo(fullPath), path = _ref.path, vmName = _ref.vmName;
		path = path.replace(/^~/, "/home/" + KD.nick());
		nodes = path.split("/").filter(function (node) {
			return !!node
		});
		queue = function () {
			var _i, _len, _results;
			_results = [];
			for (_i = 0, _len = nodes.length; _len > _i; _i++) {
				node = nodes[_i];
				subPath = nodes.join("/");
				nodes.pop();
				_results.push("[" + vmName + "]/" + subPath)
			}
			return _results
		}();
		queue.push("[" + vmName + "]/");
		return queue
	};
	FSHelper.chunkify = function (data, chunkSize) {
		var chunks;
		chunks = [];
		for (; data;) {
			if (data.length < chunkSize) {
				chunks.push(data);
				break
			}
			chunks.push(data.substr(0, chunkSize));
			data = data.substr(chunkSize)
		}
		return chunks
	};
	FSHelper.getFullPath = function (file) {
		var plainPath;
		plainPath = this.plainPath(file.path);
		return "[" + file.vmName + "]" + plainPath
	};
	return FSHelper
}();
KD.classes.FSHelper = FSHelper;
var FSWatcher, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
FSWatcher = function (_super) {
	function FSWatcher(options) {
		null == options && (options = {});
		null == options.recursive && (options.recursive = !0);
		null == options.ignoreTempChanges && (options.ignoreTempChanges = !0);
		FSWatcher.__super__.constructor.call(this, options);
		this.path = this.getOption("path")
	}
	__extends(FSWatcher, _super);
	FSWatcher.watchers = {};
	FSWatcher.registerWatcher = function (path, stopWatching) {
		return this.watchers[path] = {
			stop: stopWatching
		}
	};
	FSWatcher.stopAllWatchers = function () {
		var path, watcher, _ref;
		_ref = this.watchers;
		for (path in _ref)
			if (__hasProp.call(_ref, path)) {
				watcher = _ref[path];
				watcher.stop()
			}
		return this.watchers = {}
	};
	FSWatcher.stopWatching = function (pathToStop) {
		var path, watcher, _ref, _results;
		_ref = this.watchers;
		_results = [];
		for (path in _ref)
			if (__hasProp.call(_ref, path)) {
				watcher = _ref[path];
				if (0 === path.indexOf(pathToStop)) {
					watcher.stop();
					_results.push(delete this.watchers[path])
				}
			}
		return _results
	};
	FSWatcher.prototype.watch = function (callback) {
		var vmController;
		vmController = KD.getSingleton("vmController");
		this.vmName || (this.vmName = this.getOption("vmName") || vmController.defaultVmName);
		if (!this.vmName) return "function" == typeof callback ? callback({
			message: "No VM provided!"
		}) : void 0;
		FSWatcher.stopWatching(this.getFullPath());
		return vmController.run({
			method: "fs.readDirectory",
			vmName: this.vmName,
			withArgs: {
				onChange: function (_this) {
					return function (change) {
						return _this.changeHappened(_this.path, change)
					}
				}(this),
				path: FSHelper.plainPath(this.path),
				watchSubdirectories: this.getOption("recursive")
			}
		}, function (_this) {
			return function (err, response) {
				var files;
				if (!err && (null != response ? response.files : void 0)) {
					files = FSHelper.parseWatcher({
						vmName: _this.vmName,
						parentPath: _this.path,
						files: response.files
					});
					FSWatcher.registerWatcher(_this.getFullPath(), response.stopWatching);
					return "function" == typeof callback ? callback(err, files) : void 0
				}
				return "function" == typeof callback ? callback(err, null) : void 0
			}
		}(this))
	};
	FSWatcher.prototype.fileAdded = function () {};
	FSWatcher.prototype.folderAdded = function () {};
	FSWatcher.prototype.fileRemoved = function () {};
	FSWatcher.prototype.fileChanged = function () {};
	FSWatcher.prototype.changeHappened = function (path, change) {
		if (!this.getOption("ignoreTempChanges") || !/^\.|\~$/.test(change.file.name)) switch (change.event) {
		case "added":
			return change.file.isDir ? this.folderAdded(change) : this.fileAdded(change);
		case "removed":
			return this.fileRemoved(change);
		case "attributesChanged":
			return this.fileChanged(change)
		}
	};
	FSWatcher.prototype.stopWatching = function () {
		return FSWatcher.stopWatching(this.getFullPath())
	};
	FSWatcher.prototype.getFullPath = function () {
		return "[" + this.vmName + "]" + this.path
	};
	return FSWatcher
}(KDObject);
var FSItem, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__slice = [].slice;
FSItem = function (_super) {
	function FSItem(options) {
		var key, value;
		for (key in options)
			if (__hasProp.call(options, key)) {
				value = options[key];
				this[key] = value
			}
		FSItem.__super__.constructor.apply(this, arguments);
		this.vmController = KD.getSingleton("vmController")
	}
	var escapeFilePath, handleStdErr;
	__extends(FSItem, _super);
	escapeFilePath = FSHelper.escapeFilePath, handleStdErr = FSHelper.handleStdErr;
	FSItem.create = function (_arg, callback) {
		var kite, path, treeController, type, vmName;
		path = _arg.path, type = _arg.type, vmName = _arg.vmName, treeController = _arg.treeController;
		kite = FSItem.getKite({
			vmName: vmName
		});
		return kite.vmOn().then(function () {
			var method, options, plainPath;
			plainPath = FSHelper.plainPath(path);
			method = "folder" === type ? "fsCreateDirectory" : "fsWriteFile";
			options = {
				path: plainPath,
				content: "",
				donotoverwrite: !0
			};
			return kite.fsUniquePath({
				path: plainPath
			}).then(function (actualPath) {
				options.path = actualPath;
				return kite[method](options).then(function () {
					return FSHelper.createFile({
						path: actualPath,
						type: type,
						vmName: vmName
					})
				})
			}).nodeify(callback)
		})
	};
	FSItem.copyOrMove = function (sourceItem, targetItem, commandPrefix, callback) {
		var file, kite, targetPath;
		sourceItem.emit("fs.job.started");
		kite = sourceItem.getKite();
		targetPath = FSHelper.plainPath("" + targetItem.path + "/" + sourceItem.name);
		file = null;
		return kite.vmOn().then(function () {
			return kite.fsUniquePath({
				path: targetPath
			}).then(function (actualPath) {
				var command;
				command = "" + commandPrefix + " " + escapeFilePath(sourceItem.path) + " " + escapeFilePath(actualPath);
				return kite.exec({
					command: command
				}).then(handleStdErr()).then(function () {
					file = FSHelper.createFile({
						path: actualPath,
						parentPath: targetItem.path,
						name: sourceItem.name,
						type: sourceItem.type,
						vmName: sourceItem.vmName
					});
					return file
				})
			})
		}).nodeify(callback)["finally"](function () {
			sourceItem.emit("fs.job.finished");
			return file
		})
	};
	FSItem.copy = function (sourceItem, targetItem, callback) {
		return this.copyOrMove(sourceItem, targetItem, "cp -R", callback)
	};
	FSItem.move = function (sourceItem, targetItem, callback) {
		var newName;
		newName = FSHelper.plainPath("" + targetItem.path + "/" + sourceItem.name);
		return sourceItem.rename({
			path: newName
		}, callback)
	};
	FSItem.compress = function (file, type, callback) {
		var kite, path;
		file.emit("fs.job.started");
		kite = file.getKite();
		path = FSHelper.plainPath("" + file.path + "." + type);
		return kite.vmOn().then(function () {
			return kite.fsUniquePath({
				path: path
			})
		}).then(function (actualPath) {
			var command;
			command = "tar.gz" === type ? "tar -pczf " + escapeFilePath(actualPath) + " " + escapeFilePath(file.path) : "zip -r " + escapeFilePath(actualPath) + " " + escapeFilePath(file.path);
			return kite.exec({
				command: command
			})
		}).then(handleStdErr()).nodeify(callback)["finally"](function () {
			return file.emit("fs.job.finished")
		})
	};
	FSItem.extract = function (file, callback) {
		var extractFolder, isTarGz, kite, path, tarPattern, zipPattern, _ref;
		null == callback && (callback = function () {});
		file.emit("fs.job.started");
		kite = file.getKite();
		tarPattern = /\.tar\.gz$/;
		zipPattern = /\.zip$/;
		path = FSHelper.plainPath(file.path);
		_ref = function () {
			switch (!1) {
			case !tarPattern.test(file.name):
				return [!0, path.replace(tarPattern, "")];
			case !zipPattern.test(file.name):
				return [!1, path.replace(zipPattern, "")]
			}
		}(), isTarGz = _ref[0], extractFolder = _ref[1];
		return kite.vmOn().then(function () {
			return kite.fsUniquePath({
				path: "" + extractFolder
			})
		}).then(function (actualPath) {
			var command;
			command = isTarGz ? "cd " + escapeFilePath(file.parentPath) + ";mkdir -p " + escapeFilePath(actualPath) + ";tar -zxf " + escapeFilePath(file.name) + " -C " + escapeFilePath(actualPath) : "cd " + escapeFilePath(file.parentPath) + ";unzip -o " + escapeFilePath(file.name) + " -d " + escapeFilePath(actualPath);
			return kite.exec({
				command: command
			})
		}).then(handleStdErr()).then(function () {
			file = FSHelper.createFile({
				path: actualPath,
				parentPath: file.parentPath,
				type: "folder",
				vmName: file.vmName
			});
			return file
		}).nodeify(callback)["finally"](function () {
			return file.emit("fs.job.finished")
		})
	};
	FSItem.getFileExtension = function (path) {
		var extension, fileName, name, _ref;
		fileName = path || "";
		_ref = fileName.split("."), name = _ref[0], extension = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
		return extension = 0 === extension.length ? "" : extension.last
	};
	FSItem.getFileType = function (extension) {
		var ext, fileType, set, type, _extension_sets, _i, _len;
		fileType = null;
		_extension_sets = {
			code: ["php", "pl", "py", "jsp", "asp", "htm", "html", "phtml", "shtml", "sh", "cgi", "htaccess", "fcgi", "wsgi", "mvc", "xml", "sql", "rhtml", "js", "json", "coffee", "css", "styl", "sass", "erb"],
			text: ["txt", "doc", "rtf", "csv", "docx", "pdf"],
			archive: ["zip", "gz", "bz2", "tar", "7zip", "rar", "gzip", "bzip2", "arj", "cab", "chm", "cpio", "deb", "dmg", "hfs", "iso", "lzh", "lzma", "msi", "nsis", "rpm", "udf", "wim", "xar", "z", "jar", "ace", "7z", "uue"],
			image: ["png", "gif", "jpg", "jpeg", "bmp", "svg", "psd", "qt", "qtif", "qif", "qti", "tif", "tiff", "aif", "aiff"],
			video: ["avi", "mp4", "h264", "mov", "mpg", "ra", "ram", "mpg", "mpeg", "m4a", "3gp", "wmv", "flv", "swf", "wma", "rm", "rpm", "rv", "webm"],
			sound: ["aac", "au", "gsm", "mid", "midi", "snd", "wav", "3g2", "mp3", "asx", "asf"],
			app: ["kdapp"]
		};
		for (type in _extension_sets)
			if (__hasProp.call(_extension_sets, type)) {
				set = _extension_sets[type];
				for (_i = 0, _len = set.length; _len > _i; _i++) {
					ext = set [_i];
					if (extension === ext) {
						fileType = type;
						break
					}
				}
				if (fileType) break
			}
		return fileType || "unknown"
	};
	FSItem.isHidden = function (name) {
		return /^\./.test(name)
	};
	FSItem.prototype.getExtension = function () {
		return FSItem.getFileExtension(this.name)
	};
	FSItem.prototype.getPath = function () {
		return FSHelper.plainPath(this.path)
	};
	FSItem.prototype.isHidden = function () {
		return FSItem.isHidden(this.name)
	};
	FSItem.prototype.exists = function (callback) {
		var kite;
		null == callback && (callback = noop);
		kite = this.getKite();
		return kite.vmOn().then(function (_this) {
			return function () {
				return kite.fsExists({
					path: _this.getPath()
				})
			}
		}(this)).nodeify(callback)
	};
	FSItem.prototype.stat = function (callback) {
		var kite;
		null == callback && (callback = noop);
		kite = this.getKite();
		return kite.vmOn().then(function (_this) {
			return function () {
				return kite.fsGetInfo({
					path: _this.getPath()
				})
			}
		}(this)).nodeify(callback)
	};
	FSItem.prototype.remove = function (callback, recursive) {
		var kite;
		null == recursive && (recursive = !1);
		this.emit("fs.delete.started");
		kite = this.getKite();
		return kite.vmOn().then(function (_this) {
			return function () {
				return kite.fsRemove({
					path: _this.getPath(),
					recursive: recursive
				})
			}
		}(this)).nodeify(callback).then(function (_this) {
			return function () {
				return _this.emit("fs.delete.finished")
			}
		}(this))
	};
	FSItem.prototype.rename = function (_arg, callback) {
		var kite, newName, newPath;
		newName = _arg.name, newPath = _arg.path;
		null == newPath && (newPath = FSHelper.plainPath("" + this.parentPath + "/" + newName));
		this.emit("fs.job.started");
		kite = this.getKite();
		return kite.vmOn().then(function (_this) {
			return function () {
				return kite.fsRename({
					oldpath: _this.getPath(),
					newpath: newPath
				})
			}
		}(this)).nodeify(callback).then(function (_this) {
			return function () {
				return _this.emit("fs.job.finished")
			}
		}(this))
	};
	FSItem.prototype.chmod = function (options, callback) {
		var kite, mode, recursive;
		recursive = options.recursive, mode = options.permissions;
		this.mode = mode;
		if (null == mode) return "function" == typeof callback ? callback(new Error("no permissions passed")) : void 0;
		this.emit("fs.job.started");
		kite = this.getKite();
		return kite.vmOn().then(function (_this) {
			return function () {
				return kite.fsSetPermissions({
					path: _this.getPath(),
					recursive: recursive,
					mode: mode
				})
			}
		}(this)).nodeify(callback).then(function (_this) {
			return function () {
				return _this.emit("fs.job.started")
			}
		}(this))
	};
	FSItem.prototype.getKite = function () {
		return this.options.dummy ? null : FSItem.getKite({
			vm: this.vm,
			vmName: this.vmName
		})
	};
	FSItem.getKite = function (_arg) {
		var kontrol, vm, vmName;
		vm = _arg.vm, vmName = _arg.vmName;
		if (KD.useNewKites) {
			kontrol = KD.getSingleton("kontrol");
			return kontrol.getKite(null != vm ? {
				name: "oskite",
				correlationName: vm.hostnameAlias,
				region: vm.region
			} : {
				name: "oskite",
				correlationName: vmName
			})
		}
		return KD.getSingleton("vmController").getKiteByVmName(vmName)
	};
	return FSItem
}(KDObject);
var FSFile, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
FSFile = function (_super) {
	function FSFile() {
		FSFile.__super__.constructor.apply(this, arguments);
		this.on("file.requests.saveAs", function (_this) {
			return function (contents, name, parentPath) {
				return _this.saveAs(contents, name, parentPath)
			}
		}(this));
		this.on("file.requests.save", function (_this) {
			return function (contents) {
				return _this.save(contents)
			}
		}(this));
		this.localStorage = KD.getSingleton("localStorageController").storage("Finder");
		this.fileInfo = this.getLocalFileInfo()
	}
	__extends(FSFile, _super);
	FSFile.prototype.getLocalFileInfo = function () {
		return this.localStorage.getValue(btoa(KD.utils.utf8Encode(FSHelper.plainPath(this.path)))) || {}
	};
	FSFile.prototype.setLocalFileInfo = function (data) {
		var key, value;
		null == data && (data = {});
		for (key in data)
			if (__hasProp.call(data, key)) {
				value = data[key];
				this.fileInfo[key] = value
			}
		return this.localStorage.setValue(btoa(KD.utils.utf8Encode(FSHelper.plainPath(this.path))), this.fileInfo)
	};
	FSFile.prototype.removeLocalFileInfo = function () {
		return this.localStorage.unsetKey(btoa(KD.utils.utf8Encode(FSHelper.plainPath(this.path))))
	};
	FSFile.prototype.fetchContentsBinary = function (callback) {
		return this.fetchContents(!1, callback)
	};
	FSFile.prototype.fetchRawContents = function (callback) {
		var kite;
		kite = this.getKite();
		return kite.vmOn().then(function (_this) {
			return function () {
				return kite.fsReadFile({
					path: FSHelper.plainPath(_this.path)
				})
			}
		}(this)).nodeify(callback)
	};
	FSFile.prototype.fetchContents = function (useEncoding, callback) {
		var _ref;
		callback || (_ref = [useEncoding, callback], callback = _ref[0], useEncoding = _ref[1]);
		null == useEncoding && (useEncoding = !0);
		this.emit("fs.job.started");
		return this.fetchRawContents().then(function (_this) {
			return function (response) {
				var content;
				content = atob(response.content);
				useEncoding && (content = KD.utils.utf8Decode(content));
				KD.mixpanel("Fetch contents, success");
				_this.emit("fs.job.finished");
				return content
			}
		}(this)).nodeify(callback)
	};
	FSFile.prototype.saveAs = function (contents, name, parentPath, callback) {
		var file, kite, newPath;
		this.emit("fs.saveAs.started");
		newPath = FSHelper.plainPath("" + parentPath + "/" + name);
		file = null;
		kite = this.getKite();
		return kite.vmOn().then(function (_this) {
			return function () {
				var ok;
				return ok = kite.fsUniquePath({
					path: "" + newPath
				}).then(function (actualPath) {
					file = FSHelper.createFile({
						type: "file",
						path: actualPath,
						vmName: _this.vmName
					});
					ok = file.save(contents);
					null != callback && (ok = ok["catch"](function (err) {
						return callback(err)
					}).then(function () {
						return callback(null, file, _this)
					}));
					return ok
				}).then(function () {
					_this.emit("fs.saveAs.finished", file, _this);
					return file
				})
			}
		}(this))
	};
	FSFile.prototype.append = function (contents, callback) {
		var content, kite, ok;
		this.emit("fs.append.started");
		content = btoa(contents);
		kite = this.getKite();
		ok = kite.startVm().then(function (_this) {
			return function () {
				return kite.fsWriteFile({
					path: FSHelper.plainPath(_this.path),
					content: btoa(contents),
					append: !0
				})
			}
		}(this));
		return null != callback ? ok.then(function (_this) {
			return function (response) {
				callback(null, response);
				return _this.emit("fs.append.finished", null, response)
			}
		}(this))["catch"](function (err) {
			warn(err);
			callback(err);
			return this.emit("fs.append.finished", err)
		}) : ok.then(function (_this) {
			return function (response) {
				_this.emit("fs.append.finished", null, response);
				return Promise.cast(response)
			}
		}(this))
	};
	FSFile.createChunkQueue = function (data, chunkSize, skip) {
		var chunk, chunks, index, isSkip, queue, _i, _len;
		null == chunkSize && (chunkSize = 1048576);
		null == skip && (skip = 0);
		if (data) {
			chunks = FSHelper.chunkify(data, chunkSize);
			queue = [];
			for (index = _i = 0, _len = chunks.length; _len > _i; index = ++_i) {
				chunk = chunks[index];
				isSkip = skip > index;
				queue.push({
					content: isSkip ? void 0 : btoa(chunk),
					skip: isSkip,
					append: queue.length > 0
				})
			}
			return queue
		}
	};
	FSFile.prototype.saveBinary = function (contents, callback) {
		var chunkQueue, info, iterateChunks, total;
		info = this.getLocalFileInfo();
		chunkQueue = FSFile.createChunkQueue(contents, null, info.lastUploadedChunk);
		total = chunkQueue.length;
		this.setLocalFileInfo({
			totalChunks: total
		});
		this.on("ChunkUploaded", function (_this) {
			return function (response) {
				var loaded, percent;
				loaded = total - chunkQueue.length;
				percent = 100 * loaded / total;
				_this.setLocalFileInfo({
					lastUploadedChunk: loaded
				});
				return "function" == typeof callback ? callback(null, response, {
					total: total,
					loaded: loaded,
					percent: percent
				}) : void 0
			}
		}(this));
		this.once("AllChunksUploaded", function (_this) {
			return function () {
				_this.off("ChunkUploaded");
				_this.removeLocalFileInfo();
				return "function" == typeof callback ? callback(null, {
					finished: !0
				}) : void 0
			}
		}(this));
		this.once("AbortRequested", function (_this) {
			return function () {
				_this.abortRequested = !0;
				return "function" == typeof callback ? callback(null, {
					abort: !0
				}) : void 0
			}
		}(this));
		iterateChunks = function (_this) {
			return function () {
				var append, content, next, skip;
				chunkQueue.length || _this.emit("AllChunksUploaded");
				next = chunkQueue.shift();
				if (next && !_this.abortRequested) {
					skip = next.skip, content = next.content, append = next.append;
					if (!skip) return _this.vmController.run({
						method: "fs.writeFile",
						vmName: _this.vmName,
						withArgs: {
							path: FSHelper.plainPath(_this.path),
							content: content,
							append: append
						}
					}, function (err, res) {
						if (err) return "function" == typeof callback ? callback(err) : void 0;
						_this.emit("ChunkUploaded", res);
						return iterateChunks()
					});
					callback(null, {}, {
						percent: 100 * info.lastUploadedChunk / info.totalChunks
					});
					iterateChunks()
				}
			}
		}(this);
		return chunkQueue.length > 0 ? iterateChunks() : void 0
	};
	FSFile.prototype.abort = function () {
		return this.emit("AbortRequested")
	};
	FSFile.prototype.save = function (contents, callback, useEncoding) {
		var ok;
		null == contents && (contents = "");
		null == callback && (callback = null);
		null == useEncoding && (useEncoding = !0);
		this.emit("fs.save.started");
		ok = this.getKite().vmOn().then(function (_this) {
			return function () {
				var content;
				useEncoding && (contents = KD.utils.utf8Encode(contents));
				content = btoa(contents);
				return _this.getKite().fsWriteFile({
					path: FSHelper.plainPath(_this.path),
					content: content
				})
			}
		}(this));
		return null != callback ? ok.then(function (_this) {
			return function (response) {
				callback(null, response);
				return _this.emit("fs.save.finished", null, response)
			}
		}(this))["catch"](function (_this) {
			return function (err) {
				callback(err);
				return _this.emit("fs.save.finished", err)
			}
		}(this)) : ok.then(function (_this) {
			return function (response) {
				_this.emit("fs.save.finished", null, response);
				return response
			}
		}(this))
	};
	return FSFile
}(FSItem);
var FSFolder, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
FSFolder = function (_super) {
	function FSFolder() {
		return FSFolder.__super__.constructor.apply(this, arguments)
	}
	__extends(FSFolder, _super);
	FSFolder.prototype.fetchContents = function (dontWatch, callback) {
		var kite, treeController, _ref;
		null == callback && (_ref = [dontWatch, callback], callback = _ref[0], dontWatch = _ref[1]);
		null == dontWatch && (dontWatch = !0);
		treeController = this.getOptions().treeController;
		kite = this.getKite();
		return kite.vmOn().then(function (_this) {
			return function () {
				return kite.fsReadDirectory({
					path: FSHelper.plainPath(_this.path),
					onChange: dontWatch ? null : function (change) {
						return FSHelper.folderOnChange({
							vmName: _this.vmName,
							path: _this.path,
							change: change,
							treeController: treeController
						})
					}
				})
			}
		}(this)).then(function (_this) {
			return function (response) {
				var files;
				return files = null != (null != response ? response.files : void 0) ? FSHelper.parseWatcher({
					vmName: _this.vmName,
					parentPath: _this.path,
					files: response.files,
					treeController: treeController
				}) : []
			}
		}(this)).nodeify(callback).then(function (_this) {
			return function () {
				return _this.emit("fs.job.finished")
			}
		}(this))
	};
	FSFolder.prototype.save = function (callback) {
		this.emit("fs.save.started");
		return this.getKite().vmOn().then(function (_this) {
			return function () {
				return _this.vmController.fsCreateDirectory({
					path: FSHelper.plainPath(_this.path)
				})
			}
		}(this)).nodeify(function (err, response) {
			callback(null, response);
			return this.emit("fs.save.finished", null, response)
		})
	};
	FSFolder.prototype.saveAs = function (callback) {
		log("Not implemented yet.");
		return "function" == typeof callback ? callback(null) : void 0
	};
	FSFolder.prototype.remove = function (callback) {
		this.off("fs.delete.finished");
		this.on("fs.delete.finished", function (_this) {
			return function () {
				var finder;
				finder = _this.treeController.delegate;
				return null != finder ? finder.stopWatching(_this.path) : void 0
			}
		}(this));
		return FSFolder.__super__.remove.call(this, callback, !0)
	};
	FSFolder.prototype.registerWatcher = function (response) {
		var finder;
		this.stopWatching = response.stopWatching;
		finder = this.treeController.delegate;
		return this.stopWatching && null != finder ? finder.registerWatcher(this.path, this.stopWatching) : void 0
	};
	return FSFolder
}(FSFile);
var FSMount, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
FSMount = function (_super) {
	function FSMount() {
		return FSMount.__super__.constructor.apply(this, arguments)
	}
	__extends(FSMount, _super);
	return FSMount
}(FSFolder);
var FSBrokenLink, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
FSBrokenLink = function (_super) {
	function FSBrokenLink() {
		return FSBrokenLink.__super__.constructor.apply(this, arguments)
	}
	__extends(FSBrokenLink, _super);
	return FSBrokenLink
}(FSItem);
var FSVm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
FSVm = function (_super) {
	function FSVm() {
		return FSVm.__super__.constructor.apply(this, arguments)
	}
	__extends(FSVm, _super);
	return FSVm
}(FSFolder);
var AppsWatcher, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	},
	__indexOf = [].indexOf || function (item) {
		for (var i = 0, l = this.length; l > i; i++)
			if (i in this && this[i] === item) return i;
		return -1
	};
AppsWatcher = function (_super) {
	function AppsWatcher(options) {
		null == options && (options = {});
		options.path = "~/Applications";
		AppsWatcher.__super__.constructor.call(this, options);
		this._trackedApps = []
	}
	var getAppName, isInKdApp, isKdApp, isManifest, throttle;
	__extends(AppsWatcher, _super);
	AppsWatcher.prototype.folderAdded = function (change) {
		var app;
		if (isKdApp(change)) {
			app = getAppName(change);
			return throttle(function (_this) {
				return function () {
					return _this.emit("NewAppIsAdded", app, change)
				}
			}(this))
		}
	};
	AppsWatcher.prototype.fileRemoved = function (change) {
		var app, _app;
		if (isKdApp(change) || isManifest(change)) {
			app = getAppName(change);
			this._trackedApps = function () {
				var _i, _len, _ref, _results;
				_ref = this._trackedApps;
				_results = [];
				for (_i = 0, _len = _ref.length; _len > _i; _i++) {
					_app = _ref[_i];
					_app !== app && _results.push(_app)
				}
				return _results
			}.call(this);
			return throttle(function (_this) {
				return function () {
					return _this.emit("AppIsRemoved", app, change)
				}
			}(this))
		}
		if (isInKdApp(change)) {
			app = getAppName(change);
			return throttle(function (_this) {
				return function () {
					return _this.emit("FileIsRemoved", app, change)
				}
			}(this))
		}
	};
	AppsWatcher.prototype.fileAdded = function (change) {
		var app;
		if (isInKdApp(change)) {
			app = getAppName(change);
			if (!isManifest(change)) return throttle(function (_this) {
				return function () {
					return _this.emit("FileIsAdded", app, change)
				}
			}(this));
			if (__indexOf.call(this._trackedApps, app) < 0) {
				this._trackedApps.push(app);
				return throttle(function (_this) {
					return function () {
						return _this.emit("NewAppIsAdded", app, change)
					}
				}(this))
			}
		}
	};
	AppsWatcher.prototype.fileChanged = function (change) {
		var app;
		if (isInKdApp(change)) {
			app = getAppName(change);
			if (!isManifest(change)) return throttle(function (_this) {
				return function () {
					return _this.emit("FileHasChanged", app, change)
				}
			}(this));
			if (__indexOf.call(this._trackedApps, app) >= 0) return throttle(function (_this) {
				return function () {
					return _this.emit("ManifestHasChanged", app, change)
				}
			}(this))
		}
	};
	isKdApp = function (change) {
		return /\.kdapp$/.test(change.file.fullPath)
	};
	isInKdApp = function (change) {
		return /Applications\/.*\.kdapp/.test(change.file.fullPath)
	};
	isManifest = function (change) {
		return /manifest\.json$/.test(change.file.fullPath)
	};
	getAppName = function (change) {
		var _ref;
		return null != (_ref = change.file.fullPath.match(/Applications\/([^\/]+)\.kdapp/)) ? _ref[1] : void 0
	};
	throttle = function (cb) {
		return KD.utils.throttle(300, cb)()
	};
	return AppsWatcher
}(FSWatcher);
var LoginAppsController, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LoginAppsController = function (_super) {
	function LoginAppsController(options, data) {
		null == options && (options = {});
		options.view = new LoginView({
			testPath: "landing-login"
		});
		options.appInfo = {
			name: "Login"
		};
		LoginAppsController.__super__.constructor.call(this, options, data)
	}
	__extends(LoginAppsController, _super);
	KD.registerAppClass(LoginAppsController, {
		name: "Login"
	});
	LoginAppsController.prototype.prepareFinishRegistrationForm = function (token) {
		var JPasswordRecovery;
		JPasswordRecovery = KD.remote.api.JPasswordRecovery;
		return JPasswordRecovery.fetchRegistrationDetails(token, function (_this) {
			return function (err, details) {
				var view;
				view = _this.getView();
				if (!err) {
					view.finishRegistrationForm.setRegistrationDetails(details);
					view.setCustomDataToForm("finishRegistration", {
						recoveryToken: token
					});
					return view.animateToForm("finishRegistration")
				}
				KD.showError(err);
				view.animateToForm("login")
			}
		}(this))
	};
	LoginAppsController.prototype.headBannerShowInvitation = function (invite) {
		var view;
		view = this.getView();
		return view.headBannerShowInvitation(invite)
	};
	LoginAppsController.prototype.setStorageData = function (key, value) {
		this.appStorage = KD.getSingleton("appStorageController").storage("Login", "1.0");
		return this.appStorage.fetchStorage(function (_this) {
			return function () {
				return _this.appStorage.setValue(key, value, function (err) {
					return err ? warn("Failed to set " + key + " information") : void 0
				})
			}
		}(this))
	};
	return LoginAppsController
}(AppController);
var LoginView, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LoginView = function (_super) {
	function LoginView(options, data) {
		var entryPoint, handler, homeHandler, loginHandler, mainController, recoverHandler, registerHandler, setValue;
		null == options && (options = {});
		entryPoint = KD.config.entryPoint;
		options.cssClass = "hidden";
		LoginView.__super__.constructor.call(this, options, data);
		this.setCss("background-image", "url('../a/images/unsplash/" + backgroundImageNr + ".jpg')");
		this.hidden = !0;
		handler = function () {
			return function (route, event) {
				stop(event);
				return KD.getSingleton("router").handleRoute(route, {
					entryPoint: entryPoint
				})
			}
		}(this);
		homeHandler = handler.bind(null, "/");
		loginHandler = handler.bind(null, "/Login");
		registerHandler = handler.bind(null, "/Register");
		recoverHandler = handler.bind(null, "/Recover");
		this.logo = new KDCustomHTMLView({
			tagName: "a",
			cssClass: "koding-logo",
			partial: "<cite></cite>",
			click: function (event) {
				KD.utils.stopDOMEvent(event);
				return homeHandler()
			}
		});
		this.backToLoginLink = new KDCustomHTMLView({
			tagName: "a",
			partial: "Sign In",
			click: function () {
				KD.mixpanel("Login button form in /Login, click");
				return loginHandler()
			}
		});
		this.goToRecoverLink = new KDCustomHTMLView({
			tagName: "a",
			cssClass: "forgot-link",
			partial: "Forgot your password?",
			testPath: "landing-recover-password",
			click: recoverHandler
		});
		this.goToRegisterLink = new KDCustomHTMLView({
			tagName: "a",
			partial: "Sign up",
			click: function () {
				KD.mixpanel("Register button form in /Login, click");
				return registerHandler()
			}
		});
		this.formHeader = new KDCustomHTMLView({
			tagName: "h4",
			cssClass: "form-header"
		});
		this.github = new KDCustomHTMLView(KD.utils.oauthEnabled() === !0 ? {
			tagName: "a",
			cssClass: "github-login",
			partial: "Sign in using <strong>GitHub</strong>",
			click: function () {
				KD.mixpanel("Github auth button in /Login, click");
				return KD.singletons.oauthController.openPopup("github")
			}
		} : {
			tagName: "a",
			cssClass: "github-login",
			partial: "<a href='http://koding.com'>Learn more</a>"
		});
		this.github.setPartial("<span class='button-arrow'></span>");
		this.loginForm = new LoginInlineForm({
			cssClass: "login-form",
			testPath: "login-form",
			callback: function (_this) {
				return function (formData) {
					KD.mixpanel("Login submit, click");
					return _this.doLogin(formData)
				}
			}(this)
		});
		this.registerForm = new RegisterInlineForm({
			cssClass: "login-form",
			testPath: "register-form",
			callback: function (_this) {
				return function (formData) {
					KD.mixpanel("Register submit, click");
					return _this.doRegister(formData)
				}
			}(this)
		});
		this.redeemForm = new RedeemInlineForm({
			cssClass: "login-form",
			callback: function (_this) {
				return function (formData) {
					KD.mixpanel("Redeem submit, click");
					return _this.doRedeem(formData)
				}
			}(this)
		});
		this.recoverForm = new RecoverInlineForm({
			cssClass: "login-form",
			callback: function (_this) {
				return function (formData) {
					KD.mixpanel("Recover password submit, click");
					return _this.doRecover(formData)
				}
			}(this)
		});
		this.resendForm = new ResendEmailConfirmationLinkInlineForm({
			cssClass: "login-form",
			callback: function (_this) {
				return function (formData) {
					_this.resendEmailConfirmationToken(formData);
					return KD.mixpanel("Resend email button, click")
				}
			}(this)
		});
		this.resetForm = new ResetInlineForm({
			cssClass: "login-form",
			callback: function (_this) {
				return function (formData) {
					return _this.doReset(formData)
				}
			}(this)
		});
		this.finishRegistrationForm = new FinishRegistrationForm({
			cssClass: "login-form foobar",
			callback: function (_this) {
				return function (formData) {
					return _this.doFinishRegistration(formData)
				}
			}(this)
		});
		this.headBanner = new KDCustomHTMLView({
			domId: "invite-recovery-notification-bar",
			cssClass: "invite-recovery-notification-bar hidden",
			partial: "..."
		});
		this.failureNotice = new KDCustomHTMLView({
			cssClass: "failure-notice hidden"
		});
		setValue = function (_this) {
			return function (field, value) {
				var _ref, _ref1, _ref2, _ref3;
				null != (_ref = _this.registerForm[field]) && null != (_ref1 = _ref.input) && _ref1.setValue(value);
				return null != (_ref2 = _this.registerForm[field]) && null != (_ref3 = _ref2.placeholder) ? _ref3.setClass("out") : void 0
			}
		}(this);
		mainController = KD.getSingleton("mainController");
		mainController.on("ForeignAuthCompleted", function (_this) {
			return function (provider) {
				var isUserLoggedIn, params;
				isUserLoggedIn = KD.isLoggedIn();
				params = {
					isUserLoggedIn: isUserLoggedIn,
					provider: provider
				};
				return KD.getSingleton("mainController").handleOauthAuth(params, function (err, resp) {
					var account, field, isNewUser, replacementToken, userInfo, value;
					if (err) {
						showError(err);
						return KD.mixpanel("Authenticate with oauth, fail", {
							provider: provider
						})
					}
					account = resp.account, replacementToken = resp.replacementToken, isNewUser = resp.isNewUser, userInfo = resp.userInfo;
					if (isNewUser) {
						KD.getSingleton("router").handleRoute("/Register");
						_this.animateToForm("register");
						for (field in userInfo)
							if (__hasProp.call(userInfo, field)) {
								value = userInfo[field];
								setValue(field, value)
							}
						return KD.mixpanel("Github auth register, success")
					}
					if (isUserLoggedIn) {
						mainController.emit("ForeignAuthSuccess." + provider);
						KD.mixpanel("Authenticate with oauth, success", {
							provider: provider
						});
						return new KDNotificationView({
							title: "Your " + provider.capitalize() + " account has been linked.",
							type: "mini"
						})
					}
					_this.afterLoginCallback(err, {
						account: account,
						replacementToken: replacementToken
					});
					return KD.mixpanel("Github auth login, success")
				})
			}
		}(this))
	}
	var backgroundImageNr, backgroundImages, runExternal, showError, stop;
	__extends(LoginView, _super);
	stop = KD.utils.stopDOMEvent;
	LoginView.backgroundImageNr = backgroundImageNr = KD.utils.getRandomNumber(15);
	backgroundImages = [{
		path: "1",
		href: "http://www.flickr.com/photos/charliefoster/",
		photographer: "Charlie Foster"
	}, {
		path: "2",
		href: "http://pican.de/",
		photographer: "Dietmar Becker"
	}, {
		path: "3",
		href: "http://www.station75.com/",
		photographer: "Marcin Czerwinski"
	}, {
		path: "4",
		href: "http://www.station75.com/",
		photographer: "Marcin Czerwinski"
	}, {
		path: "5",
		href: "http://www.flickr.com/photos/discomethod/sets/72157635620513053/",
		photographer: "Anton Sulsky"
	}, {
		path: "6",
		href: "http://www.jfrwebdesign.nl/",
		photographer: "Joeri RÃ¶mer"
	}, {
		path: "7",
		href: "http://be.net/Zugr",
		photographer: "Zugr"
	}, {
		path: "8",
		href: "",
		photographer: "Mark Doda"
	}, {
		path: "9",
		href: "http://www.twitter.com/rickwaalders",
		photographer: "Rick Waalders"
	}, {
		path: "10",
		href: "http://madebyvadim.com/",
		photographer: "Vadim Sherbakov"
	}, {
		path: "11",
		href: "",
		photographer: "Zwaddi"
	}, {
		path: "12",
		href: "http://be.net/Zugr",
		photographer: "Zugr"
	}, {
		path: "13",
		href: "http://www.romainbriaux.fr/",
		photographer: "Romain Briaux"
	}, {
		path: "14",
		href: "https://twitter.com/Petchy19",
		photographer: "petradr"
	}, {
		path: "15",
		href: "http://rileyb.me/",
		photographer: "Riley Briggs"
	}, {
		path: "16",
		href: "http://chloecolorphotography.tumblr.com/",
		photographer: "Chloe Benko-Prieur"
	}];
	LoginView.prototype.viewAppended = function () {
		var message, query, suffix;
		this.setClass("login-screen login");
		this.setTemplate(this.pistachio());
		this.template.update();
		query = KD.utils.parseQuery(document.location.search.replace("?", ""));
		if (query.warning) {
			suffix = "comment" === query.type ? "post a comment" : "like an activity";
			message = "You need to be logged in to " + suffix;
			return KD.getSingleton("mainView").createGlobalNotification({
				title: message,
				type: "yellow",
				content: "",
				closeTimer: 4e3,
				container: this
			})
		}
	};
	LoginView.prototype.pistachio = function () {
		return '<div class=\'tint\'></div>\n{{> this.logo}}\n<div class="flex-wrapper">\n  {{> this.formHeader}}\n  <div class="login-form-holder lf">\n    {{> this.loginForm}}\n  </div>\n  <div class="login-form-holder rf">\n    {{> this.registerForm}}\n  </div>\n  <div class="login-form-holder frf">\n    {{> this.finishRegistrationForm}}\n  </div>\n  <div class="login-form-holder rdf">\n    {{> this.redeemForm}}\n  </div>\n  <div class="login-form-holder rcf">\n    {{> this.recoverForm}}\n  </div>\n  <div class="login-form-holder rsf">\n    {{> this.resetForm}}\n  </div>\n  <div class="login-form-holder resend-confirmation-form">\n    {{> this.resendForm}}\n  </div>\n  {{> this.failureNotice}}\n  <div class="login-footer">\n    {{> this.github}} {{> this.goToRecoverLink}}\n  </div>\n</div>\n<footer>\n  <a href="/acceptable.html" target="_blank">Acceptable user policy</a><a href="/copyright.html" target="_blank">Copyright/DMCA guidelines</a><a href="/tos.html" target="_blank">Terms of service</a><a href="/privacy.html" target="_blank">Privacy policy</a><a href="' + backgroundImages[backgroundImageNr].href + '" target="_blank"><span>photo by </span>' + backgroundImages[backgroundImageNr].photographer + "</a>\n</footer>"
	};
	LoginView.prototype.doReset = function (_arg) {
		var password, recoveryToken;
		recoveryToken = _arg.recoveryToken, password = _arg.password;
		return KD.remote.api.JPasswordRecovery.resetPassword(recoveryToken, password, function (_this) {
			return function (err, username) {
				if (err) return new KDNotificationView({
					title: "An error occurred: " + err.message
				});
				_this.resetForm.button.hideLoader();
				_this.resetForm.reset();
				_this.headBanner.hide();
				return _this.doLogin({
					username: username,
					password: password
				})
			}
		}(this))
	};
	LoginView.prototype.doRecover = function (formData) {
		return KD.remote.api.JPasswordRecovery.recoverPassword(formData["username-or-email"], function (_this) {
			return function (err) {
				var entryPoint;
				_this.recoverForm.button.hideLoader();
				if (err) return new KDNotificationView({
					title: "An error occurred: " + err.message
				});
				_this.recoverForm.reset();
				entryPoint = KD.config.entryPoint;
				KD.getSingleton("router").handleRoute("/Login", {
					entryPoint: entryPoint
				});
				new KDNotificationView({
					title: "Check your email",
					content: "We've sent you a password recovery code.",
					duration: 4500
				});
				return KD.mixpanel("Recover password, success")
			}
		}(this))
	};
	LoginView.prototype.resendEmailConfirmationToken = function (formData) {
		return KD.remote.api.JPasswordRecovery.recoverPassword(formData["username-or-email"], function (_this) {
			return function (err) {
				var entryPoint;
				_this.resendForm.button.hideLoader();
				if (err) return new KDNotificationView({
					title: "An error occurred: " + err.message
				});
				_this.resendForm.reset();
				entryPoint = KD.config.entryPoint;
				KD.getSingleton("router").handleRoute("/Login", {
					entryPoint: entryPoint
				});
				return new KDNotificationView({
					title: "Check your email",
					content: "We've sent you a confirmation mail.",
					duration: 4500
				})
			}
		}(this))
	};
	LoginView.prototype.doRegister = function (formData) {
		var _ref, _ref1;
		KD.getSingleton("mainController").isLoggingIn(!0);
		formData.agree = "on";
		formData.referrer = Cookies.get("referrer");
		this.registerForm.notificationsDisabled = !0;
		null != (_ref = this.registerForm.notification) && _ref.destroy();
		null != (_ref1 = KD.getSingleton("groupsController").groupChannel) && _ref1.close();
		return KD.remote.api.JUser.convert(formData, function (_this) {
			return function (err, _arg) {
				var account, message, newToken, title, titleText;
				account = _arg.account, newToken = _arg.newToken;
				null == account && (account = KD.whoami());
				_this.registerForm.button.hideLoader();
				if (err) {
					message = err.message;
					warn("An error occured while registering:", err);
					_this.registerForm.notificationsDisabled = !1;
					return _this.registerForm.emit("SubmitFailed", message)
				}
				KD.mixpanel.alias(account.profile.nickname);
				KD.mixpanel("Signup, success");
				Cookies.set("newRegister", !0);
				KD.getSingleton("mainController").swapAccount({
					account: account,
					replacementToken: newToken
				});
				titleText = err ? "Quota exceeded and could not join to the group. Please contact the group admin" : "You're good to go, Enjoy!";
				title = "<span>" + titleText + "</span>";
				new KDNotificationView({
					cssClass: "login",
					title: title,
					duration: 2e3
				});
				if (!KD.remote.isConnected()) return location.reload();
				_this.headBanner.hide();
				err && (window.location.href = "/");
				return KD.utils.wait(1e3, function () {
					_this.registerForm.reset();
					_this.registerForm.button.hideLoader();
					_this.hide();
					return KD.singleton("router").handleRoute("/Activity")
				})
			}
		}(this))
	};
	LoginView.prototype.doFinishRegistration = function (formData) {
		return KD.getSingleton("mainController").handleFinishRegistration(formData, this.bound("afterLoginCallback"))
	};
	LoginView.prototype.doLogin = function (credentials) {
		KD.singletons.localSync.removeLocalContents();
		return KD.getSingleton("mainController").handleLogin(credentials, this.bound("afterLoginCallback"))
	};
	runExternal = function (token) {
		KD.getSingleton("kiteController").run({
			kiteName: "externals",
			method: "import",
			correlationName: " ",
			withArgs: {
				value: token,
				serviceName: "github",
				userId: KD.whoami().getId()
			}
		});
		return function (err, status) {
			return log("Status of fetching stuff from external: " + status)
		}
	};
	LoginView.prototype.afterLoginCallback = function (err, params) {
		var account, entryPoint, firstRoute, mainController, mainView;
		null == params && (params = {});
		this.loginForm.button.hideLoader();
		entryPoint = KD.config.entryPoint;
		if (err) {
			showError(err);
			this.loginForm.resetDecoration();
			this.$(".flex-wrapper").removeClass("shake");
			return KD.utils.defer(function (_this) {
				return function () {
					return _this.$(".flex-wrapper").addClass("animate shake")
				}
			}(this))
		}
		account = params.account;
		account && KD.utils.setPreferredDomain(account);
		mainController = KD.getSingleton("mainController");
		mainView = mainController.mainViewController.getView();
		mainView.show();
		mainView.$().css("opacity", 1);
		firstRoute = KD.getSingleton("router").visitedRoutes.first;
		firstRoute && /^\/(?:Reset|Register|Confirm|R)\//.test(firstRoute) && (firstRoute = "/Activity");
		this.appStorage = KD.getSingleton("appStorageController").storage("Login", "1.0");
		return this.appStorage.fetchValue("redirectTo", function (_this) {
			return function (redirectTo) {
				if (redirectTo) {
					firstRoute = "/" + redirectTo;
					_this.appStorage.unsetKey("redirectTo", function (err) {
						return err ? warn("Failed to reset redirectTo", err) : void 0
					})
				}
				KD.getSingleton("appManager").quitAll();
				KD.getSingleton("router").handleRoute(firstRoute || "/Activity", {
					replaceState: !0,
					entryPoint: entryPoint
				});
				KD.getSingleton("groupsController").on("GroupChanged", function () {
					var _ref;
					null != (_ref = _this.headBanner) && _ref.hide();
					return _this.loginForm.reset()
				});
				new KDNotificationView({
					cssClass: "login",
					title: "<span></span>Happy Koding!",
					duration: 2e3
				});
				_this.loginForm.reset();
				KD.mixpanel("Login, success");
				return redirectTo ? window.location.reload() : void 0
			}
		}(this))
	};
	LoginView.prototype.doRedeem = function (_arg) {
		var inviteCode, _ref;
		inviteCode = _arg.inviteCode;
		return (null != (_ref = KD.config.entryPoint) ? _ref.slug : void 0) || KD.isLoggedIn() ? KD.remote.cacheable(KD.config.entryPoint.slug, function (_this) {
			return function (err, _arg1) {
				var group;
				group = _arg1[0];
				return group.redeemInvitation(inviteCode, function (err) {
					_this.redeemForm.button.hideLoader();
					if (err) return KD.notify_(err.message || err);
					KD.notify_("Success!");
					KD.getSingleton("mainController").accountChanged(KD.whoami());
					return KD.mixpanel("Redeem, success")
				})
			}
		}(this)) : void 0
	};
	LoginView.prototype.showHeadBanner = function (message, callback) {
		$("body").addClass("recovery");
		this.headBannerMsg = message;
		this.headBanner.updatePartial(this.headBannerMsg);
		this.headBanner.unsetClass("hidden");
		this.headBanner.setClass("show");
		this.headBanner.off("click");
		this.headBanner.once("click", callback);
		return this.headBanner.appendToDomBody()
	};
	LoginView.prototype.headBannerShowInvitation = function (invite) {
		this.showHeadBanner("Cool! you got an invite! <span>If you already have an account click here to sign in.</span>", function (_this) {
			return function () {
				KD.singleton("router").handleRoute("/Login");
				return _this.headBanner.hide()
			}
		}(this));
		KD.getSingleton("router").clear(this.getRouteWithEntryPoint("Register"));
		$("body").removeClass("recovery");
		return this.show(function (_this) {
			return function () {
				_this.animateToForm("register");
				_this.$(".flex-wrapper").addClass("taller");
				return KD.getSingleton("mainController").emit("InvitationReceived", invite)
			}
		}(this))
	};
	LoginView.prototype.hide = function (callback) {
		this.$(".flex-wrapper").removeClass("expanded");
		this.emit("LoginViewHidden");
		this.setClass("hidden");
		return "function" == typeof callback ? callback() : void 0
	};
	LoginView.prototype.show = function (callback) {
		this.unsetClass("hidden");
		this.emit("LoginViewShown");
		this.hidden = !1;
		return "function" == typeof callback ? callback() : void 0
	};
	LoginView.prototype.setCustomDataToForm = function (type, data) {
		var formName;
		formName = "" + type + "Form";
		return this[formName].addCustomData(data)
	};
	LoginView.prototype.animateToForm = function (name) {
		return this.show(function (_this) {
			return function () {
				var _ref;
				switch (name) {
				case "register":
					KD.remote.api.JUser.isRegistrationEnabled(function (status) {
						if (status === !1) {
							log("Registrations are disabled!!!");
							_this.setFailureNotice({
								cssClass: "registrations-disabled",
								title: "REGISTRATIONS ARE CURRENTLY DISABLED",
								message: "We're sorry for that, please follow us on <a href='http://twitter.com/koding' target='_blank'>twitter</a> if you want to be notified when registrations are enabled again."
							});
							_this.github.hide();
							_this.$(".login-footer").addClass("hidden");
							return _this.animateToForm("failureNotice")
						}
						_this.github.show();
						return _this.$(".login-footer").removeClass("hidden")
					});
					KD.mixpanel("Register form, click");
					break;
				case "home":
					null != (_ref = parent.notification) && _ref.destroy();
					if (null != _this.headBannerMsg) {
						_this.headBanner.updatePartial(_this.headBannerMsg);
						_this.headBanner.show()
					}
				}
				_this.unsetClass("register recover login reset home resendEmail finishRegistration");
				_this.emit("LoginViewAnimated", name);
				_this.setClass(name);
				_this.$(".flex-wrapper").removeClass("three one");
				_this.formHeader.hide();
				_this.goToRecoverLink.show();
				switch (name) {
				case "register":
					return _this.registerForm.email.input.setFocus();
				case "finishRegistration":
					return _this.finishRegistrationForm.username.input.setFocus();
				case "redeem":
					_this.$(".flex-wrapper").addClass("one");
					return _this.redeemForm.inviteCode.input.setFocus();
				case "login":
					_this.formHeader.show();
					_this.formHeader.updatePartial("Don't have an account yet? ");
					_this.formHeader.addSubView(_this.goToRegisterLink);
					return _this.loginForm.username.input.setFocus();
				case "recover":
					_this.$(".flex-wrapper").addClass("one");
					_this.github.hide();
					_this.goToRecoverLink.hide();
					return _this.recoverForm.usernameOrEmail.input.setFocus();
				case "resendEmail":
					_this.$(".flex-wrapper").addClass("one");
					return _this.resendForm.usernameOrEmail.input.setFocus();
				case "failureNotice":
					_this.$(".flex-wrapper").addClass("one");
					_this.github.hide();
					_this.$(".login-footer").addClass("hidden");
					return _this.failureNotice.show();
				case "reset":
					_this.formHeader.show();
					_this.formHeader.updatePartial("Set your new password below");
					_this.goToRecoverLink.hide();
					return _this.github.hide()
				}
			}
		}(this))
	};
	LoginView.prototype.getRouteWithEntryPoint = function (route) {
		var entryPoint;
		entryPoint = KD.config.entryPoint;
		return entryPoint && entryPoint.slug !== KD.defaultSlug ? "/" + entryPoint.slug + "/" + route : "/" + route
	};
	showError = function (err) {
		var name, nickname, _ref;
		if (err.code && 403 === err.code) {
			_ref = err.data, name = _ref.name, nickname = _ref.nickname;
			return KD.getSingleton("appManager").tell("Account", "displayConfirmEmailModal", name, nickname)
		}
		return err.message.length > 50 ? new KDModalView({
			title: "Something is wrong!",
			width: 500,
			overlay: !0,
			cssClass: "new-kdmodal",
			content: "<div class='modalformline'>" + err.message + "</div>"
		}) : new KDNotificationView({
			title: err.message,
			duration: 1e3
		})
	};
	LoginView.prototype.setFailureNotice = function (_arg) {
		var cssClass, message, title;
		cssClass = _arg.cssClass, title = _arg.title, message = _arg.message;
		cssClass && this.failureNotice.setClass(cssClass);
		return this.failureNotice.updatePartial("<strong>" + title + "</strong>\n<p>" + message + "</p>")
	};
	return LoginView
}(JView);
var LoginInlineForm, LoginViewInlineForm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LoginViewInlineForm = function (_super) {
	function LoginViewInlineForm() {
		return LoginViewInlineForm.__super__.constructor.apply(this, arguments)
	}
	__extends(LoginViewInlineForm, _super);
	JView.mixin(LoginViewInlineForm.prototype);
	LoginViewInlineForm.prototype.viewAppended = function () {
		this.setTemplate(this.pistachio());
		this.template.update();
		return this.on("FormValidationFailed", function (_this) {
			return function () {
				return _this.button.hideLoader()
			}
		}(this))
	};
	LoginViewInlineForm.prototype.pistachio = function () {};
	return LoginViewInlineForm
}(KDFormView);
LoginInlineForm = function (_super) {
	function LoginInlineForm() {
		LoginInlineForm.__super__.constructor.apply(this, arguments);
		this.username = new LoginInputView({
			inputOptions: {
				name: "username",
				forceCase: "lowercase",
				placeholder: "username or email",
				testPath: "login-form-username",
				validate: {
					event: "blur",
					rules: {
						required: !0
					},
					messages: {
						required: "Please enter a username."
					}
				}
			}
		});
		this.password = new LoginInputView({
			inputOptions: {
				name: "password",
				type: "password",
				placeholder: "password",
				testPath: "login-form-password",
				validate: {
					event: "blur",
					rules: {
						required: !0
					},
					messages: {
						required: "Please enter your password."
					}
				}
			}
		});
		this.button = new KDButtonView({
			title: "Sign in",
			style: "solid medium green",
			type: "submit",
			loader: !0
		})
	}
	__extends(LoginInlineForm, _super);
	LoginInlineForm.prototype.activate = function () {
		return this.username.setFocus()
	};
	LoginInlineForm.prototype.resetDecoration = function () {
		this.username.resetDecoration();
		return this.password.resetDecoration()
	};
	LoginInlineForm.prototype.pistachio = function () {
		return "<div>{{> this.username}}</div>\n<div>{{> this.password}}</div>\n<div>{{> this.button}}</div>"
	};
	return LoginInlineForm
}(LoginViewInlineForm);
var LoginInputView, LoginInputViewWithLoader, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LoginInputView = function (_super) {
	function LoginInputView(options, data) {
		var inputOptions, placeholder, validate;
		null == options && (options = {});
		inputOptions = options.inputOptions;
		options.cssClass = KD.utils.curry("login-input-view", options.cssClass);
		inputOptions || (inputOptions = {});
		inputOptions.cssClass = KD.utils.curry("thin medium", inputOptions.cssClass);
		inputOptions.decorateValidation = !1;
		placeholder = inputOptions.placeholder, validate = inputOptions.validate;
		delete inputOptions.placeholder;
		delete options.inputOptions;
		validate && (validate.notifications = !1);
		LoginInputView.__super__.constructor.call(this, options, null);
		this.input = new KDInputView(inputOptions, data);
		this.icon = new KDCustomHTMLView({
			cssClass: "validation-icon"
		});
		this.placeholder = new KDCustomHTMLView({
			cssClass: "placeholder-helper",
			partial: placeholder || inputOptions.name
		});
		this.errors = {};
		this.errorMessage = "";
		this.input.on("keyup", this.bound("inputReceivedKeyup"));
		this.input.on("focus", this.bound("inputReceivedFocus"));
		this.input.on("blur", this.bound("inputReceivedBlur"));
		this.input.on("ValidationError", this.bound("decorateValidation"));
		this.input.on("ValidationPassed", this.bound("decorateValidation"));
		this.input.on("ValidationFeedbackCleared", this.bound("resetDecoration"))
	}
	__extends(LoginInputView, _super);
	LoginInputView.prototype.setFocus = function () {
		return this.input.setFocus()
	};
	LoginInputView.prototype.inputReceivedKeyup = function () {
		return this.input.getValue().length > 0 ? this.placeholder.setClass("out") : this.placeholder.unsetClass("out")
	};
	LoginInputView.prototype.inputReceivedFocus = function () {
		return this.input.getValue().length > 0 ? this.placeholder.unsetClass("puff") : void 0
	};
	LoginInputView.prototype.inputReceivedBlur = function () {
		return this.input.getValue().length > 0 ? this.placeholder.setClass("puff") : this.placeholder.unsetClass("puff")
	};
	LoginInputView.prototype.resetDecoration = function () {
		return this.unsetClass("validation-error validation-passed")
	};
	LoginInputView.prototype.decorateValidation = function (err) {
		this.resetDecoration();
		if (this.input.getValue().length) {
			err ? this.icon.setTooltip({
				title: "<p>" + err + "</p>"
			}) : this.icon.unsetTooltip();
			return this.setClass(err ? "validation-error" : "validation-passed")
		}
	};
	LoginInputView.prototype.pistachio = function () {
		return "{{> this.input}}{{> this.placeholder}}{{> this.icon}}"
	};
	return LoginInputView
}(JView);
LoginInputViewWithLoader = function (_super) {
	function LoginInputViewWithLoader() {
		LoginInputViewWithLoader.__super__.constructor.apply(this, arguments);
		this.loader = new KDLoaderView({
			cssClass: "input-loader",
			size: {
				width: 32,
				height: 32
			},
			loaderOptions: {
				color: "#3E4F55"
			}
		});
		this.loader.hide()
	}
	__extends(LoginInputViewWithLoader, _super);
	LoginInputViewWithLoader.prototype.pistachio = function () {
		return "{{> this.input}}{{> this.loader}}{{> this.placeholder}}{{> this.icon}}"
	};
	return LoginInputViewWithLoader
}(LoginInputView);
var LoginOptions, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
LoginOptions = function (_super) {
	function LoginOptions() {
		return LoginOptions.__super__.constructor.apply(this, arguments)
	}
	__extends(LoginOptions, _super);
	LoginOptions.prototype.viewAppended = function () {
		var inFrame, optionsHolder;
		inFrame = KD.runningInFrame();
		this.addSubView(new KDHeaderView({
			type: "small",
			title: "SIGN IN WITH:"
		}));
		this.addSubView(optionsHolder = new KDCustomHTMLView({
			tagName: "ul",
			cssClass: "login-options"
		}));
		optionsHolder.addSubView(new KDCustomHTMLView({
			tagName: "li",
			cssClass: "koding active",
			partial: "koding",
			tooltip: {
				title: "<p class='login-tip'>Sign in with Koding</p>"
			}
		}));
		return optionsHolder.addSubView(new KDCustomHTMLView({
			tagName: "li",
			cssClass: "github " + (inFrame ? "hidden" : ""),
			partial: "github",
			click: function () {
				return new KDNotificationView({
					title: "Login restricted"
				})
			},
			tooltip: {
				title: "<p class='login-tip'>Sign in with GitHub</p>"
			}
		}))
	};
	return LoginOptions
}(KDView);
var RegisterOptions, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
RegisterOptions = function (_super) {
	function RegisterOptions() {
		return RegisterOptions.__super__.constructor.apply(this, arguments)
	}
	__extends(RegisterOptions, _super);
	RegisterOptions.prototype.viewAppended = function () {
		var inFrame, optionsHolder;
		inFrame = KD.runningInFrame();
		this.addSubView(optionsHolder = new KDCustomHTMLView({
			tagName: "ul",
			cssClass: "login-options"
		}));
		optionsHolder.addSubView(new KDCustomHTMLView({
			tagName: "li",
			cssClass: "koding active",
			partial: "koding",
			tooltip: {
				title: "<p class='login-tip'>Register with Koding</p>"
			}
		}));
		return optionsHolder.addSubView(new KDCustomHTMLView({
			tagName: "li",
			cssClass: "github active " + (inFrame ? "hidden" : ""),
			partial: "github",
			click: function () {
				return KD.getSingleton("oauthController").openPopup("github")
			},
			tooltip: {
				title: "<p class='login-tip'>Register with GitHub</p>"
			}
		}))
	};
	return RegisterOptions
}(KDView);
var ResendEmailConfirmationLinkInlineForm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ResendEmailConfirmationLinkInlineForm = function (_super) {
	function ResendEmailConfirmationLinkInlineForm() {
		ResendEmailConfirmationLinkInlineForm.__super__.constructor.apply(this, arguments);
		this.usernameOrEmail = new LoginInputView({
			inputOptions: {
				name: "username-or-email",
				placeholder: "username or email",
				testPath: "recover-password-input",
				validate: {
					container: this,
					rules: {
						required: !0
					},
					messages: {
						required: "Please enter your username or email."
					}
				}
			}
		});
		this.button = new KDButtonView({
			title: "Resend email",
			style: "solid green medium",
			type: "submit",
			loader: !0
		})
	}
	__extends(ResendEmailConfirmationLinkInlineForm, _super);
	ResendEmailConfirmationLinkInlineForm.prototype.pistachio = function () {
		return "<div>{{> this.usernameOrEmail}}</div>\n<div>{{> this.button}}</div>"
	};
	return ResendEmailConfirmationLinkInlineForm
}(LoginViewInlineForm);
var RegisterInlineForm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
RegisterInlineForm = function (_super) {
	function RegisterInlineForm(options, data) {
		null == options && (options = {});
		RegisterInlineForm.__super__.constructor.call(this, options, data);
		this.email = new LoginInputViewWithLoader({
			inputOptions: {
				name: "email",
				placeholder: "email address",
				testPath: "register-form-email",
				validate: this.getEmailValidator(),
				decorateValidation: !1
			}
		});
		this.avatar = new AvatarStaticView({
			size: {
				width: 55,
				height: 55
			}
		}, {
			profile: {
				hash: md5.digest("there is no such email"),
				firstName: "New koding user"
			}
		});
		this.avatar.hide();
		this.username = new LoginInputViewWithLoader({
			inputOptions: {
				name: "username",
				forceCase: "lowercase",
				placeholder: "username",
				testPath: "register-form-username",
				keyup: function (_this) {
					return function () {
						var val;
						return _this.domain.updatePartial("" !== (val = _this.username.input.getValue()).trim() ? "" + val + ".kd.io" : "username.kd.io")
					}
				}(this),
				validate: {
					container: this,
					rules: {
						required: !0,
						rangeLength: [4, 25],
						regExp: /^[a-z\d]+([-][a-z\d]+)*$/i,
						usernameCheck: function (_this) {
							return function (input, event) {
								return _this.usernameCheck(input, event)
							}
						}(this),
						finalCheck: function (_this) {
							return function (input, event) {
								return _this.usernameCheck(input, event, 0)
							}
						}(this)
					},
					messages: {
						required: "Please enter a username.",
						regExp: "For username only lowercase letters and numbers are allowed!",
						rangeLength: "Username should be between 4 and 25 characters!"
					},
					events: {
						required: "blur",
						rangeLength: "keyup",
						regExp: "keyup",
						usernameCheck: "keyup",
						finalCheck: "blur"
					}
				},
				decorateValidation: !1
			}
		});
		this.button = new KDButtonView({
			title: "Create account",
			type: "submit",
			style: "solid green medium",
			loader: !0
		});
		this.invitationCode = new LoginInputView({
			cssClass: "hidden",
			inputOptions: {
				name: "inviteCode",
				type: "hidden"
			}
		});
		this.domain = new KDCustomHTMLView({
			tagName: "strong",
			partial: "username.kd.io"
		});
		this.on("SubmitFailed", function (_this) {
			return function () {
				return _this.button.hideLoader()
			}
		}(this))
	}
	var usernameCheckTimer;
	__extends(RegisterInlineForm, _super);
	usernameCheckTimer = null;
	RegisterInlineForm.prototype.reset = function () {
		var input, inputs, _i, _len;
		inputs = KDFormView.findChildInputs(this);
		for (_i = 0, _len = inputs.length; _len > _i; _i++) {
			input = inputs[_i];
			input.clearValidationFeedback()
		}
		return RegisterInlineForm.__super__.reset.apply(this, arguments)
	};
	RegisterInlineForm.prototype.usernameCheck = function (input, event, delay) {
		var name;
		null == delay && (delay = 800);
		if (9 !== (null != event ? event.which : void 0) && !(input.getValue().length < 4)) {
			clearTimeout(usernameCheckTimer);
			input.setValidationResult("usernameCheck", null);
			name = input.getValue();
			return input.valid ? usernameCheckTimer = setTimeout(function (_this) {
				return function () {
					_this.username.loader.show();
					return KD.remote.api.JUser.usernameAvailable(name, function (err, response) {
						var forbidden, kodingUser;
						_this.username.loader.hide();
						kodingUser = response.kodingUser, forbidden = response.forbidden;
						return err ? (null != response ? response.kodingUser : void 0) ? input.setValidationResult("usernameCheck", 'Sorry, "' + name + '" is already taken!') : void 0 : forbidden ? input.setValidationResult("usernameCheck", 'Sorry, "' + name + '" is forbidden to use!') : kodingUser ? input.setValidationResult("usernameCheck", 'Sorry, "' + name + '" is already taken!') : input.setValidationResult("usernameCheck", null)
					})
				}
			}(this), delay) : void 0
		}
	};
	RegisterInlineForm.prototype.userAvatarFeedback = function (input) {
		if (input.valid) {
			this.avatar.setData({
				profile: {
					hash: md5.digest(input.getValue()),
					firstName: "New koding user"
				}
			});
			this.avatar.render();
			return this.showUserAvatar()
		}
		return this.hideUserAvatar()
	};
	RegisterInlineForm.prototype.showUserAvatar = function () {
		return this.avatar.show()
	};
	RegisterInlineForm.prototype.hideUserAvatar = function () {
		return this.avatar.hide()
	};
	RegisterInlineForm.prototype.viewAppended = function () {
		RegisterInlineForm.__super__.viewAppended.apply(this, arguments);
		return KD.getSingleton("mainController").on("InvitationReceived", function (_this) {
			return function (invite) {
				var origin;
				_this.$(".invitation-field").addClass("hidden");
				_this.$(".invited-by").removeClass("hidden");
				origin = invite.origin;
				_this.invitationCode.input.setValue(invite.code);
				_this.email.input.setValue(invite.email);
				_this.email.placeholder.setClass("out");
				return "JAccount" === origin.constructorName ? KD.remote.cacheable([origin], function (err, _arg) {
					var account;
					account = _arg[0];
					_this.addSubView(new AvatarStaticView({
						size: {
							width: 30,
							height: 30
						}
					}, account), ".invited-by .wrapper");
					return _this.addSubView(new ProfileTextView({}, account), ".invited-by .wrapper")
				}) : _this.$(".invited-by").addClass("hidden")
			}
		}(this))
	};
	RegisterInlineForm.prototype.getEmailValidator = function () {
		return {
			container: this,
			event: "blur",
			rules: {
				required: !0,
				email: !0,
				available: function (_this) {
					return function (input, event) {
						var email;
						if (9 !== (null != event ? event.which : void 0)) {
							input.setValidationResult("available", null);
							email = input.getValue();
							if (input.valid) {
								_this.email.loader.show();
								KD.remote.api.JUser.emailAvailable(email, function (err, response) {
									_this.email.loader.hide();
									return err ? warn(err) : response ? input.setValidationResult("available", null) : input.setValidationResult("available", 'Sorry, "' + email + '" is already in use!')
								})
							}
						}
					}
				}(this)
			},
			messages: {
				required: "Please enter your email address.",
				email: "That doesn't seem like a valid email address."
			}
		}
	};
	RegisterInlineForm.prototype.pistachio = function () {
		return "<section class='main-part'>\n  <div class='email'>{{> this.avatar}}{{> this.email}}</div>\n  <div class='username'>{{> this.username}}</div>\n  <div class='invitation-field invited-by hidden'>\n    <span class='icon'></span>\n    Invited by:\n    <span class='wrapper'></span>\n  </div>\n  <div class='hint'>Your username must be at least 4 characters and it\u2019s also going to be your {{> this.domain}} domain.</div>\n  <div>{{> this.button}}</div>\n  <div class=\"accept-tos\">\n  By creating an account, I accept Koding's <a href=\"/tos.html\" target=\"_blank\"> Terms of Service</a> and <a href=\"/privacy.html\" target=\"_blank\">Privacy Policy.</a>\n  </div>\n</section>\n{{> this.invitationCode}}"
	};
	return RegisterInlineForm
}(LoginViewInlineForm);
var RecoverInlineForm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
RecoverInlineForm = function (_super) {
	function RecoverInlineForm() {
		RecoverInlineForm.__super__.constructor.apply(this, arguments);
		this.usernameOrEmail = new LoginInputView({
			inputOptions: {
				name: "username-or-email",
				placeholder: "email",
				testPath: "recover-password-input",
				validate: {
					container: this,
					rules: {
						required: !0
					},
					messages: {
						required: "Please enter your email."
					}
				}
			}
		});
		this.button = new KDButtonView({
			title: "Recover password",
			style: "solid medium green",
			type: "submit",
			loader: !0
		})
	}
	__extends(RecoverInlineForm, _super);
	RecoverInlineForm.prototype.pistachio = function () {
		return "<div>{{> this.usernameOrEmail}}</div>\n<div>{{> this.button}}</div>"
	};
	return RecoverInlineForm
}(LoginViewInlineForm);
var ResetInlineForm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
ResetInlineForm = function (_super) {
	function ResetInlineForm() {
		ResetInlineForm.__super__.constructor.apply(this, arguments);
		this.password = new LoginInputView({
			inputOptions: {
				name: "password",
				type: "password",
				testPath: "recover-password",
				placeholder: "Enter a new password",
				validate: {
					container: this,
					rules: {
						required: !0,
						minLength: 8
					},
					messages: {
						required: "Please enter a password.",
						minLength: "Passwords should be at least 8 characters."
					}
				}
			}
		});
		this.passwordConfirm = new LoginInputView({
			inputOptions: {
				name: "passwordConfirm",
				type: "password",
				testPath: "recover-password-confirm",
				placeholder: "Confirm your password",
				validate: {
					container: this,
					rules: {
						required: !0,
						match: this.password.input,
						minLength: 8
					},
					messages: {
						required: "Please confirm your password.",
						match: "Password confirmation doesn't match!"
					}
				}
			}
		});
		this.button = new KDButtonView({
			title: "Reset password",
			style: "solid green medium",
			type: "submit",
			loader: !0
		})
	}
	__extends(ResetInlineForm, _super);
	ResetInlineForm.prototype.pistachio = function () {
		return "\n<div>{{> this.password}}</div>\n<div>{{> this.passwordConfirm}}</div>\n<div>{{> this.button}}</div>"
	};
	return ResetInlineForm
}(LoginViewInlineForm);
var FinishRegistrationForm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
FinishRegistrationForm = function (_super) {
	function FinishRegistrationForm() {
		FinishRegistrationForm.__super__.constructor.apply(this, arguments);
		this.email.input.setAttribute("readonly", "true");
		this.password = new LoginInputView({
			inputOptions: {
				name: "password",
				type: "password",
				testPath: "recover-password",
				placeholder: "Enter a new password",
				validate: {
					container: this,
					rules: {
						required: !0,
						minLength: 8
					},
					messages: {
						required: "Please enter a password.",
						minLength: "Passwords should be at least 8 characters."
					}
				}
			}
		});
		this.passwordConfirm = new LoginInputView({
			inputOptions: {
				name: "passwordConfirm",
				type: "password",
				testPath: "recover-password-confirm",
				placeholder: "Confirm your password",
				validate: {
					container: this,
					rules: {
						required: !0,
						match: this.password.input,
						minLength: 8
					},
					messages: {
						required: "Please confirm your password.",
						match: "Password confirmation doesn't match!"
					}
				}
			}
		});
		this.button = new KDButtonView({
			title: "FINISH REGISTRATION",
			type: "submit",
			style: "solid green",
			loader: !0
		})
	}
	__extends(FinishRegistrationForm, _super);
	FinishRegistrationForm.prototype.getEmailValidator = function () {};
	FinishRegistrationForm.prototype.setRegistrationDetails = function (details) {
		var key, val, _ref, _ref1, _results;
		_results = [];
		for (key in details)
			if (__hasProp.call(details, key)) {
				val = details[key];
				_results.push(null != (_ref = this[key]) && null != (_ref1 = _ref.input) && "function" == typeof _ref1.setValue ? _ref1.setValue(val) : void 0)
			}
		return _results
	};
	FinishRegistrationForm.prototype.pistachio = function () {
		return "<div class='login-hint'>Complete your registration:</div>\n<div class='email'>{{> this.avatar}}{{> this.email}}</div>\n<div class='username'>{{> this.username}}</div>\n<div>{{> this.password}}</div>\n<div>{{> this.passwordConfirm}}</div>\n<div>{{> this.button}}</div>"
	};
	return FinishRegistrationForm
}(RegisterInlineForm);
var RedeemInlineForm, __hasProp = {}.hasOwnProperty,
	__extends = function (child, parent) {
		function ctor() {
			this.constructor = child
		}
		for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
		ctor.prototype = parent.prototype;
		child.prototype = new ctor;
		child.__super__ = parent.prototype;
		return child
	};
RedeemInlineForm = function (_super) {
	function RedeemInlineForm(options, data) {
		null == options && (options = {});
		RedeemInlineForm.__super__.constructor.call(this, options, data);
		this.inviteCode = new LoginInputView({
			inputOptions: {
				name: "inviteCode",
				placeholder: "Enter your invite code",
				validate: {
					container: this,
					rules: {
						required: !0
					},
					messages: {
						required: "Please enter your invite code."
					}
				}
			}
		});
		this.button = new KDButtonView({
			title: "Redeem",
			style: "solid medium green",
			type: "submit",
			loader: !0
		})
	}
	__extends(RedeemInlineForm, _super);
	RedeemInlineForm.prototype.pistachio = function () {
		return "<div>{{> this.inviteCode}}</div>\n<div>{{> this.button}}</div>"
	};
	return RedeemInlineForm
}(LoginViewInlineForm);

//# sourceMappingURL=/a/js/koding.js.map
